<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - README</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/27/2022, 3:51:01 PM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="menu" id="menu"></div>
    <div class="mobile_menu" id="mobile_menu">
      <img src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/bars.svg" alt="" />
    </div>
    <div class="content markdown-body"><h1>bcrypt.js</h1>
<p>Optimized bcrypt in JavaScript with zero dependencies. Compatible to the C++ <a href="https://npmjs.org/package/bcrypt">bcrypt</a>
binding on node.js and also working in the browser.</p>
<p><a href="https://travis-ci.org/dcodeIO/bcrypt.js"><img alt="build static" src="https://travis-ci.org/dcodeIO/bcrypt.js.svg?branch=master" /></a> <a href="https://npmjs.org/package/bcryptjs"><img src="https://img.shields.io/npm/v/bcryptjs.svg" alt=""></a> <a href="https://npmjs.org/package/bcryptjs"><img src="https://img.shields.io/npm/dm/bcryptjs.svg" alt=""></a> <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=dcode%40dcode.io&item_name=Open%20Source%20Software%20Donation&item_number=dcodeIO%2Fbcrypt.js"><img alt="donate ❤" src="https://img.shields.io/badge/donate-❤-ff2244.svg"></a></p>
<h2>Security considerations</h2>
<p>Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the
iteration count can be increased to make it slower, so it remains resistant to brute-force search attacks even with
increasing computation power. (<a href="http://en.wikipedia.org/wiki/Bcrypt">see</a>)</p>
<p>While bcrypt.js is compatible to the C++ bcrypt binding, it is written in pure JavaScript and thus slower (<a href="https://github.com/dcodeIO/bcrypt.js/wiki/Benchmark">about 30%</a>), effectively reducing the number of iterations that can be
processed in an equal time span.</p>
<p>The maximum input length is 72 bytes (note that UTF8 encoded characters use up to 4 bytes) and the length of generated
hashes is 60 characters.</p>
<h2>Usage</h2>
<p>The library is compatible with CommonJS and AMD loaders and is exposed globally as <code>dcodeIO.bcrypt</code> if neither is
available.</p>
<h3>node.js</h3>
<p>On node.js, the inbuilt <a href="http://nodejs.org/api/crypto.html">crypto module</a>'s randomBytes interface is used to obtain
secure random numbers.</p>
<p><code>npm install bcryptjs</code></p>
<pre><code class="language-js">var bcrypt = require('bcryptjs');
...
</code></pre>
<h3>Browser</h3>
<p>In the browser, bcrypt.js relies on <a href="http://www.w3.org/TR/WebCryptoAPI">Web Crypto API</a>'s getRandomValues
interface to obtain secure random numbers. If no cryptographically secure source of randomness is available, you may
specify one through <a href="https://github.com/dcodeIO/bcrypt.js#setrandomfallbackrandom">bcrypt.setRandomFallback</a>.</p>
<pre><code class="language-js">var bcrypt = dcodeIO.bcrypt;
...
</code></pre>
<p>or</p>
<pre><code class="language-js">require.config({
    paths: { &quot;bcrypt&quot;: &quot;/path/to/bcrypt.js&quot; }
});
require([&quot;bcrypt&quot;], function(bcrypt) {
    ...
});
</code></pre>
<h2>Usage - Sync</h2>
<p>To hash a password:</p>
<pre><code class="language-javascript">var bcrypt = require('bcryptjs');
var salt = bcrypt.genSaltSync(10);
var hash = bcrypt.hashSync(&quot;B4c0/\/&quot;, salt);
// Store hash in your password DB.
</code></pre>
<p>To check a password:</p>
<pre><code class="language-javascript">// Load hash from your password DB.
bcrypt.compareSync(&quot;B4c0/\/&quot;, hash); // true
bcrypt.compareSync(&quot;not_bacon&quot;, hash); // false
</code></pre>
<p>Auto-gen a salt and hash:</p>
<pre><code class="language-javascript">var hash = bcrypt.hashSync('bacon', 8);
</code></pre>
<h2>Usage - Async</h2>
<p>To hash a password:</p>
<pre><code class="language-javascript">var bcrypt = require('bcryptjs');
bcrypt.genSalt(10, function(err, salt) {
    bcrypt.hash(&quot;B4c0/\/&quot;, salt, function(err, hash) {
        // Store hash in your password DB.
    });
});
</code></pre>
<p>To check a password:</p>
<pre><code class="language-javascript">// Load hash from your password DB.
bcrypt.compare(&quot;B4c0/\/&quot;, hash, function(err, res) {
    // res === true
});
bcrypt.compare(&quot;not_bacon&quot;, hash, function(err, res) {
    // res === false
});

// As of bcryptjs 2.4.0, compare returns a promise if callback is omitted:
bcrypt.compare(&quot;B4c0/\/&quot;, hash).then((res) =&gt; {
    // res === true
});
</code></pre>
<p>Auto-gen a salt and hash:</p>
<pre><code class="language-javascript">bcrypt.hash('bacon', 8, function(err, hash) {
});
</code></pre>
<p><strong>Note:</strong> Under the hood, asynchronisation splits a crypto operation into small chunks. After the completion of a chunk, the execution of the next chunk is placed on the back of <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop">JS event loop queue</a>, thus efficiently sharing the computational resources with the other operations in the queue.</p>
<h2>API</h2>
<h3>setRandomFallback(random)</h3>
<p>Sets the pseudo random number generator to use as a fallback if neither node's <code>crypto</code> module nor the Web Crypto
API is available. Please note: It is highly important that the PRNG used is cryptographically secure and that it is
seeded properly!</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>random</td>
<td><em>function(number):!Array.&lt;number&gt;</em></td>
<td>Function taking the number of bytes to generate as its sole argument, returning the corresponding array of cryptographically secure random byte values.</td>
</tr>
<tr>
<td><strong>@see</strong></td>
<td></td>
<td>http://nodejs.org/api/crypto.html</td>
</tr>
<tr>
<td><strong>@see</strong></td>
<td></td>
<td>http://www.w3.org/TR/WebCryptoAPI/</td>
</tr>
</tbody>
</table>
<p><strong>Hint:</strong> You might use <a href="https://github.com/rubycon/isaac.js">isaac.js</a> as a CSPRNG but you still have to make sure to
seed it properly.</p>
<h3>genSaltSync(rounds=, seed_length=)</h3>
<p>Synchronously generates a salt.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>rounds</td>
<td><em>number</em></td>
<td>Number of rounds to use, defaults to 10 if omitted</td>
</tr>
<tr>
<td>seed_length</td>
<td><em>number</em></td>
<td>Not supported.</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>string</em></td>
<td>Resulting salt</td>
</tr>
<tr>
<td><strong>@throws</strong></td>
<td><em>Error</em></td>
<td>If a random fallback is required but not set</td>
</tr>
</tbody>
</table>
<h3>genSalt(rounds=, seed_length=, callback)</h3>
<p>Asynchronously generates a salt.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>rounds</td>
<td><em>number | function(Error, string=)</em></td>
<td>Number of rounds to use, defaults to 10 if omitted</td>
</tr>
<tr>
<td>seed_length</td>
<td><em>number | function(Error, string=)</em></td>
<td>Not supported.</td>
</tr>
<tr>
<td>callback</td>
<td><em>function(Error, string=)</em></td>
<td>Callback receiving the error, if any, and the resulting salt</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>Promise</em></td>
<td>If <code>callback</code> has been omitted</td>
</tr>
<tr>
<td><strong>@throws</strong></td>
<td><em>Error</em></td>
<td>If <code>callback</code> is present but not a function</td>
</tr>
</tbody>
</table>
<h3>hashSync(s, salt=)</h3>
<p>Synchronously generates a hash for the given string.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td><em>string</em></td>
<td>String to hash</td>
</tr>
<tr>
<td>salt</td>
<td><em>number | string</em></td>
<td>Salt length to generate or salt to use, default to 10</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>string</em></td>
<td>Resulting hash</td>
</tr>
</tbody>
</table>
<h3>hash(s, salt, callback, progressCallback=)</h3>
<p>Asynchronously generates a hash for the given string.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td><em>string</em></td>
<td>String to hash</td>
</tr>
<tr>
<td>salt</td>
<td><em>number | string</em></td>
<td>Salt length to generate or salt to use</td>
</tr>
<tr>
<td>callback</td>
<td><em>function(Error, string=)</em></td>
<td>Callback receiving the error, if any, and the resulting hash</td>
</tr>
<tr>
<td>progressCallback</td>
<td><em>function(number)</em></td>
<td>Callback successively called with the percentage of rounds completed (0.0 - 1.0), maximally once per <code>MAX_EXECUTION_TIME = 100</code> ms.</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>Promise</em></td>
<td>If <code>callback</code> has been omitted</td>
</tr>
<tr>
<td><strong>@throws</strong></td>
<td><em>Error</em></td>
<td>If <code>callback</code> is present but not a function</td>
</tr>
</tbody>
</table>
<h3>compareSync(s, hash)</h3>
<p>Synchronously tests a string against a hash.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td><em>string</em></td>
<td>String to compare</td>
</tr>
<tr>
<td>hash</td>
<td><em>string</em></td>
<td>Hash to test against</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>boolean</em></td>
<td>true if matching, otherwise false</td>
</tr>
<tr>
<td><strong>@throws</strong></td>
<td><em>Error</em></td>
<td>If an argument is illegal</td>
</tr>
</tbody>
</table>
<h3>compare(s, hash, callback, progressCallback=)</h3>
<p>Asynchronously compares the given data against the given hash.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td><em>string</em></td>
<td>Data to compare</td>
</tr>
<tr>
<td>hash</td>
<td><em>string</em></td>
<td>Data to be compared to</td>
</tr>
<tr>
<td>callback</td>
<td><em>function(Error, boolean)</em></td>
<td>Callback receiving the error, if any, otherwise the result</td>
</tr>
<tr>
<td>progressCallback</td>
<td><em>function(number)</em></td>
<td>Callback successively called with the percentage of rounds completed (0.0 - 1.0), maximally once per <code>MAX_EXECUTION_TIME = 100</code> ms.</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>Promise</em></td>
<td>If <code>callback</code> has been omitted</td>
</tr>
<tr>
<td><strong>@throws</strong></td>
<td><em>Error</em></td>
<td>If <code>callback</code> is present but not a function</td>
</tr>
</tbody>
</table>
<h3>getRounds(hash)</h3>
<p>Gets the number of rounds used to encrypt the specified hash.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><em>string</em></td>
<td>Hash to extract the used number of rounds from</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>number</em></td>
<td>Number of rounds used</td>
</tr>
<tr>
<td><strong>@throws</strong></td>
<td><em>Error</em></td>
<td>If <code>hash</code> is not a string</td>
</tr>
</tbody>
</table>
<h3>getSalt(hash)</h3>
<p>Gets the salt portion from a hash. Does not validate the hash.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>hash</td>
<td><em>string</em></td>
<td>Hash to extract the salt from</td>
</tr>
<tr>
<td><strong>@returns</strong></td>
<td><em>string</em></td>
<td>Extracted salt part</td>
</tr>
<tr>
<td><strong>@throws</strong></td>
<td><em>Error</em></td>
<td>If <code>hash</code> is not a string or otherwise invalid</td>
</tr>
</tbody>
</table>
<h2>Command line</h2>
<p><code>Usage: bcrypt &lt;input&gt; [salt]</code></p>
<p>If the input has spaces inside, simply surround it with quotes.</p>
<h2>Downloads</h2>
<ul>
<li><a href="https://github.com/dcodeIO/bcrypt.js/tree/master/dist">Distributions</a></li>
<li><a href="https://github.com/dcodeIO/bcrypt.js/archive/master.zip">ZIP-Archive</a></li>
<li><a href="https://github.com/dcodeIO/bcrypt.js/tarball/master">Tarball</a></li>
</ul>
<h2>Credits</h2>
<p>Based on work started by Shane Girish at <a href="https://github.com/shaneGirish/bcrypt-nodejs">bcrypt-nodejs</a> (MIT-licensed),
which is itself based on <a href="http://code.google.com/p/javascript-bcrypt/">javascript-bcrypt</a> (New BSD-licensed).</p>
<h2>License</h2>
<p>New-BSD / MIT (<a href="https://github.com/dcodeIO/bcrypt.js/blob/master/LICENSE">see</a>)</p>
</div>
  </body>
</html>
