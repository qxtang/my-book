<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - README</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/27/2022, 3:51:00 PM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="content markdown-body"><h1>morgan</h1>
<p><a href="https://npmjs.org/package/morgan"><img src="https://badgen.net/npm/v/morgan" alt="NPM Version"></a>
<a href="https://npmjs.org/package/morgan"><img src="https://badgen.net/npm/dm/morgan" alt="NPM Downloads"></a>
<a href="https://travis-ci.org/expressjs/morgan"><img src="https://badgen.net/travis/expressjs/morgan/master" alt="Build Status"></a>
<a href="https://coveralls.io/r/expressjs/morgan?branch=master"><img src="https://badgen.net/coveralls/c/github/expressjs/morgan/master" alt="Test Coverage"></a></p>
<p>HTTP request logger middleware for node.js</p>
<blockquote>
<p>Named after <a href="http://en.wikipedia.org/wiki/Dexter_Morgan">Dexter</a>, a show you should not watch until completion.</p>
</blockquote>
<h2>API</h2>
<!-- eslint-disable no-unused-vars -->
<pre><code class="language-js">var morgan = require('morgan')
</code></pre>
<h3>morgan(format, options)</h3>
<p>Create a new morgan logger middleware function using the given <code>format</code> and <code>options</code>.
The <code>format</code> argument may be a string of a predefined name (see below for the names),
a string of a format string, or a function that will produce a log entry.</p>
<p>The <code>format</code> function will be called with three arguments <code>tokens</code>, <code>req</code>, and <code>res</code>,
where <code>tokens</code> is an object with all defined tokens, <code>req</code> is the HTTP request and <code>res</code>
is the HTTP response. The function is expected to return a string that will be the log
line, or <code>undefined</code> / <code>null</code> to skip logging.</p>
<h4>Using a predefined format string</h4>
<!-- eslint-disable no-undef -->
<pre><code class="language-js">morgan('tiny')
</code></pre>
<h4>Using format string of predefined tokens</h4>
<!-- eslint-disable no-undef -->
<pre><code class="language-js">morgan(':method :url :status :res[content-length] - :response-time ms')
</code></pre>
<h4>Using a custom format function</h4>
<!-- eslint-disable no-undef -->
<pre><code class="language-js">morgan(function (tokens, req, res) {
  return [
    tokens.method(req, res),
    tokens.url(req, res),
    tokens.status(req, res),
    tokens.res(req, res, 'content-length'), '-',
    tokens['response-time'](req, res), 'ms'
  ].join(' ')
})
</code></pre>
<h4>Options</h4>
<p>Morgan accepts these properties in the options object.</p>
<h5>immediate</h5>
<p>Write log line on request instead of response. This means that a requests will
be logged even if the server crashes, <em>but data from the response (like the
response code, content length, etc.) cannot be logged</em>.</p>
<h5>skip</h5>
<p>Function to determine if logging is skipped, defaults to <code>false</code>. This function
will be called as <code>skip(req, res)</code>.</p>
<!-- eslint-disable no-undef -->
<pre><code class="language-js">// EXAMPLE: only log error responses
morgan('combined', {
  skip: function (req, res) { return res.statusCode &lt; 400 }
})
</code></pre>
<h5>stream</h5>
<p>Output stream for writing log lines, defaults to <code>process.stdout</code>.</p>
<h4>Predefined Formats</h4>
<p>There are various pre-defined formats provided:</p>
<h5>combined</h5>
<p>Standard Apache combined log output.</p>
<pre><code>:remote-addr - :remote-user [:date[clf]] &quot;:method :url HTTP/:http-version&quot; :status :res[content-length] &quot;:referrer&quot; &quot;:user-agent&quot;
</code></pre>
<h5>common</h5>
<p>Standard Apache common log output.</p>
<pre><code>:remote-addr - :remote-user [:date[clf]] &quot;:method :url HTTP/:http-version&quot; :status :res[content-length]
</code></pre>
<h5>dev</h5>
<p>Concise output colored by response status for development use. The <code>:status</code>
token will be colored green for success codes, red for server error codes,
yellow for client error codes, cyan for redirection codes, and uncolored
for information codes.</p>
<pre><code>:method :url :status :response-time ms - :res[content-length]
</code></pre>
<h5>short</h5>
<p>Shorter than default, also including response time.</p>
<pre><code>:remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms
</code></pre>
<h5>tiny</h5>
<p>The minimal output.</p>
<pre><code>:method :url :status :res[content-length] - :response-time ms
</code></pre>
<h4>Tokens</h4>
<h5>Creating new tokens</h5>
<p>To define a token, simply invoke <code>morgan.token()</code> with the name and a callback function.
This callback function is expected to return a string value. The value returned is then
available as &quot;:type&quot; in this case:</p>
<!-- eslint-disable no-undef -->
<pre><code class="language-js">morgan.token('type', function (req, res) { return req.headers['content-type'] })
</code></pre>
<p>Calling <code>morgan.token()</code> using the same name as an existing token will overwrite that
token definition.</p>
<p>The token function is expected to be called with the arguments <code>req</code> and <code>res</code>, representing
the HTTP request and HTTP response. Additionally, the token can accept further arguments of
it's choosing to customize behavior.</p>
<h5>:date[format]</h5>
<p>The current date and time in UTC. The available formats are:</p>
<ul>
<li><code>clf</code> for the common log format (<code>&quot;10/Oct/2000:13:55:36 +0000&quot;</code>)</li>
<li><code>iso</code> for the common ISO 8601 date time format (<code>2000-10-10T13:55:36.000Z</code>)</li>
<li><code>web</code> for the common RFC 1123 date time format (<code>Tue, 10 Oct 2000 13:55:36 GMT</code>)</li>
</ul>
<p>If no format is given, then the default is <code>web</code>.</p>
<h5>:http-version</h5>
<p>The HTTP version of the request.</p>
<h5>:method</h5>
<p>The HTTP method of the request.</p>
<h5>:referrer</h5>
<p>The Referrer header of the request. This will use the standard mis-spelled Referer header if exists, otherwise Referrer.</p>
<h5>:remote-addr</h5>
<p>The remote address of the request. This will use <code>req.ip</code>, otherwise the standard <code>req.connection.remoteAddress</code> value (socket address).</p>
<h5>:remote-user</h5>
<p>The user authenticated as part of Basic auth for the request.</p>
<h5>:req[header]</h5>
<p>The given <code>header</code> of the request. If the header is not present, the
value will be displayed as <code>&quot;-&quot;</code> in the log.</p>
<h5>:res[header]</h5>
<p>The given <code>header</code> of the response. If the header is not present, the
value will be displayed as <code>&quot;-&quot;</code> in the log.</p>
<h5>:response-time[digits]</h5>
<p>The time between the request coming into <code>morgan</code> and when the response
headers are written, in milliseconds.</p>
<p>The <code>digits</code> argument is a number that specifies the number of digits to
include on the number, defaulting to <code>3</code>, which provides microsecond precision.</p>
<h5>:status</h5>
<p>The status code of the response.</p>
<p>If the request/response cycle completes before a response was sent to the
client (for example, the TCP socket closed prematurely by a client aborting
the request), then the status will be empty (displayed as <code>&quot;-&quot;</code> in the log).</p>
<h5>:total-time[digits]</h5>
<p>The time between the request coming into <code>morgan</code> and when the response
has finished being written out to the connection, in milliseconds.</p>
<p>The <code>digits</code> argument is a number that specifies the number of digits to
include on the number, defaulting to <code>3</code>, which provides microsecond precision.</p>
<h5>:url</h5>
<p>The URL of the request. This will use <code>req.originalUrl</code> if exists, otherwise <code>req.url</code>.</p>
<h5>:user-agent</h5>
<p>The contents of the User-Agent header of the request.</p>
<h3>morgan.compile(format)</h3>
<p>Compile a format string into a <code>format</code> function for use by <code>morgan</code>. A format string
is a string that represents a single log line and can utilize token syntax.
Tokens are references by <code>:token-name</code>. If tokens accept arguments, they can
be passed using <code>[]</code>, for example: <code>:token-name[pretty]</code> would pass the string
<code>'pretty'</code> as an argument to the token <code>token-name</code>.</p>
<p>The function returned from <code>morgan.compile</code> takes three arguments <code>tokens</code>, <code>req</code>, and
<code>res</code>, where <code>tokens</code> is object with all defined tokens, <code>req</code> is the HTTP request and
<code>res</code> is the HTTP response. The function will return a string that will be the log line,
or <code>undefined</code> / <code>null</code> to skip logging.</p>
<p>Normally formats are defined using <code>morgan.format(name, format)</code>, but for certain
advanced uses, this compile function is directly available.</p>
<h2>Examples</h2>
<h3>express/connect</h3>
<p>Simple app that will log all request in the Apache combined format to STDOUT</p>
<pre><code class="language-js">var express = require('express')
var morgan = require('morgan')

var app = express()

app.use(morgan('combined'))

app.get('/', function (req, res) {
  res.send('hello, world!')
})
</code></pre>
<h3>vanilla http server</h3>
<p>Simple app that will log all request in the Apache combined format to STDOUT</p>
<pre><code class="language-js">var finalhandler = require('finalhandler')
var http = require('http')
var morgan = require('morgan')

// create &quot;middleware&quot;
var logger = morgan('combined')

http.createServer(function (req, res) {
  var done = finalhandler(req, res)
  logger(req, res, function (err) {
    if (err) return done(err)

    // respond to request
    res.setHeader('content-type', 'text/plain')
    res.end('hello, world!')
  })
})
</code></pre>
<h3>write logs to a file</h3>
<h4>single file</h4>
<p>Simple app that will log all requests in the Apache combined format to the file
<code>access.log</code>.</p>
<pre><code class="language-js">var express = require('express')
var fs = require('fs')
var morgan = require('morgan')
var path = require('path')

var app = express()

// create a write stream (in append mode)
var accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })

// setup the logger
app.use(morgan('combined', { stream: accessLogStream }))

app.get('/', function (req, res) {
  res.send('hello, world!')
})
</code></pre>
<h4>log file rotation</h4>
<p>Simple app that will log all requests in the Apache combined format to one log
file per day in the <code>log/</code> directory using the
<a href="https://www.npmjs.com/package/rotating-file-stream">rotating-file-stream module</a>.</p>
<pre><code class="language-js">var express = require('express')
var morgan = require('morgan')
var path = require('path')
var rfs = require('rotating-file-stream') // version 2.x

var app = express()

// create a rotating write stream
var accessLogStream = rfs.createStream('access.log', {
  interval: '1d', // rotate daily
  path: path.join(__dirname, 'log')
})

// setup the logger
app.use(morgan('combined', { stream: accessLogStream }))

app.get('/', function (req, res) {
  res.send('hello, world!')
})
</code></pre>
<h3>split / dual logging</h3>
<p>The <code>morgan</code> middleware can be used as many times as needed, enabling
combinations like:</p>
<ul>
<li>Log entry on request and one on response</li>
<li>Log all requests to file, but errors to console</li>
<li>... and more!</li>
</ul>
<p>Sample app that will log all requests to a file using Apache format, but
error responses are logged to the console:</p>
<pre><code class="language-js">var express = require('express')
var fs = require('fs')
var morgan = require('morgan')
var path = require('path')

var app = express()

// log only 4xx and 5xx responses to console
app.use(morgan('dev', {
  skip: function (req, res) { return res.statusCode &lt; 400 }
}))

// log all requests to access.log
app.use(morgan('common', {
  stream: fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })
}))

app.get('/', function (req, res) {
  res.send('hello, world!')
})
</code></pre>
<h3>use custom token formats</h3>
<p>Sample app that will use custom token formats. This adds an ID to all requests and displays it using the <code>:id</code> token.</p>
<pre><code class="language-js">var express = require('express')
var morgan = require('morgan')
var uuid = require('node-uuid')

morgan.token('id', function getId (req) {
  return req.id
})

var app = express()

app.use(assignId)
app.use(morgan(':id :method :url :response-time'))

app.get('/', function (req, res) {
  res.send('hello, world!')
})

function assignId (req, res, next) {
  req.id = uuid.v4()
  next()
}
</code></pre>
<h2>License</h2>
<p><a href="LICENSE">MIT</a></p>
</div>
  </body>
</html>
