<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - 其他</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/27/2022, 3:51:01 PM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="content markdown-body"><h1>Restful</h1>
<ul>
<li>用 URL 定位资源，用 HTTP 描述操作</li>
<li>应该将 API 的版本号放入 URL</li>
<li>每个网址代表一种资源，所以网址中不能有动词，只能有名词，往往与数据库的表格名对应</li>
<li>对于资源的具体操作类型 CURD，由 HTTP 动词表示，例如查询用 GET 方式请求</li>
<li>使用 HTTP 状态码表达处理结果，例如成功为 200，无权限 403，而不能全都是 200</li>
<li>返回尽量使用 JSON 格式，避免使用 XML</li>
</ul>
<h1>JWT</h1>
<h2>组成</h2>
<ul>
<li>base64UrlEncode(header) + ‘.’ + base64UrlEncode(payload) + ‘.’ + signature</li>
<li>signature：签证信息，由 HMAC_SHA256((base64UrlEncode(header) + ‘.’ + base64UrlEncode(payload)), ‘密钥’) 生成</li>
<li>payload 即载体，存放过期时间用户信息等等，不应该在载体存放敏感信息，因为该部分是客户端可解密的部分</li>
</ul>
<h2>防篡改</h2>
<ul>
<li>通过比对 signature，用客户端传过来的这个 token，把头部和载体拿出来再算一遍 signature，和 token 里面带的那个 signature 比对是否一致</li>
</ul>
<h2>缺点</h2>
<p>缺点就是一旦签发不可撤销</p>
<h1>单元测试</h1>
<ul>
<li>定义：是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</li>
<li>前端开发我只对较为复杂的功能做单元测试，一些简单功能的没必要做，会增加比较多的工作量</li>
</ul>
<h2>前端常用单元测试框架</h2>
<p>mocha、Jest 提供了单元测试所需的各种 API，你可以使用它们来对你的代码进行单元测试</p>
<h1>对称加密 和 非对称加密</h1>
<h2>对称加密</h2>
<ul>
<li>加密与解密用的是同样的密钥</li>
<li>效率高</li>
<li>密钥越大，加密越强，但加密与解密的过程越慢</li>
<li>通常使用相对较小的密钥，一般小于 256 bit</li>
<li>缺点是不安全，在发送密钥的过程中，密钥有很大的风险会被黑客们拦截</li>
<li>通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人</li>
</ul>
<h2>非对称加密</h2>
<ul>
<li>使用了一对密钥，公钥（public key）和私钥（private key）</li>
<li>私钥只能由一方安全保管，不能外泄，</li>
<li>公钥则可以发给任何请求它的人</li>
<li>非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥</li>
<li>使用公钥对消息加密，只有私钥的持有人才能对消息解密</li>
<li>不需要将私钥通过网络发送出去，因此安全性大大提高</li>
<li>常用的非对称加密算法是 RSA 算法</li>
<li>相对对称加密较慢</li>
<li>解决：将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通</li>
</ul>
<h1>进程和线程</h1>
<ul>
<li>进程 是操作系统进行资源分配和调度的独立单位，是应用程序运行的载体</li>
<li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位</li>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</li>
<li>同一个进程下的所有线程共享该进程的所有资源</li>
</ul>
<h1>ESLint 常用哪个规范？</h1>
<ul>
<li>airbnb</li>
</ul>
<h1>React 与 Vue 异同</h1>
<p>React 是手动挡，Vue 是自动挡</p>
<ul>
<li>异
<ul>
<li>react 是函数式思想，all in js ，jsx 语法，js 操控 css</li>
<li>react 是单项数据流</li>
<li>react 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 shouldComponentUpdate 这个生命周期方法来进行控制，如果为 true 继续渲染、false 不渲染，但 Vue 将此视为默认的优化</li>
<li>react 对 ts 更友好一些</li>
<li>vue 是响应式思想，也就是基于数据可变的。把 html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中</li>
<li>vue 是双向绑定</li>
<li>Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树</li>
</ul>
</li>
<li>同
<ul>
<li>使用 Virtual DOM，都有 jsx，性能好</li>
<li>都是数据驱动视图</li>
</ul>
</li>
</ul>
<h1>后端一次给 10 万条数据，如何处理展示</h1>
<ul>
<li>直接遍历渲染（耗时最高，不推荐）</li>
<li>setTimeout 分页渲染：把 10w 按照每页数量 limit 分成总共 Math.ceil(total / limit)页，然后利用 setTimeout，每次渲染 1 页数据</li>
<li>使用 requestAnimationFrame 代替上一条的 setTimeout</li>
<li>文档碎片(createDocumentFragment) + requestAnimationFrame</li>
<li>懒加载：在列表尾部放一个空节点 blank，等到 blank 出现在视图中（使用 getBoundingClientRect），就说明到底了，这时候再加载第二页，以此类推</li>
<li>虚拟列表</li>
</ul>
<h1>跨浏览器开发最佳实践</h1>
<ul>
<li>封装</li>
<li>垫片 polyfill</li>
<li>不要污染全局</li>
</ul>
<h1>调试排错技巧</h1>
<p>参考：</p>
<ul>
<li><a href="https://developer.chrome.com/docs/devtools/">https://developer.chrome.com/docs/devtools/</a></li>
<li><a href="https://www.zhihu.com/question/43687153/answer/149944688">前端界有哪些越早知道越好的小技巧、小知识？</a></li>
<li><a href="https://blog.csdn.net/minkeyto/article/details/81489041">IDEA debug 断点调试技巧</a></li>
</ul>
<h2>浏览器</h2>
<ul>
<li>使用 debugger 关键字</li>
<li>source 面板打断点</li>
<li>chrome 移动页面调试工具：chrome://inspect/#devices</li>
<li>chrome dev tools 的请求重放功能</li>
<li>webstorm 的 debug JavaScript in chrome 功能</li>
</ul>
<h2>react</h2>
<ul>
<li>redux devtools</li>
<li>react developer tools</li>
<li><a href="https://isamatov.com/react-chrome-dev-tools-tips/">Top five useful Chrome Dev Tools tips for React</a></li>
</ul>
<h2>Nodejs</h2>
<ul>
<li>使用 VScode 或 webstorm 的 debug 功能完全满足</li>
</ul>
<h1>使用 pscp 实现 Windows 和 Linux 服务器间远程传递文件</h1>
<ul>
<li>PSCP (PuTTY Secure Copy client)是 PuTTY 提供的文件传输工具，通过 SSH 连接，在两台机器之间安全的传输文件，可以用于任何 SSH（包括 SSH v1、SSH v2）服务器。</li>
</ul>
</div>
  </body>
</html>
