# arguments

- 是一个类数组对象，存储传入函数的全部参数。（类数组对象：属性是 0 开始的下标，并且有 length 属性，但没有数组独有的方法）
- callee 属性：当前函数的引用
- 妙用：递归、参数累加

## 为什么 ES6 不推荐使用 arguments.callee()

- 访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响浏览器的性能，还会影响闭包。
- 当一个函数必须调用自身的时候，假如它是函数表达式则给它命名，或者使用函数声明，避免使用 callee

# delete 机制

- 使用 delete 操作符并不会直接释放内存，与 V8 引擎有关
- 最有效的方式，应该是将不需要的属性设置为 undefined
- 在实际业务中可以考虑使用 Map 来代替 object，map 包装对象有 delete 方法，比以上方式都快

# 0.1 + 0.2 为什么不等于 0.3

- 二进制模拟十进制进行计算时的精度问题
- 进制转换：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失
- 对阶运算：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0 舍 1 入），尾数位移时可能会发生数丢失的情况，影响精度

## 解决

- 使用 Number.EPSILON 误差范围

Number.EPSILON 表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值

```javascript
function isEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true
```

# es6 新特性

- 箭头函数
- Promise
- 拓展运算符和解构赋值
- 对象和数组解构
- let const
- 模板字符串
- 函数的参数默认值
- class
- for…of 和 for…in
- 模块
- 尾调用优化 TCO

# var let const

- const 用于声明常量，const 声明的一般类型的变量，不能修改
- const 声明的对象，属性可以被修改
- 用 var 重复声明不会报错，但 let 和 const 会
- var 会使变量提升，变量可以在 var 声明之前使用。let 和 const 不会使变量提升，提前使用会报错。

# 柯里化

- 把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

## 意义

- 让人们将关注的重点聚焦到函数本身，而不因冗余的数据参数分散注意力，单一参数的纯函数是最简单的，目的单纯、职责单一、灵活且通用
- 减少耦合增强其可维护性

## 缺点

- 过度使用会占用较大的堆栈空间
- 经过柯里化之后，函数的通用性有所降低，但是适用性有所提高

```javascript
// 手写柯里化

const add = function (a, b, c) {
  return a + b + c;
};

function curry(fn) {
  return function curryFun(...args) {
    if (args.length < fn.length) {
      return function () {
        return curryFun([...args, ...arguments]);
      };
    }
    return fn(...args);
  };
}

const curried = curry(add);

const a = curried(1)(9)(3);
const b = curried(2, 8)(6);

console.log({ a, b });
```

# 闭包

- 函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包
- 闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量
- 能够访问已经被销毁的执行期上下文的活动对象的函数、有权访问另一个函数作用域中的变量的函数
- 函数做为参数传递或在尾部 return，并且子函数在外调用，形成闭包，子函数所在的父函数的作用域不会被释放，子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象
- 应用：设计私有的方法和变量。
- 优点：可以避免全局变量的污染
- 缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露。

## 如何优化闭包

- 通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）

```jsx
function outerFun(outerArg) {
  return function () {
    console.log('这里是内部匿名函数');
    console.log('可以访问包含函数的变量', outerArg);
  };
}
var create = outerFun('hi');
// 创建一个函数，是 outerFun 中返回的匿名函数create();
// 调用函数，是调用匿名函数create = null;
// 释放对匿名函数的引用
```

- 如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题。
- 利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁。

# 垃圾回收

- 现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数

## 标记清除（主流）

- 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记
- 从根部出发将能触及到的对象的标记清除
- 那些还存在标记的变量被视为准备删除的变量
- 销毁那些带标记的值

## 引用计数

- 如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收。
- 跟踪记录每个值被引用的次数
- 当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1
- 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1
- 当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来
- 缺点：循环引用会造成对象无法被回收

## 如何避免垃圾回收

- 对象尽量复用
- 数组优化： 将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

## 引起内存泄漏的操作

- 全局变量
- 闭包
- dom 清除，事件绑定未清除
- 未清除的计时器
- setTimeout 的第一个参数使用字符串而非函数
- 引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环
- console.log 打印了太大的变量

# js 数据类型

- 基本类型：number、string、boolean、undefined、null、Symbol、BigInt（BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数）
- 栈内存：是一种特殊的线性表，它具有后进先出的特性，存放基本类型
- 堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象)
- 基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据
- 引用数据类型存储在堆内存中，因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能
- 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体
- 引用类型：Object、Array、Function、内置对象（Date、Math 等等）

## 数据类型的判断

- typeof：能判断所有值类型，函数。不可对 null、对象、数组进行精确判断，因为都返回 object
- instanceof：能判断对象类型，不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型
- 使用 Object.prototype.toString.call()，所有原始数据类型都能判断，还有 Error 对象，Date 对象等

## 如何判断变量是否为数组

- `Array.isArray(arr)`
- `arr.__proto__ === Array.prototype`
- `arr instanceof Array`
- `Object.prototype.toString.call(arr)`

# null 和 undefined 区别

null 表示没有对象，即该处不应该有值。
undefined 表示缺少值，即此处应该有值，但没有定义。
typeof null 为 object
typeof undefined 为 undefined

null 和 undefined 转换成 number 数据类型时，
null 转成 0 undefined 转成 NaN

# 为什么会出现精度丢失

- 这跟浮点数在计算机内部（用二进制存储）的表示方法有关
- JS 采用 IEEE 754 标准的 64 位双精度浮点数表示法，这个标准是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，也被很多语言如 java、python 采用。

这个标准，会让大部分的十进制小数都不能用二进制浮点数来精确表示（比如转成二进制就会变成无限小数）。所以一般情况下，你输入的十进制小数仅由实际存储在计算机中的近似的二进制浮点数表示。

然而，许多语言在处理的时候，在一定误差范围内（通常极小）会将结果修正为正确的目标数字，而不是像 JS 一样将存在误差的真实结果转换成最接近的小数输出

# 深拷贝、浅拷贝

- 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign 或 展开运算符
- 深拷贝：
  - JavaScript 包含基本类型（如字符串、数字、布尔）和引用类型（如数组、对象）
  - 基本数据类型按值访问、引用类型的值按照引用访问
  - 直接复制引用类型的值，实际上是一个内存地址的指针，修改新的变量，原变量也会被修改
- 手写深拷贝：

```jsx
function deepCopy(obj) {
  // 1、判断是否是简单数据类型，
  if (typeof obj == 'object') {
    // 2、复杂数据类型
    var result = obj.constructor == Array ? [] : {};
    for (let i in obj) {
      result[i] = typeof obj[i] == 'object' ? deepCopy(obj[i]) : obj[i];
    }
  } else {
    // 简单数据类型 直接赋值
    var result = obj;
  }
  return result;
}
```

# 描述 Promise

- 用来解决回调地狱
- 实例化一个 Promise 需要传入一个函数，业务代码在这个函数中执行，这个函数往往接收两个参数 resolve 和 reject
- 在函数中业务代码执行成功了，调用 resolve 函数，可以把 Promise 的状态变为已成功，通过参数把成功的结果传递出去，能在这个 Promise 对象的 then 方法中获取，then 方法可以链式调用多次，then 方法接受一个函数作为参数，这个函数的参数就是 resolve 传递出来的结果
- 在函数中业务代码执行失败了，调用 reject 函数，可以把 Promise 的状态变为已失败，通过参数把失败的结果传递出去，能在这个 Promise 对象的 catch 方法中获取，catch 方法和 then 方法用法一致，也是接受一个函数作为参数
- 无论结果如何都会走 finally 方法
- Promise.all 接受一个数组作为参数，都是 Promise 实例，调用 Promise.all 的时候，这些实例会一起开始执行，返回一个结果数组，只有全部实例的状态是已完成，结果的状态才会是已完成，只要有一个失败，结果就是失败
- Promise.race 接受一个数组作为参数，都是 Promise 实例，返回一个结果数组，调用 Promise.race 的时候，传进去的实例是竞赛关系，哪个结果获得的快，就返回那个结果

# 手写 Promise

```jsx
// 在这里用Symbol定义三种状态，防止外部改变状态
const Pending = Symbol('Pending');
// 进行中
const Fulfilled = Symbol('Fulfilled');
// 已成功
const Rejected = Symbol('Rejected');
// 已失败
const handleValue = (promise, x, resolve, reject) => {
  // 循环引用，自己等待自己完成，会出错，用reject传递出错误原因
  if (promise === x) {
    return reject(new TypeError('检测到Promise的链式循环引用'));
  }
  // 确保递归解析中只传递出去一次值
  let once = false;
  if ((x !== null && typeof x === 'object') || typeof x === 'function') {
    try {
      // 防止重复去读取x.then
      let then = x.then;
      // 判断x是不是Promise
      if (typeof then === 'function') {
        //调用then实例方法处理Promise执行结果
        then.call(
          x,
          (y) => {
            if (once) return;
            once = true;
            // 防止Promise中Promise执行成功后又传递一个Promise过来，
            // 要做递归解析。
            handleValue(promise, y, resolve, reject);
          },
          (r) => {
            if (once) return;
            once = true;
            reject(r);
          }
        );
      } else {
        // 如果x是个普通对象，直接调用resolve(x)
        resolve(x);
      }
    } catch (err) {
      if (once) return;
      once = true;
      reject(err);
    }
  } else {
    // 如果x是个原始值，直接调用resolve(x)
    resolve(x);
  }
};
class Promise {
  constructor(executor) {
    this.status = Pending;
    //存储 Promise 的状态
    this.value = undefined;
    //存储executor函数中业务代码执行成功的结果
    this.reason = undefined;
    //存储executor函数中业务代码执行失败的原因
    this.onFulfilled = [];
    //executor函数中业务代码执行成功回调函数的集合
    this.onRejected = [];
    //executor函数中业务代码执行失败回调函数的集合
    const resolve = (value) => {
      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。
      if (this.status === Pending) {
        this.status = Fulfilled;
        this.value = value;
        // 依次调用成功回调函数
        this.onFulfilled.forEach((fn) => fn());
      }
    };
    const reject = (value) => {
      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。
      if (this.status === Pending) {
        this.status = Rejected;
        this.reason = value;
        // 依次调用失败回调函数
        this.onRejected.forEach((fn) => fn());
      }
    };
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (v) => v;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : (err) => {
            throw err;
          };
    let promise = new Promise((resolve, reject) => {
      if (this.status === Fulfilled) {
        setTimeout(() => {
          try {
            let x = onFulfilled(this.value);
            handleValue(promise, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }
      if (this.status === Rejected) {
        if (onRejected && typeof onRejected === 'function') {
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              handleValue(promise, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        }
      }
      if (this.status === Pending) {
        this.onFulfilled.push(() => {
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              handleValue(promise, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
        if (onRejected && typeof onRejected === 'function') {
          this.onRejected.push(() => {
            setTimeout(() => {
              try {
                let x = onRejected(this.reason);
                handleValue(promise, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            }, 0);
          });
        }
      }
    });
    return promise;
  }
  static resolve(param) {
    if (param instanceof Promise) {
      return param;
    }
    return new Promise((resolve, reject) => {
      if (param && Object.prototype.toString.call(param) === '[object Object]' && typeof param.then === 'function') {
        setTimeout(() => {
          param.then(resolve, reject);
        }, 0);
      } else {
        resolve(param);
      }
    });
  }
  static reject(param) {
    return new Promise((resolve, reject) => {
      reject(param);
    });
  }
  static all(promises) {
    //将参数promises转为一个真正的数组
    promises = Array.from(promises);
    return new Promise((resolve, reject) => {
      const length = promises.length;
      let value = [];
      if (length) {
        value = Array.apply(null, { length: length });
        for (let i = 0; i < length; i++) {
          Promise.resolve(promises[i]).then(
            (res) => {
              value[i] = res;
              if (value.length == length) {
                resolve(value);
              }
            },
            (err) => {
              reject(err);
              return;
            }
          );
        }
      } else {
        resolve(value);
      }
    });
  }
  static race(promises) {
    //将参数promises转为一个真正的数组
    promises = Array.from(promises);
    return new Promise((resolve, reject) => {
      const length = promises.length;
      if (length) {
        for (let i = 0; i < length; i++) {
          Promise.resolve(promises[i]).then(
            (res) => {
              resolve(res);
              return;
            },
            (err) => {
              reject(err);
              return;
            }
          );
        }
      } else {
        return;
      }
    });
  }
}
```

# 描述 async/await

- async 用来声明函数，告诉解释器这是一个异步函数，只有 async 声明的函数里面才能用 await
- await 用来等待一个 promise 执行结束，可以返回 promise 对象 resolve 出来的结果
- 如果 await 等待的这个 Promise 对象出错或者结果为 reject，可以通过 try catch 捕获到错误

# Array 的方法

- isArray()
- indexOf、lastIndexOf
- toString() 返回字符串，逗号分隔
- push(o:any) 在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，会改变原数组
- pop() 删除数组的最后一个元素，并返回该元素，会改变原数组
- shift() 删除数组的第一个元素，并返回该元素，会改变原数组
- unshift(o:any) 在数组的第一个位置添加元素，并返回添加新元素后的数组长度，会改变原数组
- join(o:str) 以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔
- concat(o:array) 用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变
- reverse 用于颠倒排列数组元素，返回改变后的数组，会改变原数组
- slice(start, end) 用于提取目标数组的一部分，返回一个新数组，原数组不变
- splice(start, count, addElement1, addElement2, …) 用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。会改变原数组
- sort
- map、forEach、filter、some、every、reduce、reduceRight

# String 的方法

- split(o:str) 按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组
- toLowerCase、toUpperCase
- trim 用于去除字符串两端的空格，返回一个新字符串，不改变原字符串
- indexOf、lastIndexOf
- substr 用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同
- substring(start, end) 用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）
- slice(start, end) 用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）
- concat 用于连接两个字符串，返回一个新字符串，不改变原字符串
- charAt(num) 返回指定位置的字符，参数是从 0 开始编号的位置，这个方法完全可以用数组下标替代
- fromCharCode 方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串
- btoa 任意值转为 Base64 编码
- atob Base64 编码转为原来的值

# 数组的遍历迭代方法

- for in
  以任意顺序遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行。

> 如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性。

- for of
  ES6 新增，用来替代 for in 和 forEach，可以遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构。
- forEach
  遍历数组中的每一项，没有返回值，对原数组没有影响，注意：在 forEach 中用 return 不会返回，break 不会跳出，函数会继续执行。
- map
  返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
- filter
  返回通过过滤的元素，不改变原来的数组。
- some
  用于检测数组中的某个元素是否满足指定条件,返回 boolean 值，不改变原数组。
- every
  用于检测数组中的所有元素是否都符合指定条件，返回 boolean 值，不改变原数组。
- reduce
  接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
- reduceRight
  和 reduce() 功能是一样的，它是从数组的末尾处向前开始计算。
- find 返回通过测试（函数内判断）的数组的第一个元素的值。

forEach、for in、for of 三者区别：

- forEach 更多的用来遍历数组
- for in 一般常用来遍历对象或 json
- for of 数组对象都可以遍历，遍历对象需要通过和 Object.keys()
- for in 循环出的是 key，for of 循环出的是 value

# apply、call、bind

- 都是用来改变函数 this 的指向

区别：

- apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组
- bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用，bind 与 apply/call 一样都能改变函数 this 指向，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数，你需要再次调用此函数才能达到最终执行

## 手写

```javascript
// call
Function.prototype.myCall = function (context, ...args) {
  if (typeof this !== 'function') {
    throw new Error('Type error');
  }

  // 判断 context 是否传入，如果没有传就设置为 window
  context = context || window;

  // 使用 Symbol 来保证属性唯一
  // 保证不会重写用户自己原来定义在 context 中的同名属性
  const fnSymbol = Symbol();

  // 将被调用的方法设置为 context 的属性
  // this 即为我们要调用的方法
  context[fnSymbol] = this;

  // 将执行结果返回
  try {
    return context[fnSymbol](...args);
  } finally {
    // 最后删除手动增加的属性方法
    delete context[fnSymbol];
  }
};

var foo = {
  value: 1,
};

function bar() {
  console.log(this.value);
}

bar.call(foo); // 1
bar.myCall(foo); // 1

// apply
// 与 call 相比仅获取参数方式不同

// bind
Function.prototype.myBind = function (context, ...args) {
  if (typeof this !== 'function') {
    throw new Error('Type error');
  }

  const fn = this;

  return function Fn() {
    return fn.apply(
      this instanceof Fn ? this : context,
      // 当前的这个 arguments 是指 Fn 的参数
      args.concat(...arguments)
    );
  };
};
```

# 尾调用和尾递归

- 指某个函数的最后一步是调用另一个函数
- 递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生栈溢出错误
- 但对于尾递归来说，由于只存在一个调用记录，所以不会发生栈溢出

```javascript
function factorial(num) {
  if (num === 1) return 1;
  return num * factorial(num - 1);
}

console.log(factorial(5));
console.log(factorial(10));
```

# 词法作用域和动态作用域

- JavaScript 采用词法作用域，也就是静态作用域
- 函数的作用域在函数定义的时候就决定了
- 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定

```javascript
var value = 1;

function foo() {
  console.log(value);
}

function bar() {
  var value = 2;
  foo();
}

bar();

// 1
```

# 参数传递

- 参数如果是基本类型是按值传递，如果是引用类型按共享传递
- 但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题

## 按值传递

- 把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样

## 共享传递

- 在传递对象的时候，传递对象的引用的副本
- 假设 arg 是一个对象参数，修改 arg.value，可以通过引用找到原值，但是直接修改 arg，并不会修改原值
