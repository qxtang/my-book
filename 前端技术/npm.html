<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - npm</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/31/2022, 10:14:08 AM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="menu" id="menu"></div>
    <div class="mobile_menu" id="mobile_menu">
      <img src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/bars.svg" alt="" />
    </div>
    <div class="content markdown-body"><h2>团队管理最佳实践</h2>
<ul>
<li>开发环境 node 和 npm 版本需要一致，因为不同版本 npm 行为不一样</li>
</ul>
<h2>npm 的使用</h2>
<ul>
<li>
<p>可以通过环境变量读取 package.json 中的属性：process.env.npm_package_name</p>
</li>
<li>
<p>获取当前正在运行的 npm script 脚本名称：process.env.npm_lifecycle_event</p>
</li>
<li>
<p>可通过添加 pre- 和 post- 前缀声明钩子脚本</p>
</li>
<li>
<p>使用 link 调试本地包</p>
</li>
<li>
<p>npx 工具：直接运行 node_modules/.bin 目录下的可执行文件</p>
</li>
<li>
<p>npm run 新建的 Shell 环境，会将当前目录的 node_modules/.bin 加入 PATH 环境变量，执行结束后，再将 PATH 环境变量恢复，这意味着，当前目录的 node_modules/.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径或者 npx</p>
</li>
<li>
<p>script 中可通过 <code>$npm_config_tag</code> 获取 shell 中的配置值；如果 env 环境变量中存在以 <code>npm_config_*</code> 为前缀的环境变量，则也会被识别为 npm 的配置属性；以及各个级别的 .npmrc 配置文件</p>
<pre><code class="language-bash">npm run serve --params  // 参数params将转化成process.env.npm_config_params = true
npm run serve --params=123 // 参数params将转化成process.env.npm_config_params = 123
</code></pre>
</li>
<li>
<p>npm version patch</p>
<ul>
<li>升级小版本，还会默认执行 git add-&gt;git commit-&gt;git tag 操作，也可以通过配置禁止这一默认行为</li>
</ul>
</li>
<li>
<p>查看所有可用命令：<code>npm run</code></p>
</li>
<li>
<p>npm ci</p>
<ul>
<li>npm ci 只根据 package-lock.json 来安装包，而 npm install 在安装的过程中会结合 package.json 和 package-lock.json 来计算依赖包版本的差异性问题。所以相比较 npm install，npm ci 既能提升包的安装速度，又能避免在生产化境中出现包版本不一致的问题</li>
<li>如果项目中已经存在 node_modules，npm ci 将会先删除它，然后再安装</li>
<li>如果检测到 package.json 和 package-lock.json 中的依赖项不匹配的话，npm ci 将退出并报错，而不是更新两个文件中的版本号</li>
<li>要求项目中必须具有 package-lock.json 或 npm-shrinkwrap.json，否则执行 npm ci 将会报错</li>
<li>npm ci 只能一次安装整个项目的依赖包，而不能为项目安装单个依赖包</li>
</ul>
</li>
</ul>
<h2>npm 检查配置的优先级</h2>
<ul>
<li>项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件 &gt; 全局级的 .npmrc &gt; npm 内置的 .npmrc 文件</li>
</ul>
<h2>package-lock.json、yarn.lock 的作用</h2>
<ul>
<li>锁定安装时的包的版本号，并且需要上传到 git，以保证其他人在 npm install 时大家的依赖能保证一致</li>
<li>package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次 npm install 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。</li>
</ul>
<h2>npm install 流程</h2>
<ul>
<li>检查项目中是否有 package-lock.json 文件</li>
<li>如果有， 检查 package-lock.json 和 package.json 声明的依赖是否一致：
<ul>
<li>一致， 直接使用 package-lock.json 中的信息，从网络或者缓存中加载依赖</li>
<li>不一致， 根据上述流程中的不同版本进行处理</li>
</ul>
</li>
<li>如果没有， 那么会根据 package.json 递归构建依赖树，然后就会根据构建好的依赖去下载完整的依赖资源，在下载的时候，会检查有没有相关的资源缓存:
<ul>
<li>存在， 直接解压到 node_modules 文件中</li>
<li>不存在， 从 npm 远端仓库下载包，校验包的完整性，同时添加到缓存中，解压到 node_modules 中</li>
</ul>
</li>
<li>最后， 生成 package-lock.json 文件</li>
<li>在我们实际的项目开发中，使用 npm 作为团队的最佳实践: 同一个项目团队，应该保持 npm 版本的一致性。</li>
</ul>
<blockquote>
<p>如果希望一个模块不管是否安装过，npm 都要强制重新安装，可以使用 -f 或–force 参数</p>
</blockquote>
<h2>npm 的缺点</h2>
<ul>
<li>包之间相互依赖，导致嵌套地狱，会形成一棵巨大的依赖树</li>
<li>依赖层级过深，有问题不利于排查和调试</li>
<li>安装结果占据大量空间资源，安装时间长</li>
</ul>
<h2>yarn 解决的问题</h2>
<ul>
<li>采用模块扁平化的安装模式: 将不同版本的依赖包，按照一定的策略，归结为单个版本；以避免创建多个版本造成工程的冗余（目前版本的 npm 也有相同的优化）</li>
<li>网络性能更好: yarn 采用了请求排队的理念，类似于并发池连接，能够更好的利用网络资源；同时也引入了一种安装失败的重试机制</li>
<li>采用缓存机制，实现了离线模式 （目前的 npm 也有类似的实现）</li>
</ul>
<h2>依赖包版本号</h2>
<ul>
<li>采用了 semver 规范作为依赖版本管理方案</li>
<li>一般格式：主版本号.次版本号.修订号（x.y.z）</li>
</ul>
<h2>package.json</h2>
<ul>
<li>bin：表示的是一个可执行文件到指定文件源的映射<pre><code class="language-json">&quot;bin&quot;: {
  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;
}
</code></pre>
</li>
<li>file：需要上传 npm 的文件，一般设置只上传编译产物，加快下载包的速度</li>
<li>main：指定加载的入口文件</li>
<li>browser：定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件</li>
<li>module：定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用。如果 npm 包导出的是 ESM 规范的包，使用 module 来定义入口文件</li>
<li>man：指定帮助文档</li>
<li>typings：指定 TypeScript 的入口文件</li>
</ul>
<h3>dependencies</h3>
<ul>
<li>dependencies
<ul>
<li>最终上线或者发布 npm 包时所需要，例如 vue 框架、UI 组件库</li>
<li>发布 npm 包的时候，包中的 dependencies 依赖项在安装该包的时候会被一起下载，devDependencies 依赖项则不会</li>
</ul>
</li>
<li>devDependencies
<ul>
<li>开发和测试时需要，例如打包工具、css 预处理器、测试框架等</li>
</ul>
</li>
<li>peerDependencies
<ul>
<li>如果你安装我，那么你最好也要按照我的要求安装 A、B 和 C</li>
<li>可以用来防止多次引入相同的库</li>
</ul>
</li>
<li>optionalDependencies
<ul>
<li>这种依赖中的依赖项即使安装失败了，也不影响整个安装的过程</li>
<li>如果一个依赖同时出现在 dependencies 和 optionalDependencies 中，那么 optionalDependencies 会获得更高的优先级</li>
<li>在实际项目中，如果某个包已经失效，我们通常会寻找它的替代者，或者换一个实现方案。不确定的依赖会增加代码判断和测试难度，所以这个依赖项还是尽量不要使用</li>
</ul>
</li>
</ul>
<h2>域级包管理</h2>
<ul>
<li>以@开头的包名</li>
<li>由于用@声明了该包，npm 会默认将此包认定为私有包，而在 npm 上托管私有包是需要收费的，所以为了避免发布私有包，可以在发布时添加--accss=public 参数告知 npm 这不是一个私有包</li>
<li>域级包不一定就是私有包，但是私有包一定是一个域级包</li>
<li>在安装域级包时需要按照域级包全名来安装：<code>npm install @scopeName/package</code></li>
</ul>
<h2>发布一个支持 tree shaking 机制的包</h2>
<ul>
<li>
<p>tree shaking 是依赖 ES Module 的模块特性来工作的，那是因为 ES Module 模块的依赖关系是在编译时确定的（和运行时无关），并且之后不能再改变，所以基于此特性可以进行可靠的静态分析</p>
</li>
<li>
<p>设置 module 字段：该字段指向一个既符合 ES Module 模块规范但是又使用 ES5 语法的源文件。这么做的目的是为了启动 tree shaking 的同时，又避免代码兼容性的问题</p>
<pre><code class="language-json">{
  &quot;main&quot;: &quot;./lib/index.js&quot;, // 指向 CommonJS 模块规范的代码入口文件
  &quot;module&quot;: &quot;./lib/index.es.js&quot; // 指向 ES Module 模块规范的代码入口文件
}
</code></pre>
<p>如上配置要求你的包中要发布两种模块规范的版本。如果你的 npm 环境支持 module 字段，则会优先使用 ES Module 模块规范的入口文件，如果不支持则会使用 CommonJS 模块规范的入口文件。</p>
</li>
<li>
<p>其实要想发布一个支持 tree shaking 机制的包，最主要是要构建出一个符合 module 字段要求的源文件，也就是一个既符合 ES Module 模块规范但是又采用 ES5 语法的源文件。
rollup 可以直接构建出符合 ES Module 模块规范的文件，但是 webpack 不能。所以我们只需要使用 rollup 提供的构建能力，在配置文件中把 output 的格式设置为 es 即可</p>
</li>
<li>
<p>为了更好地使用 ES Module 模块规范来开启 tree shaking 功能，优先选用 rollup 来开发 npm 包</p>
</li>
<li>
<p>基于 ES6 模块规范是为了用户在使用我们的包时可以享受 Tree Shaking 带来的好处；使用 ES5 语法书写是为了用户在配置 babel 插件时可以放心的屏蔽 node_modules 目录</p>
</li>
</ul>
</div>
  </body>
</html>
