<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - 语言基础</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/27/2022, 3:54:23 PM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="content markdown-body"><h1>语言基础</h1>
<h1>arguments</h1>
<ul>
<li>是一个类数组对象，存储传入函数的全部参数。（类数组对象：属性是 0 开始的下标，并且有 length 属性，但没有数组独有的方法）</li>
<li>callee 属性：当前函数的引用</li>
<li>妙用：递归、参数累加</li>
</ul>
<h2>为什么 ES6 不推荐使用 arguments.callee()</h2>
<ul>
<li>访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响浏览器的性能，还会影响闭包。</li>
<li>当一个函数必须调用自身的时候，假如它是函数表达式则给它命名，或者使用函数声明，避免使用 callee</li>
</ul>
<h1>delete 机制</h1>
<ul>
<li>使用 delete 操作符并不会直接释放内存，与 V8 引擎有关</li>
<li>最有效的方式，应该是将不需要的属性设置为 undefined</li>
<li>在实际业务中可以考虑使用 Map 来代替 object，map 包装对象有 delete 方法，比以上方式都快</li>
</ul>
<h1>0.1 + 0.2 为什么不等于 0.3</h1>
<ul>
<li>二进制模拟十进制进行计算时 的精度问题</li>
</ul>
<h1>es6 新特性</h1>
<ul>
<li>箭头函数</li>
<li>Promise</li>
<li>拓展运算符和解构赋值</li>
<li>对象和数组解构</li>
<li>let const</li>
<li>模板字符串</li>
<li>函数的参数默认值</li>
<li>class</li>
<li>for…of 和 for…in</li>
<li>模块</li>
<li>尾调用优化 TCO</li>
</ul>
<h1>var let const</h1>
<ul>
<li>const 用于声明常量，const 声明的一般类型的变量，不能修改</li>
<li>const 声明的对象，属性可以被修改</li>
<li>用 var 重复声明不会报错，但 let 和 const 会</li>
<li>var 会使变量提升，变量可以在 var 声明之前使用。let 和 const 不会使变量提升，提前使用会报错。</li>
</ul>
<h1>柯里化</h1>
<ul>
<li>含义：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</li>
<li>意义：让人们将关注的重点聚焦到函数本身，而不因冗余的数据参数分散注意力，单一参数的纯函数是最简单的，目的单纯、职责单一、灵活且通用</li>
<li>缺点：过度使用会占用较大的堆栈空间</li>
<li>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用</li>
<li>把一个多参数的函数转化为单参数函数的方法 好处：</li>
<li>提高程序性能</li>
<li>使代码模块化，减少耦合增强其可维护性</li>
<li>经过柯里化之后，函数的通用性有所降低，但是适用性有所提高</li>
</ul>
<pre><code class="language-javascript">// 手写柯里化

const add = function (a, b, c) {
  return a + b + c;
};

function curry(fn) {
  return function curryFun(...args) {
    if (args.length &lt; fn.length) {
      return function () {
        return curryFun(...args.concat(Array.from(arguments)));
      };
    }
    return fn(...args);
  };
}

const curried = curry(add);

const a = curried(1)(9)(3);
const b = curried(2, 8)(6);

console.log({ a, b });
</code></pre>
<h1>闭包</h1>
<ul>
<li>能够访问已经被销毁的执行期上下文的活动对象的函数</li>
<li>闭包就是指有权访问另一个函数作用域中的变量的函数</li>
<li>应用主要场合：设计私有的方法和变量。</li>
<li>优点：可以避免全局变量的污染</li>
<li>缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露。</li>
<li>闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，才是形成闭包，子函数所在的父函数的作用域不会被释放。</li>
<li>父函数被销毁 的情况下，返回出的子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象。</li>
</ul>
<h2>如何优化闭包</h2>
<ul>
<li>通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）</li>
</ul>
<pre><code class="language-jsx">function outerFun(outerArg) {
  return function () {
    console.log('这里是内部匿名函数');
    console.log('可以访问包含函数的变量', outerArg);
  };
}
var create = outerFun('hi');
// 创建一个函数，是 outerFun 中返回的匿名函数create();
// 调用函数，是调用匿名函数create = null;
// 释放对匿名函数的引用
</code></pre>
<ul>
<li>如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题。</li>
<li>利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁。</li>
</ul>
<h1>垃圾回收</h1>
<ul>
<li>现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数</li>
</ul>
<h2>标记清除（主流）</h2>
<ul>
<li>当变量进入执行环境时，就标记这个变量为“进入环境”</li>
<li>从逻辑上讲，不能释放进入环境的变量所占用的内存，因为会有可能用到</li>
<li>当变量离开环境时，则将其标记为“离开环境”。</li>
<li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</li>
</ul>
<h2>引用计数</h2>
<ul>
<li>如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收。</li>
<li>跟踪记录每个值被引用的次数</li>
<li>当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1</li>
<li>相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1</li>
<li>当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来</li>
</ul>
<h2>为什么标记清除是主流的</h2>
<p>引用计数垃圾收集有一个缺点，就是循环引用会造成对象无法被回收 引用计数有个最大的问题：循环引用。比如对象 A 有一个属性指向对象 B，而对象 B 也有有一个属性指向对象 A 这样通过各自的属性相互引用；也就是说这两个对象的引用次数都是 2。在采用引用计数的策略时，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，对象 A 和对象 B 还将会继续存在，因为他们的引用次数永远不会是 0。这样的相互引用如果说很大量的存在就会导致大量的内存泄露。</p>
<h2>如何避免垃圾回收</h2>
<ul>
<li>对象尽量复用</li>
<li>数组优化： 将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</li>
</ul>
<h2>引起内存泄漏的操作</h2>
<ul>
<li>全局变量</li>
<li>闭包</li>
<li>dom 清除，事件绑定未清除</li>
<li>未清除的计时器</li>
<li>setTimeout 的第一个参数使用字符串而非函数</li>
<li>引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环</li>
</ul>
<h1>js 数据类型</h1>
<ul>
<li>基本类型：undefined、null、number、boolean、string、Symbol、BigInt（BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数）</li>
<li>栈内存：是一种特殊的线性表，它具有后进先出的特性，存放基本类型</li>
<li>堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象)</li>
<li>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据</li>
<li>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li>
<li>引用类型：Object、Array、Function、内置对象（Array、Date、Math 等等）</li>
<li>JS 类型判断 Object.prototype.toString.call()</li>
</ul>
<h1>null 和 undefined 区别</h1>
<p>null 表示没有对象，即该处不应该有值。
undefined 表示缺少值，即此处应该有值，但没有定义。
typeof null 为 object
typeof undefined 为 undefined</p>
<p>null 和 undefined 转换成 number 数据类型时，
null 转成 0 undefined 转成 NaN</p>
<h1>为什么会出现精度丢失</h1>
<ul>
<li>这跟浮点数在计算机内部（用二进制存储）的表示方法有关</li>
<li>JS 采用 IEEE 754 标准的 64 位双精度浮点数表示法，这个标准是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，也被很多语言如 java、python 采用。</li>
</ul>
<p>这个标准，会让大部分的十进制小数都不能用二进制浮点数来精确表示（比如转成二进制就会变成无限小数）。所以一般情况下，你输入的十进制小数仅由实际存储在计算机中的近似的二进制浮点数表示。</p>
<p>然而，许多语言在处理的时候，在一定误差范围内（通常极小）会将结果修正为正确的目标数字，而不是像 JS 一样将存在误差的真实结果转换成最接近的小数输出</p>
<h1>深拷贝、浅拷贝</h1>
<ul>
<li>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign 或 展开运算符</li>
<li>深拷贝：
<ul>
<li>JavaScript 包含基本类型（如字符串、数字、布尔）和引用类型（如数组、对象）</li>
<li>基本数据类型按值访问、引用类型的值按照引用访问</li>
<li>直接复制引用类型的值，实际上是一个内存地址的指针，修改新的变量，原变量也会被修改</li>
</ul>
</li>
<li>手写深拷贝：</li>
</ul>
<pre><code class="language-jsx">function deepCopy(obj) {
  // 1、判断是否是简单数据类型，
  if (typeof obj == 'object') {
    // 2、复杂数据类型
    var result = obj.constructor == Array ? [] : {};
    for (let i in obj) {
      result[i] = typeof obj[i] == 'object' ? deepCopy(obj[i]) : obj[i];
    }
  } else {
    // 简单数据类型 直接赋值
    var result = obj;
  }
  return result;
}
</code></pre>
<h1>描述 Promise</h1>
<ul>
<li>用来解决回调地狱</li>
<li>实例化一个 Promise 需要传入一个函数，业务代码在这个函数中执行，这个函数往往接收两个参数 resolve 和 reject</li>
<li>在函数中业务代码执行成功了，调用 resolve 函数，可以把 Promise 的状态变为已成功，通过参数把成功的结果传递出去，能在这个 Promise 对象的 then 方法中获取，then 方法可以链式调用多次，then 方法接受一个函数作为参数，这个函数的参数就是 resolve 传递出来的结果</li>
<li>在函数中业务代码执行失败了，调用 reject 函数，可以把 Promise 的状态变为已失败，通过参数把失败的结果传递出去，能在这个 Promise 对象的 catch 方法中获取，catch 方法和 then 方法用法一致，也是接受一个函数作为参数</li>
<li>无论结果如何都会走 finally 方法</li>
<li>Promise.all 接受一个数组作为参数，都是 Promise 实例，调用 Promise.all 的时候，这些实例会一起开始执行，返回一个结果数组，只有全部实例的状态是已完成，结果的状态才会是已完成，只要有一个失败，结果就是失败</li>
<li>Promise.race 接受一个数组作为参数，都是 Promise 实例，返回一个结果数组，调用 Promise.race 的时候，传进去的实例是竞赛关系，哪个结果获得的快，就返回那个结果</li>
</ul>
<h1>手写 Promise</h1>
<pre><code class="language-jsx">// 在这里用Symbol定义三种状态，防止外部改变状态
const Pending = Symbol('Pending');
// 进行中
const Fulfilled = Symbol('Fulfilled');
// 已成功
const Rejected = Symbol('Rejected');
// 已失败
const handleValue = (promise, x, resolve, reject) =&gt; {
  // 循环引用，自己等待自己完成，会出错，用reject传递出错误原因
  if (promise === x) {
    return reject(new TypeError('检测到Promise的链式循环引用'));
  }
  // 确保递归解析中只传递出去一次值
  let once = false;
  if ((x !== null &amp;&amp; typeof x === 'object') || typeof x === 'function') {
    try {
      // 防止重复去读取x.then
      let then = x.then;
      // 判断x是不是Promise
      if (typeof then === 'function') {
        //调用then实例方法处理Promise执行结果
        then.call(
          x,
          (y) =&gt; {
            if (once) return;
            once = true;
            // 防止Promise中Promise执行成功后又传递一个Promise过来，
            // 要做递归解析。
            handleValue(promise, y, resolve, reject);
          },
          (r) =&gt; {
            if (once) return;
            once = true;
            reject(r);
          }
        );
      } else {
        // 如果x是个普通对象，直接调用resolve(x)
        resolve(x);
      }
    } catch (err) {
      if (once) return;
      once = true;
      reject(err);
    }
  } else {
    // 如果x是个原始值，直接调用resolve(x)
    resolve(x);
  }
};
class Promise {
  constructor(executor) {
    this.status = Pending;
    //存储 Promise 的状态
    this.value = undefined;
    //存储executor函数中业务代码执行成功的结果
    this.reason = undefined;
    //存储executor函数中业务代码执行失败的原因
    this.onFulfilled = [];
    //executor函数中业务代码执行成功回调函数的集合
    this.onRejected = [];
    //executor函数中业务代码执行失败回调函数的集合
    const resolve = (value) =&gt; {
      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。
      if (this.status === Pending) {
        this.status = Fulfilled;
        this.value = value;
        // 依次调用成功回调函数
        this.onFulfilled.forEach((fn) =&gt; fn());
      }
    };
    const reject = (value) =&gt; {
      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。
      if (this.status === Pending) {
        this.status = Rejected;
        this.reason = value;
        // 依次调用失败回调函数
        this.onRejected.forEach((fn) =&gt; fn());
      }
    };
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (v) =&gt; v;
    onRejected =
      typeof onRejected === 'function'
        ? onRejected
        : (err) =&gt; {
            throw err;
          };
    let promise = new Promise((resolve, reject) =&gt; {
      if (this.status === Fulfilled) {
        setTimeout(() =&gt; {
          try {
            let x = onFulfilled(this.value);
            handleValue(promise, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        }, 0);
      }
      if (this.status === Rejected) {
        if (onRejected &amp;&amp; typeof onRejected === 'function') {
          setTimeout(() =&gt; {
            try {
              let x = onRejected(this.reason);
              handleValue(promise, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        }
      }
      if (this.status === Pending) {
        this.onFulfilled.push(() =&gt; {
          setTimeout(() =&gt; {
            try {
              let x = onFulfilled(this.value);
              handleValue(promise, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
        if (onRejected &amp;&amp; typeof onRejected === 'function') {
          this.onRejected.push(() =&gt; {
            setTimeout(() =&gt; {
              try {
                let x = onRejected(this.reason);
                handleValue(promise, x, resolve, reject);
              } catch (error) {
                reject(error);
              }
            }, 0);
          });
        }
      }
    });
    return promise;
  }
  static resolve(param) {
    if (param instanceof Promise) {
      return param;
    }
    return new Promise((resolve, reject) =&gt; {
      if (param &amp;&amp; Object.prototype.toString.call(param) === '[object Object]' &amp;&amp; typeof param.then === 'function') {
        setTimeout(() =&gt; {
          param.then(resolve, reject);
        }, 0);
      } else {
        resolve(param);
      }
    });
  }
  static reject(param) {
    return new Promise((resolve, reject) =&gt; {
      reject(param);
    });
  }
  static all(promises) {
    //将参数promises转为一个真正的数组
    promises = Array.from(promises);
    return new Promise((resolve, reject) =&gt; {
      const length = promises.length;
      let value = [];
      if (length) {
        value = Array.apply(null, { length: length });
        for (let i = 0; i &lt; length; i++) {
          Promise.resolve(promises[i]).then(
            (res) =&gt; {
              value[i] = res;
              if (value.length == length) {
                resolve(value);
              }
            },
            (err) =&gt; {
              reject(err);
              return;
            }
          );
        }
      } else {
        resolve(value);
      }
    });
  }
  static race(promises) {
    //将参数promises转为一个真正的数组
    promises = Array.from(promises);
    return new Promise((resolve, reject) =&gt; {
      const length = promises.length;
      if (length) {
        for (let i = 0; i &lt; length; i++) {
          Promise.resolve(promises[i]).then(
            (res) =&gt; {
              resolve(res);
              return;
            },
            (err) =&gt; {
              reject(err);
              return;
            }
          );
        }
      } else {
        return;
      }
    });
  }
}
</code></pre>
<h1>描述 async/await</h1>
<ul>
<li>async 用来声明函数，告诉解释器这是一个异步函数，只有 async 声明的函数里面才能用 await</li>
<li>await 用来等待一个 promise 执行结束，可以返回 promise 对象 resolve 出来的结果</li>
<li>如果 await 等待的这个 Promise 对象出错或者结果为 reject，可以通过 try catch 捕获到错误</li>
</ul>
<h1>Array 的方法</h1>
<ul>
<li>isArray()</li>
<li>indexOf、lastIndexOf</li>
<li>toString() 返回字符串，逗号分隔</li>
<li>push(o:any) 在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，会改变原数组</li>
<li>pop() 删除数组的最后一个元素，并返回该元素，会改变原数组</li>
<li>shift() 删除数组的第一个元素，并返回该元素，会改变原数组</li>
<li>unshift(o:any) 在数组的第一个位置添加元素，并返回添加新元素后的数组长度，会改变原数组</li>
<li>join(o:str) 以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔</li>
<li>concat(o:array) 用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变</li>
<li>reverse 用于颠倒排列数组元素，返回改变后的数组，会改变原数组</li>
<li>slice(start, end) 用于提取目标数组的一部分，返回一个新数组，原数组不变</li>
<li>splice(start, count, addElement1, addElement2, …) 用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。会改变原数组</li>
<li>sort</li>
<li>map、forEach、filter、some、every、reduce、reduceRight</li>
</ul>
<h1>String 的方法</h1>
<ul>
<li>split(o:str) 按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组</li>
<li>toLowerCase、toUpperCase</li>
<li>trim 用于去除字符串两端的空格，返回一个新字符串，不改变原字符串</li>
<li>indexOf、lastIndexOf</li>
<li>substr 用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同</li>
<li>substring(start, end) 用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）</li>
<li>slice(start, end) 用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）</li>
<li>concat 用于连接两个字符串，返回一个新字符串，不改变原字符串</li>
<li>charAt(num) 返回指定位置的字符，参数是从 0 开始编号的位置，这个方法完全可以用数组下标替代</li>
<li>fromCharCode 方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串</li>
<li>btoa 任意值转为 Base64 编码</li>
<li>atob Base64 编码转为原来的值</li>
</ul>
<h1>数组的遍历迭代方法</h1>
<ul>
<li>for in
以任意顺序遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行。</li>
</ul>
<blockquote>
<p>如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性。</p>
</blockquote>
<ul>
<li>for of
ES6 新增，用来替代 for in 和 forEach，可以遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构。</li>
<li>forEach
遍历数组中的每一项，没有返回值，对原数组没有影响，注意：在 forEach 中用 return 不会返回，break 不会跳出，函数会继续执行。</li>
<li>map
返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li>
<li>filter
返回通过过滤的元素，不改变原来的数组。</li>
<li>some
用于检测数组中的某个元素是否满足指定条件,返回 boolean 值，不改变原数组。</li>
<li>every
用于检测数组中的所有元素是否都符合指定条件，返回 boolean 值，不改变原数组。</li>
<li>reduce
接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li>
<li>reduceRight
和 reduce() 功能是一样的，它是从数组的末尾处向前开始计算。</li>
<li>find 返回通过测试（函数内判断）的数组的第一个元素的值。</li>
</ul>
<p>forEach、for in、for of 三者区别：</p>
<ul>
<li>forEach 更多的用来遍历数组</li>
<li>for in 一般常用来遍历对象或 json</li>
<li>for of 数组对象都可以遍历，遍历对象需要通过和 Object.keys()</li>
<li>for in 循环出的是 key，for of 循环出的是 value</li>
</ul>
<h1>原型链</h1>
<ul>
<li>原型是一个对象，其他对象可以通过它实现属性继承</li>
<li>原型对象上的所有属性和方法，都能被对应的构造函数创建的实例对象共享（这就是 JavaScript 继承机制的基本设计）</li>
<li>JavaScript 对象通过 prototype 指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条, 即原型链。</li>
<li>每一个 JavaScript 对象都和另一个对象相关联，相关联的这个对象就是我们所说的“原型”。对象会从它的原型继承属性和方法。</li>
<li>如果试图引用实例的某个属性或方法，会首先在对象内部寻找，直至找不到，才在该对象的原型里去找这个属性或方法。</li>
<li>instanceof 判断是否处于原型链</li>
<li>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</li>
<li>使用 for in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会遍历到</li>
<li>原型链是利用原型让一个引用类型继承另一个引用类型的属性和方法</li>
<li>几乎所有 JavaScript 中的对象都是位于原型链顶端的 空对象 的实例</li>
<li>当 js 引擎查找对象的属性时，先查找对象本身是否存在该属性，如果不存在，会在原型链上查找</li>
<li>原型链顶端就是一个 空对象</li>
</ul>
<h2>typeof 和 instanceof 区别</h2>
<ul>
<li>typeof：判断一个变量的类型</li>
<li>instanceof：判断一个变量是否是某个对象的实例</li>
<li>instanceof 原理：能在实例的 原型对象链 中找到该构造函数的 prototype 属性所指向的 原型对象，就返回 true</li>
</ul>
<h2>原型对象 和 构造函数</h2>
<ul>
<li>在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象。</li>
<li>当函数经过 new 调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个 <strong>proto</strong> 属性，指向构造函数的原型对象。</li>
</ul>
<h2>声明方法为什么要用 prototype</h2>
<ul>
<li>让每个对象共享</li>
<li>通过该构造函数生成的实例所拥有的方法都是指向一个函数的索引，这样可以节省内存</li>
</ul>
<h2>prototype 和 proto 和 constructor 的关系</h2>
<ul>
<li>prototype 用于访问函数的原型对象。它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，任何函数在创建的时候，其实会默认同时创建该函数的 prototype 对象</li>
<li><strong>proto</strong> 用于访问对象实例的原型对象（或者使用 Object.getPrototypeOf()）</li>
<li><strong>proto</strong> 是对象独有的</li>
<li><strong>proto</strong> 作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<strong>proto</strong>属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的<strong>proto</strong>属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找，直到原型链顶端 null 空对象</li>
<li>constructor 属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数</li>
</ul>
<h1>new 干了什么</h1>
<ul>
<li>创建一个空对象</li>
<li>将构造函数的作用域赋给新对象</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ul>
<p>new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。</p>
<ul>
<li>手写 new</li>
</ul>
<pre><code class="language-jsx">const createNew = (Con, ...args) =&gt; {
  const obj = {};
  Object.setPrototypeOf(obj, Con.prototype);
  let result = Con.apply(obj, args);
  return result instanceof Object ? result : obj;
};
</code></pre>
<h1>apply、call、bind</h1>
<ul>
<li>都是用来改变函数 this 的指向</li>
</ul>
<p>区别：</p>
<ul>
<li>apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li>
<li>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用，bind 与 apply/call 一样都能改变函数 this 指向，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数，你需要再次调用此函数才能达到最终执行</li>
</ul>
<h2>手写</h2>
<pre><code class="language-jsx">// call
Function.prototype.myCall = function (context, ...args) {
  context = context || new Object(context);
  const key = Symbol();
  context[key] = this;
  const result = context[key](...args);
  delete context[key];
  return result;
};

// apply
Function.prototype.myApply = function (context) {
  context = context || new Object(context);
  const key = Symbol();
  const args = arguments[1];
  context[key] = this;
  const result = args ? context[key](...args) : context[key]();
  delete context[key];
  return result;
};

// bind
// 接受一个或者多个参数，第一个是要绑定的上下文，第二个是额外参数
// 返回原函数的拷贝，即返回一个新函数，这个函数具备原函数的功能，支持柯里化（柯里化就是在函数调用时只传递一部分参数进行调用，函数会返回一个新函数去处理剩下的参数）
Function.prototype.myBind = function (context, ...args) {
  const fn = this;
  const bindFn = function (...newFnArgs) {
    return fn.call(this instanceof bindFn ? this : context, ...args, ...newFnArgs);
  };
  bindFn.prototype = Object.create(fn.prototype);
  return bindFn;
};
</code></pre>
<h1>尾调用和尾递归</h1>
<ul>
<li>指某个函数的最后一步是调用另一个函数</li>
<li>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生栈溢出错误</li>
<li>但对于尾递归来说，由于只存在一个调用记录，所以不会发生栈溢出</li>
</ul>
<pre><code class="language-javascript">function factorial(num) {
  if (num === 1) return 1;
  return num * factorial(num - 1);
}

console.log(factorial(5));
console.log(factorial(10));
</code></pre>
<h1>正则表达式</h1>
<p>https://wangdoc.com/javascript/stdlib/regexp.html</p>
<h1>为什么定义类的方法使用 prototype</h1>
<ul>
<li>为了在类的各个实例间共享</li>
<li>不使用 prototype 定义的方法相当于类的静态方法，可以直接使用，不需要 new</li>
<li>使用 prototype 定义的方法相当于类的实例方法，必须 new 后才能使用</li>
</ul>
<h1>继承</h1>
<ul>
<li>JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承</li>
<li>JavaScript 也没有在语言层面提供对抽象类和接口的支持</li>
<li>许多面向对象语言都支持两种继承方式: 接口继承 和 实现继承</li>
<li>接口继承只继承方法签名，而实现继承则继承实际的方法</li>
<li>在 JavaScript 中无法实现接口继承，只支持实现继承，而且其实现继承主要是依靠原型链来实现的</li>
<li>所有对象（函数是 prototype）都有一个 proto 属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</li>
<li>确定是否原型与实例的关系：instanceof、isPrototypeOf()</li>
<li>以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链</li>
</ul>
<h2>原型链继承</h2>
<ul>
<li>直接通过原型继承属性和方法</li>
</ul>
<pre><code class="language-jsx">Son.prototype = new Father();
</code></pre>
<p>缺点：</p>
<ul>
<li>原型中包含引用值的时候，会在所有实例间共享，修改子类引用类型属性会影响到父类</li>
<li>子类型在实例化时不能给父类型的构造函数传参</li>
</ul>
<h2>盗用构造函数</h2>
<ul>
<li>为了解决原型包含引用值导致的继承问题（含引用类型值的原型属性会被所有实例共享）</li>
<li>在子类型构造函数的内部调用父类型构造函数</li>
<li>优点是可以在子类构造函数中向父类构造函数传参</li>
</ul>
<pre><code class="language-jsx">function Father() {
  this.colors = ['red', 'blue', 'green'];
}
function Son() {
  Father.call(this);
  // 继承了Father，且向父类型传递参数
}
</code></pre>
<p>缺点：</p>
<ul>
<li>必须在构造函数中定义方法，因此函数不能重用</li>
<li>子类也不能访问父类原型上定义的方法</li>
</ul>
<h2>组合继承</h2>
<ul>
<li>原型链继承和盗用构造函数继承的结合</li>
<li>使用原型链实现对原型属性和方法的继承</li>
<li>通过盗用构造函数来实现对实例属性的继承</li>
<li>既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性</li>
</ul>
<pre><code class="language-jsx">function Father(name) {
  this.name = name;
  this.colors = ['red', 'blue', 'green'];
}
Father.prototype.sayName = function () {
  alert(this.name);
};
function Son(name, age) {
  // 继承属性
  Father.call(this, name);
  this.age = age;
}
// 继承方法
Son.prototype = new Father();
Son.prototype.constructor = Son;
Son.prototype.sayAge = function () {
  alert(this.age);
};
</code></pre>
<h2>原型式继承</h2>
<ul>
<li>即相当于 ES6 的 Object.create()方法</li>
<li>适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</li>
<li>创建一个临时构造函数</li>
<li>将传入的对象赋值给这个构造函数的原型</li>
<li>然后返回这个临时类型的一个实例</li>
</ul>
<pre><code class="language-jsx">function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
</code></pre>
<h2>寄生式继承</h2>
<ul>
<li>类似工厂模式</li>
<li>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</li>
<li>适合主要关注对象，而不在乎类型和构造函数的场景</li>
<li>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似</li>
</ul>
<pre><code class="language-jsx">var book = { name: 'js book', likeBook: ['html book', 'css book'] };
function createBook(obj) {
  // 通过原型方式创建新的对象
  var o = new inheritObject(obj);
  // 拓展新对象
  o.getName = function (name) {
    console.log(name);
  };
  // 返回拓展后的新对象
  return o;
}
</code></pre>
<h2>寄生组合继承</h2>
<ul>
<li>组合继承的问题：会调用两次父类型构造函数，创建子类原型时、在子类构造函数内部</li>
<li>通过借用构造函数来继承属性</li>
<li>通过原型链的混成形式来继承方法</li>
<li>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已</li>
</ul>
<pre><code class="language-jsx">function Father(foo) {
  this.foo = foo;
}
Father.prototype.printFoo = function () {
  console.log(this.foo);
};
function Son(bar) {
  this.bar = bar;
  Father.call(this);
}
Son.prototype = Object.create(Super.prototype);
Son.prototype.constructor = Son;
</code></pre>
<h2>ES6 的 extends</h2>
<pre><code class="language-jsx">class Father {
  constructor(foo) {
    this.foo = foo;
  }
  printFoo() {
    console.log(this.foo);
  }
}
class Son extends Father {
  constructor(foo, bar) {
    super(foo);
    this.bar = bar;
  }
}
</code></pre>
</div>
  </body>
</html>
