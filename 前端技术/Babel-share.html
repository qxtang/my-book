<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - Babel</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/31/2022, 10:14:08 AM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="content markdown-body"><h1>概念</h1>
<ul>
<li>一个 JavaScript 翻译器</li>
<li>将 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在各种环境中</li>
<li>通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）</li>
</ul>
<h1>基本工作原理</h1>
<ul>
<li>
<p>第 1 步 解析（Parse）<br>
通过解析器 babylon 将代码解析成抽象语法树</p>
</li>
<li>
<p>第 2 步 转换（TransForm）<br>
通过 babel-traverse plugin 对抽象语法树进行深度优先遍历，遇到需要转换的，就直接在 AST 对象上对节点进行添加、更新及移除操作，比如遇到箭头函数，就转换成普通函数，最后得到新的 AST 树</p>
</li>
<li>
<p>第 3 步 生成（Generate）<br>
通过 babel-generator 将 AST 树生成 es5 代码</p>
</li>
</ul>
<p><img src="../resource/20220330141846.png" alt=""></p>
<p><img src="../resource/20220330141837.png" alt=""></p>
<h1>配置</h1>
<p>主要分为 presets 和 plugins</p>
<h2>.babelrc._ 和 babel.config._ 区别</h2>
<ul>
<li>.babelrc.* 仅适用于项目的某个部分</li>
<li>babel.config.* 会影响整个项目中的代码，包含 node_modules 中的代码</li>
<li>推荐使用 babel.config.*，Babel 自身使用的就是这种格式</li>
</ul>
<h2>presets</h2>
<ul>
<li>逆序处理，从后往前，这主要是为了确保向后兼容，由于大多数用户将 &quot;es2015&quot; 放在 &quot;stage-0&quot; 之前，</li>
<li>可以是数组、对象、字符串</li>
</ul>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    &quot;presetA&quot;, // bare string
    [&quot;presetA&quot;], // wrapped in array
    [&quot;presetA&quot;, {}] // 2nd argument is an empty options object
  ]
}
</code></pre>
<h3>useBuiltIns</h3>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;debug&quot;: true
      }
    ]
  ]
}
</code></pre>
<ul>
<li>babel 在转译的时候，会将源代码分成 syntax（语法） 和 api 两部分来处理，语法处理通过配置 presets，</li>
<li>babel 使用 polyfill 来处理 api，@babel/preset-env 中有一个配置选项 useBuiltIns，用来告诉 babel 如何处理 api，由于这个选项默认值为 false，即不处理 api，所以代码转译后默认没有处理 api，可以通过手动引入 polyfill，但是 polyfill 没有动态引入会增加包的体积，</li>
<li>设置 useBuiltIns 的值为 &quot;entry&quot;，同时在源代码的最上方手动引入 <code>@babel/polyfill</code> 这个库（该库一共分为两部分，第一部分是 core-js，第二部分是 regenerator-runtime。其中 core-js 为其他团队开源的另一个独立项目），此时 babel 根据项目 browserslist，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 <code>import '@babel/polyfill'</code>，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill</li>
<li>将 useBuiltIns 改为 &quot;usage&quot;，babel 就可以按需加载 polyfill，并且不需要手动引入 <code>@babel/polyfill</code></li>
</ul>
<h4>存在的问题</h4>
<ul>
<li>polyfill 会直接在全局对象上定义方法，比如 Array.include，众所周知前端开发不鼓励污染全局变量，</li>
<li>babel 会向翻译后的<strong>每一个</strong>文件原地定义许多帮助函数，用于转义语法，比如 <code>__spreadArray</code>、<code>__generator</code>,</li>
</ul>
<h2>plugins</h2>
<ul>
<li>本质就是一个 JS 程序, 指示 Babel 如何对代码进行转换</li>
<li>排列顺序很重要</li>
<li>插件在 presets 前运行</li>
<li>插件顺序从前往后排列，与 presets 相反</li>
</ul>
<h1>核心与其周边</h1>
<h2>@babel/core</h2>
<ul>
<li>babel 使用了微内核的架构风格，也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的，@babel/core 就是这个内核</li>
<li>作用：
<ul>
<li>加载和处理配置(config)</li>
<li>加载插件</li>
<li>调用 Parser 进行语法解析，生成 AST</li>
<li>调用 Traverser 遍历 AST，并使用访问者模式应用'插件'对 AST 进行转换</li>
<li>生成代码，包括 SourceMap 转换和源代码生成</li>
</ul>
</li>
</ul>
<h2>@babel/cli</h2>
<p>命令行工具</p>
<h2>@babel/plugin-transform-runtime</h2>
<ul>
<li>这个插件就是为了解决 polyfill 污染全局的问题，</li>
<li>其中 <code>@babel/plugin-transform-runtime</code> 的作用是转译代码，转译后的代码中可能会引入 <code>@babel/runtime-corejs3</code> 里面的模块。</li>
<li>前者运行在编译时，后者运行在运行时。类似 polyfill，后者需要被打包到最终产物里在浏览器中运行。</li>
</ul>
<p>安装：</p>
<pre><code class="language-sh">$ yarn add @babel/plugin-transform-runtime -D
$ yarn add @babel/runtime-corejs3
</code></pre>
<p>修改配置如下：</p>
<pre><code class="language-json">{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;,
      {
        &quot;useBuiltIns&quot;: &quot;usage&quot;,
        &quot;debug&quot;: true
      }
    ]
  ],
  &quot;plugins&quot;: [
    [
      &quot;@babel/plugin-transform-runtime&quot;,
      {
        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本，目前有 2 3 两个版本
      }
    ]
  ]
}
</code></pre>
<p>引入了这个插件后：</p>
<ul>
<li>api 从之前的直接修改原型改为了从一个统一的模块中引入，避免了对全局变量及其原型的污染</li>
<li>helpers 从之前的原地定义改为了从一个统一的模块中引入，使得打包的结果中每个 helper 只会存在一个</li>
</ul>
<h2>@babel/parser</h2>
<ul>
<li>将源代码解析为 AST</li>
<li>已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的 ECMAScript 规范</li>
</ul>
<h2>@babel/traverse</h2>
<ul>
<li>实现了访问者模式，对 AST 进行遍历，转换插件会通过它获取感兴趣的 AST 节点，对节点继续操作</li>
</ul>
<h2>@babel/generator</h2>
<ul>
<li>将 AST 转换为源代码，支持 SourceMap</li>
</ul>
<h2>@babel/preset-env</h2>
<ul>
<li>语法转换插件的集合</li>
<li>可以根据配置的目标浏览器或者运行环境（browserslist、targets），将 ES2015+ 的语法转换为 es5 语法，不需要一个个语法插件去安装（比如@babel/plugin-transform-arrow-functions）</li>
</ul>
<h2>core.js</h2>
<ul>
<li>新 api 集合</li>
</ul>
<h2>@babel/polyfill</h2>
<ul>
<li>@babel/polyfill 融合了 core-js 和 regenerator-runtime，因此 babel-polyfill 本质就是 corejs</li>
<li>官方提示已经 deprecated，推荐使用 core-js@3 + @babel/preset-env 即可<pre><code class="language-txt">🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions)
</code></pre>
</li>
</ul>
<h2>regenerator-runtime</h2>
<ul>
<li>生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现，运行时依赖，需要打包进产物</li>
</ul>
</div>
  </body>
</html>
