<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - 语言基础</title>

  <!-- styles -->
  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight.default.min.css" />
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <!-- scripts -->
  <script src="/my-book/resource/lib/jquery.min.js"></script>

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：4/11/2022, 12:00:47 PM -->

  <script>
    window.root = '/my-book';

    // 提前把搜索数据库载入内存
    fetch(`${window.root}/dir_tree.json`)
      .then(function (res) {
        return res.json();
      })
      .then(function (res) {
        window.__doc_builder_dirTree__ = res;
      });
  </script>
</head>

  <body>
    <ul class="menu expand" id="menu">
      <div class="search_bar" id="search_bar">
        <input type="text" placeholder="search..." />
        <img
          class="clear"
          id="clear"
          src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/circle-xmark.svg"
          alt=""
        />
        <div class="search_result" id="search_result"></div>
      </div>
      
            <ul class="parent open">
              <li id="工作沉淀" class="dir" title="工作沉淀">
                <span>工作沉淀</span>
                <div class="triangle"></div>
              </li>
              
          <li id="工作沉淀/Fiddler 真机调试微信 h5.md" class="children" title="Fiddler 真机调试微信 h5">
            <a href="/my-book/工作沉淀/Fiddler 真机调试微信 h5.html">Fiddler 真机调试微信 h5</a>
          </li>
        
          <li id="工作沉淀/GitFlow 学习笔记.md" class="children" title="GitFlow 学习笔记">
            <a href="/my-book/工作沉淀/GitFlow 学习笔记.html">GitFlow 学习笔记</a>
          </li>
        
          <li id="工作沉淀/Nginx 学习笔记.md" class="children" title="Nginx 学习笔记">
            <a href="/my-book/工作沉淀/Nginx 学习笔记.html">Nginx 学习笔记</a>
          </li>
        
          <li id="工作沉淀/动态校验企微应用可信域名.md" class="children" title="动态校验企微应用可信域名">
            <a href="/my-book/工作沉淀/动态校验企微应用可信域名.html">动态校验企微应用可信域名</a>
          </li>
        
          <li id="工作沉淀/工作中遇到问题汇总.md" class="children" title="工作中遇到问题汇总">
            <a href="/my-book/工作沉淀/工作中遇到问题汇总.html">工作中遇到问题汇总</a>
          </li>
        
          <li id="工作沉淀/我的最佳实践.md" class="children" title="我的最佳实践">
            <a href="/my-book/工作沉淀/我的最佳实践.html">我的最佳实践</a>
          </li>
        
          <li id="工作沉淀/敏捷迭代.md" class="children" title="敏捷迭代">
            <a href="/my-book/工作沉淀/敏捷迭代.html">敏捷迭代</a>
          </li>
        
          <li id="工作沉淀/登录方案.md" class="children" title="登录方案">
            <a href="/my-book/工作沉淀/登录方案.html">登录方案</a>
          </li>
        
          <li id="工作沉淀/设计稿多端适配方案.md" class="children" title="设计稿多端适配方案">
            <a href="/my-book/工作沉淀/设计稿多端适配方案.html">设计稿多端适配方案</a>
          </li>
        
            </ul>
          
            <ul class="parent open">
              <li id="前端技术" class="dir" title="前端技术">
                <span>前端技术</span>
                <div class="triangle"></div>
              </li>
              
            <ul class="parent open">
              <li id="前端技术/浏览器" class="dir" title="浏览器">
                <span>浏览器</span>
                <div class="triangle"></div>
              </li>
              
          <li id="前端技术/浏览器/事件循环.md" class="children" title="事件循环">
            <a href="/my-book/前端技术/浏览器/事件循环.html">事件循环</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器.md" class="children" title="浏览器">
            <a href="/my-book/前端技术/浏览器/浏览器.html">浏览器</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器架构.md" class="children" title="浏览器架构">
            <a href="/my-book/前端技术/浏览器/浏览器架构.html">浏览器架构</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器缓存.md" class="children" title="浏览器缓存">
            <a href="/my-book/前端技术/浏览器/浏览器缓存.html">浏览器缓存</a>
          </li>
        
            </ul>
          
          <li id="前端技术/AST抽象语法树.md" class="children" title="AST抽象语法树">
            <a href="/my-book/前端技术/AST抽象语法树.html">AST抽象语法树</a>
          </li>
        
          <li id="前端技术/Babel.md" class="children" title="Babel">
            <a href="/my-book/前端技术/Babel.html">Babel</a>
          </li>
        
          <li id="前端技术/Browserslist.md" class="children" title="Browserslist">
            <a href="/my-book/前端技术/Browserslist.html">Browserslist</a>
          </li>
        
          <li id="前端技术/CSS.md" class="children" title="CSS">
            <a href="/my-book/前端技术/CSS.html">CSS</a>
          </li>
        
          <li id="前端技术/Fiber.md" class="children" title="Fiber">
            <a href="/my-book/前端技术/Fiber.html">Fiber</a>
          </li>
        
          <li id="前端技术/Hooks.md" class="children" title="Hooks">
            <a href="/my-book/前端技术/Hooks.html">Hooks</a>
          </li>
        
          <li id="前端技术/Nodejs.md" class="children" title="Nodejs">
            <a href="/my-book/前端技术/Nodejs.html">Nodejs</a>
          </li>
        
          <li id="前端技术/React.md" class="children" title="React">
            <a href="/my-book/前端技术/React.html">React</a>
          </li>
        
          <li id="前端技术/Redux.md" class="children" title="Redux">
            <a href="/my-book/前端技术/Redux.html">Redux</a>
          </li>
        
          <li id="前端技术/Typescript.md" class="children" title="Typescript">
            <a href="/my-book/前端技术/Typescript.html">Typescript</a>
          </li>
        
          <li id="前端技术/Vue.md" class="children" title="Vue">
            <a href="/my-book/前端技术/Vue.html">Vue</a>
          </li>
        
          <li id="前端技术/Webpack.md" class="children" title="Webpack">
            <a href="/my-book/前端技术/Webpack.html">Webpack</a>
          </li>
        
          <li id="前端技术/npm.md" class="children" title="npm">
            <a href="/my-book/前端技术/npm.html">npm</a>
          </li>
        
          <li id="前端技术/函数式编程.md" class="children" title="函数式编程">
            <a href="/my-book/前端技术/函数式编程.html">函数式编程</a>
          </li>
        
          <li id="前端技术/原型链和继承.md" class="children" title="原型链和继承">
            <a href="/my-book/前端技术/原型链和继承.html">原型链和继承</a>
          </li>
        
          <li id="前端技术/微信开发.md" class="children" title="微信开发">
            <a href="/my-book/前端技术/微信开发.html">微信开发</a>
          </li>
        
          <li id="前端技术/微前端.md" class="children" title="微前端">
            <a href="/my-book/前端技术/微前端.html">微前端</a>
          </li>
        
          <li id="前端技术/手写题.md" class="children" title="手写题">
            <a href="/my-book/前端技术/手写题.html">手写题</a>
          </li>
        
          <li id="前端技术/模块.md" class="children" title="模块">
            <a href="/my-book/前端技术/模块.html">模块</a>
          </li>
        
          <li id="前端技术/虚拟列表.md" class="children" title="虚拟列表">
            <a href="/my-book/前端技术/虚拟列表.html">虚拟列表</a>
          </li>
        
          <li id="前端技术/设计模式.md" class="children" title="设计模式">
            <a href="/my-book/前端技术/设计模式.html">设计模式</a>
          </li>
        
          <li id="前端技术/语言基础.md" class="children" title="语言基础">
            <a href="/my-book/前端技术/语言基础.html">语言基础</a>
          </li>
        
            </ul>
          
          <li id="其他.md" class="children" title="其他">
            <a href="/my-book/其他.html">其他</a>
          </li>
        
          <li id="网络.md" class="children" title="网络">
            <a href="/my-book/网络.html">网络</a>
          </li>
        
      <li id="index.md" class="children about">
        <a href="/my-book/">关于</a>
      </li>
    </ul>
    <div class="drager" id="drager">
      <div class="switcher" id="switcher" title="展开或收起"></div>
    </div>
    <div class="mobile_menu" id="mobile_menu">
      <img src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/bars.svg" alt="" />
    </div>
    <div class="content markdown-body">
      <h1 id="js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" tabindex="-1"><a class="header-anchor" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">js 数据类型</a></h1>
<ul>
<li>基本类型：number、string、boolean、undefined、null、Symbol、BigInt（BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数）</li>
<li>引用类型：Object、Array、Function、内置对象（Date、Math 等等）</li>
<li>栈内存：是一种特殊的线性表，它具有后进先出的特性，存放基本类型</li>
<li>堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象)</li>
<li>基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据</li>
<li>引用数据类型存储在堆内存中，因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能</li>
<li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li>
</ul>
<h2 id="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD" tabindex="-1"><a class="header-anchor" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD">数据类型的判断</a></h2>
<ul>
<li>typeof：能判断所有值类型，函数。不可对 null、对象、数组进行精确判断，因为都返回 object</li>
<li>instanceof：能判断对象类型，不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型</li>
<li>使用 Object.prototype.toString.call()，所有原始数据类型都能判断，还有 Error 对象，Date 对象等</li>
</ul>
<h2 id="%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84" tabindex="-1"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84">如何判断变量是否为数组</a></h2>
<ul>
<li><code>Array.isArray(arr)</code></li>
<li><code>arr.__proto__ === Array.prototype</code></li>
<li><code>arr instanceof Array</code></li>
<li><code>Object.prototype.toString.call(arr)</code></li>
</ul>
<h2 id="null-%E5%92%8C-undefined-%E5%8C%BA%E5%88%AB" tabindex="-1"><a class="header-anchor" href="#null-%E5%92%8C-undefined-%E5%8C%BA%E5%88%AB">null 和 undefined 区别</a></h2>
<p>null 表示没有对象，即该处不应该有值。
undefined 表示缺少值，即此处应该有值，但没有定义。
typeof null 为 object
typeof undefined 为 undefined</p>
<p>null 和 undefined 转换成 number 数据类型时，
null 转成 0 undefined 转成 NaN</p>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1" tabindex="-1"><a class="header-anchor" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1">为什么会出现精度丢失</a></h2>
<ul>
<li>这跟浮点数在计算机内部（用二进制存储）的表示方法有关</li>
<li>JS 采用 IEEE 754 标准的 64 位双精度浮点数表示法，这个标准是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，也被很多语言如 java、python 采用。</li>
</ul>
<p>这个标准，会让大部分的十进制小数都不能用二进制浮点数来精确表示（比如转成二进制就会变成无限小数）。所以一般情况下，你输入的十进制小数仅由实际存储在计算机中的近似的二进制浮点数表示。</p>
<p>然而，许多语言在处理的时候，在一定误差范围内（通常极小）会将结果修正为正确的目标数字，而不是像 JS 一样将存在误差的真实结果转换成最接近的小数输出</p>
<h1 id="array-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1"><a class="header-anchor" href="#array-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95">Array 的一些不好记的方法</a></h1>
<p>全部：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>
<ul>
<li><code>push(element1, ..., elementN)</code>：在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，会改变原数组</li>
<li><code>pop()</code>：删除数组的最后一个元素，并返回该元素，会改变原数组</li>
<li><code>shift()</code>：删除数组的第一个元素，并返回该元素，会改变原数组</li>
<li><code>unshift(element1, ..., elementN)</code>：在数组的第一个位置添加元素，并返回添加新元素后的数组长度，会改变原数组</li>
<li><code>join([separator])</code>：以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔，<code>[1, 2, 3] =&gt; '1,2,3'</code></li>
<li><code>slice([begin[, end]])</code>：用于提取目标数组的一部分，返回一个新数组，原数组不变</li>
<li><code>splice(start[, deleteCount[, item1[, item2[, ...]]]])</code>：用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。会改变原数组</li>
</ul>
<h1 id="string-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95" tabindex="-1"><a class="header-anchor" href="#string-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95">String 的一些不好记的方法</a></h1>
<p>全部：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a></p>
<ul>
<li><code>substr(start[, length])</code>：要被废弃，跟 slice 和 substring 方法的作用相同</li>
<li><code>split([separator[, limit]])</code>：按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组 <code>'1,2,3' =&gt; [1, 2, 3]</code></li>
<li><code>substring(indexStart[, indexEnd])</code>：返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集</li>
<li><code>slice(beginIndex[, endIndex])</code>：提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串</li>
</ul>
<h1 id="delete-%E6%9C%BA%E5%88%B6" tabindex="-1"><a class="header-anchor" href="#delete-%E6%9C%BA%E5%88%B6">delete 机制</a></h1>
<ul>
<li>使用 delete 操作符并不会直接释放内存，与 V8 引擎有关</li>
<li>最有效的方式，应该是将不需要的属性设置为 undefined</li>
<li>在实际业务中可以考虑使用 Map 来代替 object，map 包装对象有 delete 方法，比以上方式都快</li>
</ul>
<h1 id="0.1-%2B-0.2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E-0.3" tabindex="-1"><a class="header-anchor" href="#0.1-%2B-0.2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E-0.3">0.1 + 0.2 为什么不等于 0.3</a></h1>
<ul>
<li>二进制模拟十进制进行计算时的精度问题</li>
<li>进制转换：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失</li>
<li>对阶运算：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0 舍 1 入），尾数位移时可能会发生数丢失的情况，影响精度</li>
</ul>
<p><strong>解决：</strong></p>
<ul>
<li>使用 Number.EPSILON 误差范围</li>
</ul>
<p>Number.EPSILON 表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isEqual</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(a - b) &lt; <span class="hljs-title class_">Number</span>.<span class="hljs-property">EPSILON</span>;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isEqual</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span>
</code></pre>
<h1 id="es6-%E6%96%B0%E7%89%B9%E6%80%A7" tabindex="-1"><a class="header-anchor" href="#es6-%E6%96%B0%E7%89%B9%E6%80%A7">es6 新特性</a></h1>
<ul>
<li>箭头函数</li>
<li>Promise</li>
<li>拓展运算符和解构赋值</li>
<li>对象和数组解构</li>
<li>let const</li>
<li>模板字符串</li>
<li>函数的参数默认值</li>
<li>class</li>
<li>for…of 和 for…in</li>
<li>模块</li>
<li>尾调用优化 TCO</li>
</ul>
<h1 id="var-let-const" tabindex="-1"><a class="header-anchor" href="#var-let-const">var let const</a></h1>
<ul>
<li>const 用于声明常量，const 声明的一般类型的变量，不能修改</li>
<li>const 声明的对象，属性可以被修改</li>
<li>用 var 重复声明不会报错，但 let 和 const 会</li>
<li>var 会使变量提升，变量可以在 var 声明之前使用。let 和 const 不会使变量提升，提前使用会报错。</li>
</ul>
<h1 id="%E6%9F%AF%E9%87%8C%E5%8C%96" tabindex="-1"><a class="header-anchor" href="#%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a></h1>
<ul>
<li>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术</li>
</ul>
<h2 id="%E6%84%8F%E4%B9%89" tabindex="-1"><a class="header-anchor" href="#%E6%84%8F%E4%B9%89">意义</a></h2>
<ul>
<li>让人们将关注的重点聚焦到函数本身，而不因冗余的数据参数分散注意力，单一参数的纯函数是最简单的，目的单纯、职责单一、灵活且通用</li>
<li>减少耦合增强其可维护性</li>
</ul>
<h2 id="%E7%BC%BA%E7%82%B9" tabindex="-1"><a class="header-anchor" href="#%E7%BC%BA%E7%82%B9">缺点</a></h2>
<ul>
<li>过度使用会占用较大的堆栈空间</li>
<li>经过柯里化之后，函数的通用性有所降低，但是适用性有所提高</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-comment">// 手写柯里化</span>

<span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curryFun</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &lt; fn.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">curryFun</span>([...args, ...<span class="hljs-variable language_">arguments</span>]);
      };
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...args);
  };
}

<span class="hljs-keyword">const</span> curried = <span class="hljs-title function_">curry</span>(add);

<span class="hljs-keyword">const</span> a = <span class="hljs-title function_">curried</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">9</span>)(<span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> b = <span class="hljs-title function_">curried</span>(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)(<span class="hljs-number">6</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>({ a, b });
</code></pre>
<h1 id="%E9%97%AD%E5%8C%85" tabindex="-1"><a class="header-anchor" href="#%E9%97%AD%E5%8C%85">闭包</a></h1>
<ul>
<li>函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包</li>
<li>闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量</li>
<li>能够访问已经被销毁的执行期上下文的活动对象的函数、有权访问另一个函数作用域中的变量的函数</li>
<li>函数做为参数传递或在尾部 return，并且子函数在外调用，形成闭包，子函数所在的父函数的作用域不会被释放，子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象</li>
<li>应用：设计私有的方法和变量。</li>
<li>优点：可以避免全局变量的污染</li>
<li>缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露。</li>
</ul>
<h2 id="%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%97%AD%E5%8C%85" tabindex="-1"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%97%AD%E5%8C%85">如何优化闭包</a></h2>
<ul>
<li>通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）</li>
</ul>
<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFun</span>(<span class="hljs-params">outerArg</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这里是内部匿名函数&#x27;</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;可以访问包含函数的变量&#x27;</span>, outerArg);
  };
}
<span class="hljs-keyword">var</span> create = <span class="hljs-title function_">outerFun</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);
<span class="hljs-comment">// 创建一个函数，是 outerFun 中返回的匿名函数create();</span>
<span class="hljs-comment">// 调用函数，是调用匿名函数create = null;</span>
<span class="hljs-comment">// 释放对匿名函数的引用</span>
</code></pre>
<ul>
<li>如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题。</li>
<li>利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁。</li>
</ul>
<h1 id="%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" tabindex="-1"><a class="header-anchor" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">垃圾回收</a></h1>
<ul>
<li>现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数</li>
</ul>
<h2 id="%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88%E4%B8%BB%E6%B5%81%EF%BC%89" tabindex="-1"><a class="header-anchor" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88%E4%B8%BB%E6%B5%81%EF%BC%89">标记清除（主流）</a></h2>
<ul>
<li>垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记</li>
<li>因为只要上下文中的代码在运行，就有可能用到它们</li>
<li>从根部出发将能触及到的对象的标记清除</li>
<li>那些还存在标记的变量被视为准备删除的变量</li>
<li>销毁那些带标记的值</li>
</ul>
<h2 id="%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" tabindex="-1"><a class="header-anchor" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">引用计数</a></h2>
<ul>
<li>如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收。</li>
<li>跟踪记录每个值被引用的次数</li>
<li>当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1</li>
<li>相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1</li>
<li>当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来</li>
<li>缺点：循环引用会造成对象无法被回收</li>
</ul>
<h2 id="%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" tabindex="-1"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">如何避免垃圾回收</a></h2>
<ul>
<li>对象尽量复用</li>
<li>数组优化： 将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</li>
</ul>
<h2 id="%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C" tabindex="-1"><a class="header-anchor" href="#%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C">引起内存泄漏的操作</a></h2>
<ul>
<li>全局变量</li>
<li>闭包</li>
<li>dom 清除，事件绑定未清除</li>
<li>未清除的计时器</li>
<li>setTimeout 的第一个参数使用字符串而非函数</li>
<li>引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环</li>
<li>console.log 打印了太大的变量</li>
</ul>
<h2 id="%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98" tabindex="-1"><a class="header-anchor" href="#%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98">手动释放内存</a></h2>
<p>fn = null【null：空指针对象】</p>
<h1 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D" tabindex="-1"><a class="header-anchor" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝、浅拷贝</a></h1>
<ul>
<li>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign 或 展开运算符</li>
<li>深拷贝：
<ul>
<li>JavaScript 包含基本类型（如字符串、数字、布尔）和引用类型（如数组、对象）</li>
<li>基本数据类型按值访问、引用类型的值按照引用访问</li>
<li>直接复制引用类型的值，实际上是一个内存地址的指针，修改新的变量，原变量也会被修改</li>
</ul>
</li>
<li>手写深拷贝：</li>
</ul>
<pre><code class="language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-comment">// 1、判断是否是简单数据类型，</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj == <span class="hljs-string">&#x27;object&#x27;</span>) {
    <span class="hljs-comment">// 2、复杂数据类型</span>
    <span class="hljs-keyword">var</span> result = obj.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Array</span> ? [] : {};
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) {
      result[i] = <span class="hljs-keyword">typeof</span> obj[i] == <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">deepCopy</span>(obj[i]) : obj[i];
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 简单数据类型 直接赋值</span>
    <span class="hljs-keyword">var</span> result = obj;
  }
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h1 id="%E6%8F%8F%E8%BF%B0-promise" tabindex="-1"><a class="header-anchor" href="#%E6%8F%8F%E8%BF%B0-promise">描述 Promise</a></h1>
<ul>
<li>用来解决回调地狱</li>
<li>实例化一个 Promise 需要传入一个函数，业务代码在这个函数中执行，这个函数往往接收两个参数 resolve 和 reject</li>
<li>在函数中业务代码执行成功了，调用 resolve 函数，可以把 Promise 的状态变为已成功，通过参数把成功的结果传递出去，能在这个 Promise 对象的 then 方法中获取，then 方法可以链式调用多次，then 方法接受一个函数作为参数，这个函数的参数就是 resolve 传递出来的结果</li>
<li>在函数中业务代码执行失败了，调用 reject 函数，可以把 Promise 的状态变为已失败，通过参数把失败的结果传递出去，能在这个 Promise 对象的 catch 方法中获取，catch 方法和 then 方法用法一致，也是接受一个函数作为参数</li>
<li>无论结果如何都会走 finally 方法</li>
<li>Promise.all 接受一个数组作为参数，都是 Promise 实例，调用 Promise.all 的时候，这些实例会一起开始执行，返回一个结果数组，只有全部实例的状态是已完成，结果的状态才会是已完成，只要有一个失败，结果就是失败</li>
<li>Promise.race 接受一个数组作为参数，都是 Promise 实例，返回一个结果数组，调用 Promise.race 的时候，传进去的实例是竞赛关系，哪个结果获得的快，就返回那个结果</li>
</ul>
<h1 id="%E6%89%8B%E5%86%99-promise" tabindex="-1"><a class="header-anchor" href="#%E6%89%8B%E5%86%99-promise">手写 Promise</a></h1>
<pre><code class="language-jsx"><span class="hljs-comment">// 在这里用Symbol定义三种状态，防止外部改变状态</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Pending</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;Pending&#x27;</span>);
<span class="hljs-comment">// 进行中</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Fulfilled</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;Fulfilled&#x27;</span>);
<span class="hljs-comment">// 已成功</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Rejected</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;Rejected&#x27;</span>);
<span class="hljs-comment">// 已失败</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleValue</span> = (<span class="hljs-params">promise, x, resolve, reject</span>) =&gt; {
  <span class="hljs-comment">// 循环引用，自己等待自己完成，会出错，用reject传递出错误原因</span>
  <span class="hljs-keyword">if</span> (promise === x) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;检测到Promise的链式循环引用&#x27;</span>));
  }
  <span class="hljs-comment">// 确保递归解析中只传递出去一次值</span>
  <span class="hljs-keyword">let</span> once = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 防止重复去读取x.then</span>
      <span class="hljs-keyword">let</span> then = x.<span class="hljs-property">then</span>;
      <span class="hljs-comment">// 判断x是不是Promise</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-comment">//调用then实例方法处理Promise执行结果</span>
        then.<span class="hljs-title function_">call</span>(
          x,
          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (once) <span class="hljs-keyword">return</span>;
            once = <span class="hljs-literal">true</span>;
            <span class="hljs-comment">// 防止Promise中Promise执行成功后又传递一个Promise过来，</span>
            <span class="hljs-comment">// 要做递归解析。</span>
            <span class="hljs-title function_">handleValue</span>(promise, y, resolve, reject);
          },
          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> {
            <span class="hljs-keyword">if</span> (once) <span class="hljs-keyword">return</span>;
            once = <span class="hljs-literal">true</span>;
            <span class="hljs-title function_">reject</span>(r);
          }
        );
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果x是个普通对象，直接调用resolve(x)</span>
        <span class="hljs-title function_">resolve</span>(x);
      }
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">if</span> (once) <span class="hljs-keyword">return</span>;
      once = <span class="hljs-literal">true</span>;
      <span class="hljs-title function_">reject</span>(err);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 如果x是个原始值，直接调用resolve(x)</span>
    <span class="hljs-title function_">resolve</span>(x);
  }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">Pending</span>;
    <span class="hljs-comment">//存储 Promise 的状态</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span>;
    <span class="hljs-comment">//存储executor函数中业务代码执行成功的结果</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span>;
    <span class="hljs-comment">//存储executor函数中业务代码执行失败的原因</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilled</span> = [];
    <span class="hljs-comment">//executor函数中业务代码执行成功回调函数的集合</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejected</span> = [];
    <span class="hljs-comment">//executor函数中业务代码执行失败回调函数的集合</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; {
      <span class="hljs-comment">// 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">Pending</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">Fulfilled</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value;
        <span class="hljs-comment">// 依次调用成功回调函数</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilled</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());
      }
    };
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">value</span>) =&gt; {
      <span class="hljs-comment">// 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">Pending</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-title class_">Rejected</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = value;
        <span class="hljs-comment">// 依次调用失败回调函数</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejected</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());
      }
    };
    <span class="hljs-keyword">try</span> {
      <span class="hljs-title function_">executor</span>(resolve, reject);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-title function_">reject</span>(error);
    }
  }
  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) {
    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> v;
    onRejected =
      <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>
        ? onRejected
        : <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
            <span class="hljs-keyword">throw</span> err;
          };
    <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">Fulfilled</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
            <span class="hljs-title function_">handleValue</span>(promise, x, resolve, reject);
          } <span class="hljs-keyword">catch</span> (error) {
            <span class="hljs-title function_">reject</span>(error);
          }
        }, <span class="hljs-number">0</span>);
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">Rejected</span>) {
        <span class="hljs-keyword">if</span> (onRejected &amp;&amp; <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">try</span> {
              <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);
              <span class="hljs-title function_">handleValue</span>(promise, x, resolve, reject);
            } <span class="hljs-keyword">catch</span> (error) {
              <span class="hljs-title function_">reject</span>(error);
            }
          }, <span class="hljs-number">0</span>);
        }
      }
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">Pending</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilled</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> {
          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">try</span> {
              <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
              <span class="hljs-title function_">handleValue</span>(promise, x, resolve, reject);
            } <span class="hljs-keyword">catch</span> (error) {
              <span class="hljs-title function_">reject</span>(error);
            }
          }, <span class="hljs-number">0</span>);
        });
        <span class="hljs-keyword">if</span> (onRejected &amp;&amp; <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejected</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
              <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>);
                <span class="hljs-title function_">handleValue</span>(promise, x, resolve, reject);
              } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-title function_">reject</span>(error);
              }
            }, <span class="hljs-number">0</span>);
          });
        }
      }
    });
    <span class="hljs-keyword">return</span> promise;
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">param</span>) {
    <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) {
      <span class="hljs-keyword">return</span> param;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (param &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(param) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> param.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          param.<span class="hljs-title function_">then</span>(resolve, reject);
        }, <span class="hljs-number">0</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">resolve</span>(param);
      }
    });
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">param</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-title function_">reject</span>(param);
    });
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) {
    <span class="hljs-comment">//将参数promises转为一个真正的数组</span>
    promises = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(promises);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> length = promises.<span class="hljs-property">length</span>;
      <span class="hljs-keyword">let</span> value = [];
      <span class="hljs-keyword">if</span> (length) {
        value = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, { <span class="hljs-attr">length</span>: length });
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
          <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(
            <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
              value[i] = res;
              <span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> == length) {
                <span class="hljs-title function_">resolve</span>(value);
              }
            },
            <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
              <span class="hljs-title function_">reject</span>(err);
              <span class="hljs-keyword">return</span>;
            }
          );
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">resolve</span>(value);
      }
    });
  }
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promises</span>) {
    <span class="hljs-comment">//将参数promises转为一个真正的数组</span>
    promises = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(promises);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> length = promises.<span class="hljs-property">length</span>;
      <span class="hljs-keyword">if</span> (length) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
          <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(
            <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
              <span class="hljs-title function_">resolve</span>(res);
              <span class="hljs-keyword">return</span>;
            },
            <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
              <span class="hljs-title function_">reject</span>(err);
              <span class="hljs-keyword">return</span>;
            }
          );
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>;
      }
    });
  }
}
</code></pre>
<h1 id="%E6%8F%8F%E8%BF%B0-async%2Fawait" tabindex="-1"><a class="header-anchor" href="#%E6%8F%8F%E8%BF%B0-async%2Fawait">描述 async/await</a></h1>
<ul>
<li>async 用来声明函数，告诉解释器这是一个异步函数，只有 async 声明的函数里面才能用 await</li>
<li>await 用来等待一个 promise 执行结束，可以返回 promise 对象 resolve 出来的结果</li>
<li>如果 await 等待的这个 Promise 对象出错或者结果为 reject，可以通过 try catch 捕获到错误</li>
</ul>
<h1 id="%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95" tabindex="-1"><a class="header-anchor" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95">数组的遍历迭代方法</a></h1>
<ul>
<li>for in
以任意顺序遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行。</li>
</ul>
<blockquote>
<p>如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性。</p>
</blockquote>
<ul>
<li>for of
ES6 新增，用来替代 for in 和 forEach，可以遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构。</li>
<li>forEach
遍历数组中的每一项，没有返回值，对原数组没有影响，注意：在 forEach 中用 return 不会返回，break 不会跳出，函数会继续执行。</li>
<li>map
返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li>
<li>filter
返回通过过滤的元素，不改变原来的数组。</li>
<li>some
用于检测数组中的某个元素是否满足指定条件,返回 boolean 值，不改变原数组。</li>
<li>every
用于检测数组中的所有元素是否都符合指定条件，返回 boolean 值，不改变原数组。</li>
<li>reduce
接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li>
<li>reduceRight
和 reduce() 功能是一样的，它是从数组的末尾处向前开始计算。</li>
<li>find 返回通过测试（函数内判断）的数组的第一个元素的值。</li>
</ul>
<p>forEach、for in、for of 三者区别：</p>
<ul>
<li>forEach 更多的用来遍历数组</li>
<li>for in 一般常用来遍历对象或 json</li>
<li>for of 数组对象都可以遍历，遍历对象需要通过和 Object.keys()</li>
<li>for in 循环出的是 key，for of 循环出的是 value</li>
</ul>
<h1 id="apply%E3%80%81call%E3%80%81bind" tabindex="-1"><a class="header-anchor" href="#apply%E3%80%81call%E3%80%81bind">apply、call、bind</a></h1>
<ul>
<li>都是用来改变函数 this 的指向</li>
</ul>
<p>区别：</p>
<ul>
<li>apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组</li>
<li>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用，bind 与 apply/call 一样都能改变函数 this 指向，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数，你需要再次调用此函数才能达到最终执行</li>
</ul>
<h2 id="%E6%89%8B%E5%86%99" tabindex="-1"><a class="header-anchor" href="#%E6%89%8B%E5%86%99">手写</a></h2>
<pre><code class="language-javascript"><span class="hljs-comment">// call</span>
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Type error&#x27;</span>);
  }

  <span class="hljs-comment">// 判断 context 是否传入，如果没有传就设置为 window</span>
  context = context || <span class="hljs-variable language_">window</span>;

  <span class="hljs-comment">// 使用 Symbol 来保证属性唯一</span>
  <span class="hljs-comment">// 保证不会重写用户自己原来定义在 context 中的同名属性</span>
  <span class="hljs-keyword">const</span> fnSymbol = <span class="hljs-title class_">Symbol</span>();

  <span class="hljs-comment">// 将被调用的方法设置为 context 的属性</span>
  <span class="hljs-comment">// this 即为我们要调用的方法</span>
  context[fnSymbol] = <span class="hljs-variable language_">this</span>;

  <span class="hljs-comment">// 将执行结果返回</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> context[fnSymbol](...args);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 最后删除手动增加的属性方法</span>
    <span class="hljs-keyword">delete</span> context[fnSymbol];
  }
};

<span class="hljs-keyword">var</span> foo = {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
}

bar.<span class="hljs-title function_">call</span>(foo); <span class="hljs-comment">// 1</span>
bar.<span class="hljs-title function_">myCall</span>(foo); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// apply</span>
<span class="hljs-comment">// 与 call 相比仅获取参数方式不同</span>

<span class="hljs-comment">// bind</span>
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Type error&#x27;</span>);
  }

  <span class="hljs-keyword">const</span> fn = <span class="hljs-variable language_">this</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(
      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,
      <span class="hljs-comment">// 当前的这个 arguments 是指 Fn 的参数</span>
      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)
    );
  };
};
</code></pre>
<h1 id="%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92" tabindex="-1"><a class="header-anchor" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92">尾调用和尾递归</a></h1>
<ul>
<li>指某个函数的最后一步是调用另一个函数</li>
<li>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生栈溢出错误</li>
<li>但对于尾递归来说，由于只存在一个调用记录，所以不会发生栈溢出</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> num * <span class="hljs-title function_">factorial</span>(num - <span class="hljs-number">1</span>);
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">10</span>));
</code></pre>
<h1 id="%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F" tabindex="-1"><a class="header-anchor" href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域和动态作用域</a></h1>
<ul>
<li>JavaScript 采用词法作用域，也就是静态作用域</li>
<li>函数的作用域在函数定义的时候就决定了</li>
<li>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;
  <span class="hljs-title function_">foo</span>();
}

<span class="hljs-title function_">bar</span>();

<span class="hljs-comment">// 1</span>
</code></pre>
<h1 id="%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" tabindex="-1"><a class="header-anchor" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a></h1>
<ul>
<li>参数如果是基本类型是按值传递，如果是引用类型按共享传递</li>
<li>但是当值是一个复杂的数据结构的时候，拷贝就会产生性能上的问题</li>
</ul>
<h2 id="%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92" tabindex="-1"><a class="header-anchor" href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92">按值传递</a></h2>
<ul>
<li>把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样</li>
</ul>
<h2 id="%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92" tabindex="-1"><a class="header-anchor" href="#%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92">共享传递</a></h2>
<ul>
<li>在传递对象的时候，传递对象的引用的副本</li>
<li>假设 arg 是一个对象参数，修改 arg.value，可以通过引用找到原值，但是直接修改 arg，并不会修改原值</li>
</ul>
<h1 id="arguments" tabindex="-1"><a class="header-anchor" href="#arguments">arguments</a></h1>
<ul>
<li>是一个类数组对象，存储传入函数的全部参数。（类数组对象：属性是 0 开始的下标，并且有 length 属性，但没有数组独有的方法）</li>
<li>callee 属性：当前函数的引用</li>
<li>妙用：递归、参数累加</li>
</ul>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88-es6-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-arguments.callee()" tabindex="-1"><a class="header-anchor" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-es6-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-arguments.callee()">为什么 ES6 不推荐使用 arguments.callee()</a></h2>
<ul>
<li>访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响浏览器的性能，还会影响闭包。</li>
<li>当一个函数必须调用自身的时候，假如它是函数表达式则给它命名，或者使用函数声明，避免使用 callee</li>
</ul>

      
        <div class="btt withToc" id="btt"></div>
      
    </div>
    
    <div class="table-of-contents"><ul><li title=js 数据类型><a href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" data-anchor="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">js 数据类型</a><ul><li title=数据类型的判断><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD" data-anchor="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD">数据类型的判断</a></li><li title=如何判断变量是否为数组><a href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84" data-anchor="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84">如何判断变量是否为数组</a></li><li title=null 和 undefined 区别><a href="#null-%E5%92%8C-undefined-%E5%8C%BA%E5%88%AB" data-anchor="#null-%E5%92%8C-undefined-%E5%8C%BA%E5%88%AB">null 和 undefined 区别</a></li><li title=为什么会出现精度丢失><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1" data-anchor="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1">为什么会出现精度丢失</a></li></ul></li><li title=Array 的一些不好记的方法><a href="#array-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95" data-anchor="#array-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95">Array 的一些不好记的方法</a></li><li title=String 的一些不好记的方法><a href="#string-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95" data-anchor="#string-%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A5%BD%E8%AE%B0%E7%9A%84%E6%96%B9%E6%B3%95">String 的一些不好记的方法</a></li><li title=delete 机制><a href="#delete-%E6%9C%BA%E5%88%B6" data-anchor="#delete-%E6%9C%BA%E5%88%B6">delete 机制</a></li><li title=0.1 + 0.2 为什么不等于 0.3><a href="#0.1-%2B-0.2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E-0.3" data-anchor="#0.1-%2B-0.2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%AD%89%E4%BA%8E-0.3">0.1 + 0.2 为什么不等于 0.3</a></li><li title=es6 新特性><a href="#es6-%E6%96%B0%E7%89%B9%E6%80%A7" data-anchor="#es6-%E6%96%B0%E7%89%B9%E6%80%A7">es6 新特性</a></li><li title=var let const><a href="#var-let-const" data-anchor="#var-let-const">var let const</a></li><li title=柯里化><a href="#%E6%9F%AF%E9%87%8C%E5%8C%96" data-anchor="#%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a><ul><li title=意义><a href="#%E6%84%8F%E4%B9%89" data-anchor="#%E6%84%8F%E4%B9%89">意义</a></li><li title=缺点><a href="#%E7%BC%BA%E7%82%B9" data-anchor="#%E7%BC%BA%E7%82%B9">缺点</a></li></ul></li><li title=闭包><a href="#%E9%97%AD%E5%8C%85" data-anchor="#%E9%97%AD%E5%8C%85">闭包</a><ul><li title=如何优化闭包><a href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%97%AD%E5%8C%85" data-anchor="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%97%AD%E5%8C%85">如何优化闭包</a></li></ul></li><li title=垃圾回收><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" data-anchor="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">垃圾回收</a><ul><li title=标记清除（主流）><a href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88%E4%B8%BB%E6%B5%81%EF%BC%89" data-anchor="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88%E4%B8%BB%E6%B5%81%EF%BC%89">标记清除（主流）</a></li><li title=引用计数><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0" data-anchor="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">引用计数</a></li><li title=如何避免垃圾回收><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" data-anchor="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6">如何避免垃圾回收</a></li><li title=引起内存泄漏的操作><a href="#%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C" data-anchor="#%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C">引起内存泄漏的操作</a></li><li title=手动释放内存><a href="#%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98" data-anchor="#%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98">手动释放内存</a></li></ul></li><li title=深拷贝、浅拷贝><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D" data-anchor="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝、浅拷贝</a></li><li title=描述 Promise><a href="#%E6%8F%8F%E8%BF%B0-promise" data-anchor="#%E6%8F%8F%E8%BF%B0-promise">描述 Promise</a></li><li title=手写 Promise><a href="#%E6%89%8B%E5%86%99-promise" data-anchor="#%E6%89%8B%E5%86%99-promise">手写 Promise</a></li><li title=描述 async/await><a href="#%E6%8F%8F%E8%BF%B0-async%2Fawait" data-anchor="#%E6%8F%8F%E8%BF%B0-async%2Fawait">描述 async/await</a></li><li title=数组的遍历迭代方法><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95" data-anchor="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95">数组的遍历迭代方法</a></li><li title=apply、call、bind><a href="#apply%E3%80%81call%E3%80%81bind" data-anchor="#apply%E3%80%81call%E3%80%81bind">apply、call、bind</a><ul><li title=手写><a href="#%E6%89%8B%E5%86%99" data-anchor="#%E6%89%8B%E5%86%99">手写</a></li></ul></li><li title=尾调用和尾递归><a href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92" data-anchor="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92">尾调用和尾递归</a></li><li title=词法作用域和动态作用域><a href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F" data-anchor="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F">词法作用域和动态作用域</a></li><li title=参数传递><a href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" data-anchor="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">参数传递</a><ul><li title=按值传递><a href="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92" data-anchor="#%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92">按值传递</a></li><li title=共享传递><a href="#%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92" data-anchor="#%E5%85%B1%E4%BA%AB%E4%BC%A0%E9%80%92">共享传递</a></li></ul></li><li title=arguments><a href="#arguments" data-anchor="#arguments">arguments</a><ul><li title=为什么 ES6 不推荐使用 arguments.callee()><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-es6-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-arguments.callee()" data-anchor="#%E4%B8%BA%E4%BB%80%E4%B9%88-es6-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-arguments.callee()">为什么 ES6 不推荐使用 arguments.callee()</a></li></ul></li></ul></div>
    

    <!-- bottom scripts -->
    <script src="//cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
    <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
    <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
    <script src="/my-book/resource/script.js"></script>
  </body>
</html>
