<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - 浏览器</title>

  <!-- styles -->
  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight.default.min.css" />
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <!-- scripts -->
  <script src="/my-book/resource/lib/jquery.min.js"></script>

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：4/11/2022, 9:47:32 AM -->

  <script>
    window.root = '/my-book';

    // 提前把搜索数据库载入内存
    fetch(`${window.root}/dir_tree.json`)
      .then(function (res) {
        return res.json();
      })
      .then(function (res) {
        window.__doc_builder_dirTree__ = res;
      });
  </script>
</head>

  <body>
    <ul class="menu expand" id="menu">
      <div class="search_bar" id="search_bar">
        <input type="text" placeholder="search..." />
        <img
          class="clear"
          id="clear"
          src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/circle-xmark.svg"
          alt=""
        />
        <div class="search_result" id="search_result"></div>
      </div>
      
            <ul class="parent open">
              <li id="工作沉淀" class="dir" title="工作沉淀">
                <span>工作沉淀</span>
                <div class="triangle"></div>
              </li>
              
          <li id="工作沉淀/Fiddler 真机调试微信 h5.md" class="children" title="Fiddler 真机调试微信 h5">
            <a href="/my-book/工作沉淀/Fiddler 真机调试微信 h5.html">Fiddler 真机调试微信 h5</a>
          </li>
        
          <li id="工作沉淀/GitFlow 学习笔记.md" class="children" title="GitFlow 学习笔记">
            <a href="/my-book/工作沉淀/GitFlow 学习笔记.html">GitFlow 学习笔记</a>
          </li>
        
          <li id="工作沉淀/Nginx 学习笔记.md" class="children" title="Nginx 学习笔记">
            <a href="/my-book/工作沉淀/Nginx 学习笔记.html">Nginx 学习笔记</a>
          </li>
        
          <li id="工作沉淀/动态校验企微应用可信域名.md" class="children" title="动态校验企微应用可信域名">
            <a href="/my-book/工作沉淀/动态校验企微应用可信域名.html">动态校验企微应用可信域名</a>
          </li>
        
          <li id="工作沉淀/工作中遇到问题汇总.md" class="children" title="工作中遇到问题汇总">
            <a href="/my-book/工作沉淀/工作中遇到问题汇总.html">工作中遇到问题汇总</a>
          </li>
        
          <li id="工作沉淀/我的最佳实践.md" class="children" title="我的最佳实践">
            <a href="/my-book/工作沉淀/我的最佳实践.html">我的最佳实践</a>
          </li>
        
          <li id="工作沉淀/敏捷迭代.md" class="children" title="敏捷迭代">
            <a href="/my-book/工作沉淀/敏捷迭代.html">敏捷迭代</a>
          </li>
        
          <li id="工作沉淀/登录方案.md" class="children" title="登录方案">
            <a href="/my-book/工作沉淀/登录方案.html">登录方案</a>
          </li>
        
          <li id="工作沉淀/设计稿多端适配方案.md" class="children" title="设计稿多端适配方案">
            <a href="/my-book/工作沉淀/设计稿多端适配方案.html">设计稿多端适配方案</a>
          </li>
        
            </ul>
          
            <ul class="parent open">
              <li id="前端技术" class="dir" title="前端技术">
                <span>前端技术</span>
                <div class="triangle"></div>
              </li>
              
            <ul class="parent open">
              <li id="前端技术/浏览器" class="dir" title="浏览器">
                <span>浏览器</span>
                <div class="triangle"></div>
              </li>
              
          <li id="前端技术/浏览器/事件循环.md" class="children" title="事件循环">
            <a href="/my-book/前端技术/浏览器/事件循环.html">事件循环</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器.md" class="children" title="浏览器">
            <a href="/my-book/前端技术/浏览器/浏览器.html">浏览器</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器架构.md" class="children" title="浏览器架构">
            <a href="/my-book/前端技术/浏览器/浏览器架构.html">浏览器架构</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器缓存.md" class="children" title="浏览器缓存">
            <a href="/my-book/前端技术/浏览器/浏览器缓存.html">浏览器缓存</a>
          </li>
        
            </ul>
          
          <li id="前端技术/AST抽象语法树.md" class="children" title="AST抽象语法树">
            <a href="/my-book/前端技术/AST抽象语法树.html">AST抽象语法树</a>
          </li>
        
          <li id="前端技术/Babel.md" class="children" title="Babel">
            <a href="/my-book/前端技术/Babel.html">Babel</a>
          </li>
        
          <li id="前端技术/Browserslist.md" class="children" title="Browserslist">
            <a href="/my-book/前端技术/Browserslist.html">Browserslist</a>
          </li>
        
          <li id="前端技术/CSS.md" class="children" title="CSS">
            <a href="/my-book/前端技术/CSS.html">CSS</a>
          </li>
        
          <li id="前端技术/Fiber.md" class="children" title="Fiber">
            <a href="/my-book/前端技术/Fiber.html">Fiber</a>
          </li>
        
          <li id="前端技术/Hooks.md" class="children" title="Hooks">
            <a href="/my-book/前端技术/Hooks.html">Hooks</a>
          </li>
        
          <li id="前端技术/Nodejs.md" class="children" title="Nodejs">
            <a href="/my-book/前端技术/Nodejs.html">Nodejs</a>
          </li>
        
          <li id="前端技术/React.md" class="children" title="React">
            <a href="/my-book/前端技术/React.html">React</a>
          </li>
        
          <li id="前端技术/Redux.md" class="children" title="Redux">
            <a href="/my-book/前端技术/Redux.html">Redux</a>
          </li>
        
          <li id="前端技术/Typescript.md" class="children" title="Typescript">
            <a href="/my-book/前端技术/Typescript.html">Typescript</a>
          </li>
        
          <li id="前端技术/Vue.md" class="children" title="Vue">
            <a href="/my-book/前端技术/Vue.html">Vue</a>
          </li>
        
          <li id="前端技术/Webpack.md" class="children" title="Webpack">
            <a href="/my-book/前端技术/Webpack.html">Webpack</a>
          </li>
        
          <li id="前端技术/npm.md" class="children" title="npm">
            <a href="/my-book/前端技术/npm.html">npm</a>
          </li>
        
          <li id="前端技术/函数式编程.md" class="children" title="函数式编程">
            <a href="/my-book/前端技术/函数式编程.html">函数式编程</a>
          </li>
        
          <li id="前端技术/原型链和继承.md" class="children" title="原型链和继承">
            <a href="/my-book/前端技术/原型链和继承.html">原型链和继承</a>
          </li>
        
          <li id="前端技术/微信开发.md" class="children" title="微信开发">
            <a href="/my-book/前端技术/微信开发.html">微信开发</a>
          </li>
        
          <li id="前端技术/微前端.md" class="children" title="微前端">
            <a href="/my-book/前端技术/微前端.html">微前端</a>
          </li>
        
          <li id="前端技术/手写题.md" class="children" title="手写题">
            <a href="/my-book/前端技术/手写题.html">手写题</a>
          </li>
        
          <li id="前端技术/模块.md" class="children" title="模块">
            <a href="/my-book/前端技术/模块.html">模块</a>
          </li>
        
          <li id="前端技术/虚拟列表.md" class="children" title="虚拟列表">
            <a href="/my-book/前端技术/虚拟列表.html">虚拟列表</a>
          </li>
        
          <li id="前端技术/设计模式.md" class="children" title="设计模式">
            <a href="/my-book/前端技术/设计模式.html">设计模式</a>
          </li>
        
          <li id="前端技术/语言基础.md" class="children" title="语言基础">
            <a href="/my-book/前端技术/语言基础.html">语言基础</a>
          </li>
        
            </ul>
          
          <li id="其他.md" class="children" title="其他">
            <a href="/my-book/其他.html">其他</a>
          </li>
        
          <li id="网络.md" class="children" title="网络">
            <a href="/my-book/网络.html">网络</a>
          </li>
        
      <li id="index.md" class="children about">
        <a href="/my-book/">关于</a>
      </li>
    </ul>
    <div class="drager" id="drager">
      <div class="switcher" id="switcher" title="展开或收起"></div>
    </div>
    <div class="mobile_menu" id="mobile_menu">
      <img src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/bars.svg" alt="" />
    </div>
    <div class="content markdown-body">
      <h1 id="%E8%BE%93%E5%85%A5-url-%E5%88%B0%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B" tabindex="-1"><a class="header-anchor" href="#%E8%BE%93%E5%85%A5-url-%E5%88%B0%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">输入 URL 到网页渲染过程</a></h1>
<ul>
<li>
<p>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求</p>
</li>
<li>
<p>查询资源缓存，强缓存、协商缓存</p>
</li>
<li>
<p>DNS 解析</p>
<p>为了让我们更快的拿到想要的 IP，DNS 广泛使用了缓存技术：</p>
<ul>
<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录</li>
<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会去操作系统中找</li>
<li>路由缓存：路由器也有 DNS 缓存</li>
<li>ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求</li>
<li>根服务器：ISP 的 DNS 服务器找不到之后，就要向根服务器发出请求，进行递归查询</li>
</ul>
<p>CDN：DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容
dns-prefetch：DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。</p>
</li>
<li>
<p>获得请求 url 对应的 ip 地址，根据解析到的 IP 地址和端口号发起请求</p>
</li>
<li>
<p>建立 TCP 连接：tcp 协议通过三次握手与服务器建立连接</p>
</li>
<li>
<p>服务器（nginx、apache 等）处理请求并返回 HTTP 报文，浏览器收到开始渲染</p>
</li>
<li>
<p>渲染过程</p>
<ul>
<li>
<p>参考：<a href="https://juejin.cn/post/6844903779700047885" target="_blank">https://juejin.cn/post/6844903779700047885</a></p>
</li>
<li>
<p>浏览器根据深度遍历的方式把 html 节点遍历成 dom 树</p>
</li>
<li>
<p>将 css 解析成 CSS DOM 树</p>
</li>
<li>
<p>将 dom 树和 CSS DOM 树构造成渲染树</p>
<blockquote>
<p>补充：构造渲染树的过程，从 DOM 树的根节点开始遍历每个可见的节点，对于每个可见的节点，找到 CSS 树中的对应的规则，并且应用他们，根据每个可见的节点及其对应的样式，组合生成渲染树</p>
</blockquote>
<blockquote>
<p>当文档加载过程中遇到 js 文件，html 文档会挂起渲染的线程，要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，这意味着在 JS 执行完成前，后续资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的</p>
</blockquote>
</li>
<li>
<p>根据得到的渲染树，计算所有节点在屏幕中的位置，进行布局（回流）</p>
</li>
<li>
<p>遍历渲染树并调用硬件的 API 绘制所有节点（重绘）</p>
</li>
</ul>
</li>
<li>
<p>断开 TCP 连接：TCP 四次挥手</p>
</li>
</ul>
<h1 id="web-worker" tabindex="-1"><a class="header-anchor" href="#web-worker">Web Worker</a></h1>
<p>现代浏览器为 JavaScript 创造的 多线程环境。可以新建并将部分任务分配到 worker 线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。 基本用法：</p>
<pre><code class="language-jsx"><span class="hljs-comment">// 创建worker</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;work.js&#x27;</span>);
<span class="hljs-comment">// 向 worker 线程推送消息</span>
worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>);
<span class="hljs-comment">// 监听 worker 线程发送过来的消息</span>
worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message &#x27;</span> + event.<span class="hljs-property">data</span>);
};
</code></pre>
<p>限制:</p>
<ul>
<li>同源限制</li>
<li>无法使用 document / window / alert / confirm</li>
<li>无法加载本地资源</li>
</ul>
<h1 id="xss%E3%80%81csrf-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%92%8C%E9%98%B2%E5%BE%A1" tabindex="-1"><a class="header-anchor" href="#xss%E3%80%81csrf-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%92%8C%E9%98%B2%E5%BE%A1">XSS、CSRF 攻击原理和防御</a></h1>
<p>XSS：</p>
<ul>
<li>通过利用网页开发时留下的漏洞，比如评论框，注入恶意 js 到网页</li>
<li>防御 xss：过滤 html 标签，转义页面上的输入内容和输出内容，过滤 on 开头属性，cookie 设置 httpOnly</li>
</ul>
<p>CSRF：</p>
<ul>
<li>设法伪造带有正确 Cookie 的 HTTP 请求</li>
<li>通常由于服务端没有对请求头做严格过滤引起的</li>
<li>CSRF 防御：
<ul>
<li>不要使用 GET 请求来修改数据</li>
<li>不要被第三方网站访问到用户的 cookie</li>
<li>Referer 头检测，设置白名单</li>
<li>接口不要被第三方网站请求、用 token 请求校验</li>
</ul>
</li>
</ul>
<h2 id="samesite" tabindex="-1"><a class="header-anchor" href="#samesite">SameSite</a></h2>
<ul>
<li>是 cookie 的一个属性，用来防止 CSRF 攻击和用户追踪，用来限制第三方 Cookie</li>
<li>Strict<br>
完全禁止第三方 Cookie，可能造成不好的用户体验，比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态</li>
<li>Lax（默认值）
大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外</li>
<li>None</li>
<li>网站可以选择显式关闭 SameSite 属性，将其设为 None。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</li>
</ul>
<h1 id="dom-api" tabindex="-1"><a class="header-anchor" href="#dom-api">DOM api</a></h1>
<h2 id="%E5%88%9B%E5%BB%BA%E6%96%B0%E8%8A%82%E7%82%B9" tabindex="-1"><a class="header-anchor" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%8A%82%E7%82%B9">创建新节点</a></h2>
<ul>
<li>createDocumentFragment() //创建一个 DOM 片段</li>
<li>createElement() //创建一个具体的元素</li>
<li>createTextNode() //创建一个文本节点</li>
</ul>
<h2 id="%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E6%9B%BF%E6%8D%A2%E3%80%81%E6%8F%92%E5%85%A5" tabindex="-1"><a class="header-anchor" href="#%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E6%9B%BF%E6%8D%A2%E3%80%81%E6%8F%92%E5%85%A5">添加、移除、替换、插入</a></h2>
<ul>
<li>appendChild() //添加</li>
<li>removeChild() //移除</li>
<li>replaceChild() //替换</li>
<li>insertBefore() //插入</li>
</ul>
<h2 id="%E6%9F%A5%E6%89%BE" tabindex="-1"><a class="header-anchor" href="#%E6%9F%A5%E6%89%BE">查找</a></h2>
<ul>
<li>getElementsByTagName()</li>
<li>getElementsByName()</li>
<li>getElementById()</li>
<li>document.querySelector()</li>
<li>document.querySelectorAll()</li>
</ul>
<h1 id="%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86" tabindex="-1"><a class="header-anchor" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86">前端路由原理</a></h1>
<p>hash 模式：</p>
<ul>
<li>在浏览器中，#号以及#号后面的字符称之为 hash，用 window.location.hash 读取；</li>
<li>hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，修改 hash 不会刷新页面。</li>
<li>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</li>
</ul>
<p>history 模式：</p>
<ul>
<li>history 采用了 HTML5 的新特性 pushState 和 replaceState 可以对浏览器历史记录、html 标题进行修改，以及 popState 事件的监听到状态变更。</li>
<li>history 模式下，前端的 URL 和实际向后端发起请求的 URL 一致。服务端如果缺少对该页面请求的处理，就会返回 404 错误。</li>
<li>需要在服务端增加一个覆盖所有情况的候选资源：比如 URL 匹配不到任何资源时，则返回同一个 index.html 页面，这个页面就是前端应用的入口页面。</li>
</ul>
<p>我个人更推荐用 history 模式，history 模式更利于 seo 优化，url 也比较美观。</p>
<h1 id="%E4%BB%80%E4%B9%88%E6%98%AF-html-%E8%AF%AD%E4%B9%89%E5%8C%96" tabindex="-1"><a class="header-anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF-html-%E8%AF%AD%E4%B9%89%E5%8C%96">什么是 HTML 语义化</a></h1>
<p>HTML5 语义化标签是指：正确的标签包含正确的内容，结构良好，便于阅读，利于 SEO 优化，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签</p>
<h1 id="%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%88spa%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9" tabindex="-1"><a class="header-anchor" href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%88spa%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9">单页应用（SPA）优缺点</a></h1>
<p>优点：</p>
<ul>
<li>内容的改变不需要重新加载整个页面，用户体验好</li>
<li>相对对服务器压力小</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li>
</ul>
<p>缺点：</p>
<ul>
<li>首屏加载慢</li>
<li>前进后退路由需要自己管理，不能使用浏览器的前进后退功能</li>
<li>SEO（搜索优化）难度大</li>
</ul>
<h1 id="%E7%99%BD%E5%B1%8F" tabindex="-1"><a class="header-anchor" href="#%E7%99%BD%E5%B1%8F">白屏</a></h1>
<h2 id="%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98" tabindex="-1"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98">如何解决白屏问题</a></h2>
<p>往 html 中填充内容，比如渲染根元素中间加上“加载中”几个字，让渲染结束前的这段时间有内容可以显示。</p>
<h2 id="%E8%AE%A1%E7%AE%97%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4" tabindex="-1"><a class="header-anchor" href="#%E8%AE%A1%E7%AE%97%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4">计算首屏白屏时间</a></h2>
<p>使用 Performance API：</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>白屏<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
      <span class="hljs-comment">// 不兼容performance.timing 的浏览器，如IE8</span>
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">pageStartTime</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 页面 CSS 资源 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;common.css&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;page.css&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
      <span class="hljs-comment">// 白屏时间结束点</span>
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">firstPaint</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 页面内容 --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>可使用 Performance API 时，
白屏时间 = firstPaint - performance.timing.navigationStart;</p>
<p>不可使用 Performance API 时，
白屏时间 = firstPaint - pageStartTime;</p>
<h1 id="%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" tabindex="-1"><a class="header-anchor" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></h1>
<h2 id="%E4%BB%A3%E7%A0%81" tabindex="-1"><a class="header-anchor" href="#%E4%BB%A3%E7%A0%81">代码</a></h2>
<ul>
<li>缓存 dom 查找结果</li>
<li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数</li>
<li>使用局部变量和字面量比使用数组和对象有更少的读写消耗</li>
<li>原型链不要过深、对象嵌套不要太多</li>
<li>对于多次访问的嵌套对象，应该用变量缓存起来</li>
<li>不要频繁修改 DOM</li>
<li>如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称</li>
</ul>
<pre><code class="language-jsx"><span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.myDiv&#x27;</span>);
el.<span class="hljs-property">style</span>.<span class="hljs-property">borderLeft</span> = <span class="hljs-string">&#x27;1px&#x27;</span>;
el.<span class="hljs-property">style</span>.<span class="hljs-property">borderRight</span> = <span class="hljs-string">&#x27;2px&#x27;</span>;
el.<span class="hljs-property">style</span>.<span class="hljs-property">padding</span> = <span class="hljs-string">&#x27;5px&#x27;</span>;
<span class="hljs-comment">// 可以使用如下语句代替</span>
<span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.myDiv&#x27;</span>);
el.<span class="hljs-property">style</span>.<span class="hljs-property">cssText</span> += <span class="hljs-string">&#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;</span>;
<span class="hljs-comment">// cssText会覆盖已存在的样式，所以使用 +=</span>
</code></pre>
<ul>
<li>使用事件委托</li>
<li>如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快</li>
<li>CSS 能做的事情，尽量不用 JS 来做</li>
<li>避免 css 表达式比如 calc</li>
<li>代码中减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；</li>
</ul>
<h2 id="%E5%85%B6%E4%BB%96" tabindex="-1"><a class="header-anchor" href="#%E5%85%B6%E4%BB%96">其他</a></h2>
<ul>
<li>减少 http 请求次数（雪碧图、字体图标）</li>
<li>style 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async</li>
<li>单页应用首屏加载放个 loading，优化用户感知，利用一些动画 过渡效果、骨架屏</li>
<li>使用 link 标签的 rel 属性设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li>
<li>借助 webpack-bundle-analyzer 工具分析打包出的文件包含哪些,大小占比如何,模块包含关系</li>
<li>注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢</li>
<li>webpack 的 tree-shaking 删除多余代码</li>
<li>压缩 js、css 代码</li>
<li>动态 polyfill，只针对不支持的浏览器引入 polyfill</li>
<li>减少 cookie 的体积</li>
<li>强缓存通用库，比如 jq、lodash</li>
<li>通用的库使用 CDN 加速，将通用的库抽离，不要打包进 bundle，比如 jq、lodash</li>
<li>使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，会得到缓存</li>
<li>通用的库按需加载，比如 antd</li>
<li>服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）</li>
<li>路由懒加载</li>
<li>图片懒加载</li>
<li>小图片使用字体图标代替</li>
<li>服务端渲染</li>
</ul>
<h2 id="%E5%B0%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%94%BE%E5%9C%A8%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88cdn%EF%BC%89" tabindex="-1"><a class="header-anchor" href="#%E5%B0%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%94%BE%E5%9C%A8%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88cdn%EF%BC%89">将静态资源放在其他域名的原因（CDN）</a></h2>
<ul>
<li>浏览器对于相同域名有并发请求数限制</li>
<li>请求时不会发送 cookie，节省了流量</li>
<li>cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名</li>
</ul>
<h2 id="script-%E6%A0%87%E7%AD%BE%E7%9A%84-defer-%E5%92%8C-async" tabindex="-1"><a class="header-anchor" href="#script-%E6%A0%87%E7%AD%BE%E7%9A%84-defer-%E5%92%8C-async">script 标签的 defer 和 async</a></h2>
<ul>
<li>没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本</li>
<li>async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。</li>
<li>defer：立即下载，将延迟到整个页面都解析完毕后再运行</li>
</ul>
<h2 id="%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96" tabindex="-1"><a class="header-anchor" href="#%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96">缓存优化</a></h2>
<ul>
<li>Cache-Control：
<ul>
<li>不经常变的文件，比如 jQuery，设置 Cache-Control: max-age=31536000，</li>
<li>标准中规定 max-age 值最大不能超过一年，又因为是以秒为单位，所以值为 31536000，</li>
<li>如果某天这个文件需要修改，改变文件名、请求地址就行</li>
</ul>
</li>
<li>设置 Expires：
<ul>
<li>缓存过期时间,用来指定资源的到期时间,是服务器端的具体的时间点；</li>
<li>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据,而不用再次请求；</li>
<li>max-age 的优化级高于 expires,当有 max-age 的时候,会无视 expires；当在有效时间内,如果服务器端的文件已经发生改变,但是浏览器端无法感知</li>
</ul>
</li>
</ul>
<h2 id="js-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8B%E9%9D%A2%EF%BC%9F" tabindex="-1"><a class="header-anchor" href="#js-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8B%E9%9D%A2%EF%BC%9F">js 为什么放最下面？</a></h2>
<ul>
<li>当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，比如 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的</li>
</ul>
<h2 id="css-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8A%E9%9D%A2%EF%BC%9F" tabindex="-1"><a class="header-anchor" href="#css-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8A%E9%9D%A2%EF%BC%9F">css 为什么放最上面？</a></h2>
<ul>
<li>CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染</li>
<li>css 是由单独的下载线程异步下载的</li>
<li>但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）</li>
</ul>
<h2 id="gzip" tabindex="-1"><a class="header-anchor" href="#gzip">gzip</a></h2>
<ul>
<li>只对文本文件有效，比如 js、css，流文件无效，比如图片</li>
<li>需要客户端和服务端的同时支持</li>
<li>客户端支持：请求头中有个 Accept-Encoding 来标识对压缩的支持，content-encoding: gzip</li>
<li>服务端支持：能够返回经过 gzip 压缩的文件</li>
</ul>
<h2 id="%E9%87%8D%E7%BB%98%EF%BC%88repaint%EF%BC%89%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88reflow%EF%BC%89" tabindex="-1"><a class="header-anchor" href="#%E9%87%8D%E7%BB%98%EF%BC%88repaint%EF%BC%89%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88reflow%EF%BC%89">重绘（repaint）与回流（reflow）</a></h2>
<ul>
<li>重绘：当元素样式的改变不影响布局时，触发重绘，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少。</li>
<li>回流、重排：当元素的尺寸、结构或触发某些属性时，触发回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较耗性能的操作。</li>
</ul>
<p>触发回流的操作：</p>
<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 dom 元素</li>
<li>激活 CSS 伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<p>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p>
<h2 id="%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A7%A6%E5%8F%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98" tabindex="-1"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A7%A6%E5%8F%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98">如何避免触发回流和重绘</a></h2>
<p>CSS：</p>
<ul>
<li>避免使用 table 布局。</li>
<li>尽可能在 DOM 树的最末端改变 class。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</li>
<li>避免使用 CSS 表达式（例如：calc()）</li>
<li>CSS3 硬件加速（GPU 加速）</li>
</ul>
<p>JavaScript：</p>
<ul>
<li>避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性</li>
<li>避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中</li>
<li>也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘</li>
<li>避免频繁读取会引发回流/重绘的属性或方法（offsetTop、offsetLeft、offsetWidth、offsetHeight、getBoundingClientRect 等），如果确实需要多次使用，就用一个变量缓存起来</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</li>
</ul>
<h1 id="requestanimationframe" tabindex="-1"><a class="header-anchor" href="#requestanimationframe">requestAnimationFrame</a></h1>
<ul>
<li>使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用</li>
<li>浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘</li>
<li>设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果</li>
<li>代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘</li>
<li>优势在于可以充分利用显示器的刷新机制，比较节省系统资源</li>
<li>显示器有固定的刷新频率（60Hz 或 75Hz），也就是说，每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想就是与这个刷新频率保持同步</li>
<li>cancelAnimationFrame 用于取消重绘，它的参数是 requestAnimationFrame 返回的一个代表任务 ID 的整数值</li>
<li>为了提高性能和电池寿命，因此在大多数浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的 <code>&lt;iframe&gt;</code> 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命</li>
<li>当浏览器渲染线程被过度占用时这个 API 调用间隔会非常不稳定，它并不是银弹</li>
</ul>
<p><strong>使用：</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">timestamp</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(timestamp);
  <span class="hljs-title function_">requestAnimationFrame</span>(test);
}
<span class="hljs-title function_">requestAnimationFrame</span>(test);
</code></pre>
<h1 id="%E6%89%8B%E5%86%99-ajax" tabindex="-1"><a class="header-anchor" href="#%E6%89%8B%E5%86%99-ajax">手写 Ajax</a></h1>
<pre><code class="language-jsx"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 通信成功时，状态值为4</span>
  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) {
    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(xhr.<span class="hljs-property">statusText</span>);
    }
  }
};
xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(xhr.<span class="hljs-property">statusText</span>);
};
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.example.com/page.php&#x27;</span>, <span class="hljs-literal">true</span>);
xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);
</code></pre>
<p>XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。</p>
<p>0，表示 XMLHttpRequest 实例已经生成，但是实例的 open()方法还没有被调用。
1，表示 open()方法已经调用，但是实例的 send()方法还没有调用，仍然可以使用实例的 setRequestHeader()方法，设定 HTTP 请求的头信息。
2，表示实例的 send()方法已经调用，并且服务器返回的头信息和状态码已经收到。
3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的 responseType 属性等于 text 或者空字符串，responseText 属性就会包含已经收到的部分信息。
4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。</p>
<h1 id="%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%88%E8%B7%A8%E5%9F%9F%EF%BC%89" tabindex="-1"><a class="header-anchor" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%88%E8%B7%A8%E5%9F%9F%EF%BC%89">同源策略（跨域）</a></h1>
<ul>
<li>不同协议、域名、端口，禁止请求，iframe、image、script、link 标签可以</li>
</ul>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5" tabindex="-1"><a class="header-anchor" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">为什么会有同源策略</a></h2>
<p>如果没有同源策略，不同源的数据和资源（如 HTTP 头、Cookie、DOM、localStorage 等）就能相互随意访问，根本没有隐私和安全可言。</p>
<h2 id="%E8%A7%A3%E5%86%B3" tabindex="-1"><a class="header-anchor" href="#%E8%A7%A3%E5%86%B3">解决</a></h2>
<ul>
<li>nginx，tomcat，apache 等任何有代理相关功能的服务器</li>
<li>jsonp</li>
<li>cors</li>
</ul>
<h2 id="jsonp" tabindex="-1"><a class="header-anchor" href="#jsonp">jsonp</a></h2>
<ul>
<li>使用 script 标签来帮助我们跨域</li>
<li>服务端返回 <code>函数名({json数据})</code>，放在 script src 请求执行，前后端约定好函数名（或者由前端传给后端，即 callbackName）</li>
<li>jquery 封装了 jsonp</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不好调试，在调用失败的时候不会返回任何状态码</li>
<li>安全性，提供 jsonp 的服务可能存在页面注入漏洞</li>
</ul>
<h2 id="cors" tabindex="-1"><a class="header-anchor" href="#cors">cors</a></h2>
<ul>
<li>
<p>服务器设置响应头：<code>Access-Control-Allow-Origin:&lt;origin&gt;|*</code>，origin 参数的值指定了允许访问该资源的外域 URL</p>
</li>
<li>
<p>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DRP、DownLink、Save-Data、Viewport-Width、Width、Content-Type(值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一)</p>
</li>
<li>
<p>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求失败</p>
<pre><code class="language-javascript">res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Content-Type,X-Custom-Header&#x27;</span>);
</code></pre>
</li>
<li>
<p>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求，如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 只允许POST、GET、DELETE、HEAD请求方法</span>
res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;POST,GET,DELETE,HEAD&#x27;</span>);
<span class="hljs-comment">// 允许所有的HTTP请求方法</span>
res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);
</code></pre>
</li>
</ul>
<h3 id="%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB" tabindex="-1"><a class="header-anchor" href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB">请求的分类</a></h3>
<p>同时满足以下两大条件的请求，就属于简单请求，反之为非简单请求：</p>
<ul>
<li>请求方式：GET、POST、HEAD 三者之一</li>
<li>HTTP 头部信息不超过以下几种字段：
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ul>
<p><strong>简单请求：</strong></p>
<ul>
<li>
<p>请求头自动带上 Origin</p>
</li>
<li>
<p>如果 Origin 指定的源不在允许范围之内，服务器就会返回一个正常的 HTTP 回应，然后浏览器发现头信息中没有包含 Access-Control-Allow-Origin 字段，就表示出错</p>
</li>
<li>
<p>否则会出现如下响应头</p>
<pre><code class="language-yaml"><span class="hljs-attr">Access-Control-Allow-Origin:</span> <span class="hljs-string">http://api.bob.com</span> <span class="hljs-comment"># 接受请求的域(*为所有)</span>
<span class="hljs-attr">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否可以发送cookie</span>
<span class="hljs-attr">Access-Control-Expose-Headers:</span> <span class="hljs-string">FooBar</span> <span class="hljs-comment"># 该字段可选，XHMHttpRequest 对象的方法只能够拿到六种字段: Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果想拿到其他的需要使用该字段指定</span>
<span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=utf-8</span>
</code></pre>
</li>
<li>
<p>如果请求时需要带上 cookie，请求头需要设置 withCredentials 为 true</p>
</li>
</ul>
<p><strong>非简单请求：</strong></p>
<ul>
<li>
<p>非简单请求的 CORS 会在正式通信之前进行一次预检请求</p>
</li>
<li>
<p>浏览器先询问服务器，当前网页所在的域名是否可以请求您的服务器，以及可以使用那些 HTTP 动词和头信息，只有得到正确的答复，才会进行正式的请求</p>
</li>
<li>
<p>预检使用的请求方法是 OPTIONS，表示这个请求是用来询问的</p>
<pre><code class="language-yaml"><span class="hljs-comment"># 预检请求示例</span>

<span class="hljs-string">OPTIONS</span> <span class="hljs-string">/cors</span> <span class="hljs-string">HTTP/1.1</span>
<span class="hljs-attr">Origin:</span> <span class="hljs-string">localhost:2333</span>
<span class="hljs-attr">Access-Control-Request-Method:</span> <span class="hljs-string">PUT</span> <span class="hljs-string">//</span> <span class="hljs-string">表示使用的什么HTTP请求方法</span>
<span class="hljs-attr">Access-Control-Request-Headers:</span> <span class="hljs-string">X-Custom-Header</span> <span class="hljs-string">//</span> <span class="hljs-string">表示浏览器发送的自定义字段</span>
<span class="hljs-attr">Host:</span> <span class="hljs-string">localhost:2332</span>
<span class="hljs-attr">Accept-Language:</span> <span class="hljs-string">zh-CN,zh;q=0.9</span>
<span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span>
<span class="hljs-attr">User-Agent:</span> <span class="hljs-string">Mozilla/5.0...</span>
</code></pre>
</li>
<li>
<p>服务器收到预检请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应</p>
<pre><code class="language-yaml"><span class="hljs-comment"># 预检响应头示例</span>

<span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span>
<span class="hljs-attr">Date:</span> <span class="hljs-string">Mon,</span> <span class="hljs-number">01</span> <span class="hljs-string">Dec</span> <span class="hljs-number">2008 01:15:39 </span><span class="hljs-string">GMT</span>
<span class="hljs-attr">Server:</span> <span class="hljs-string">Apache/2.0.61</span> <span class="hljs-string">(Unix)</span>
<span class="hljs-attr">Access-Control-Allow-Origin:</span> <span class="hljs-string">http://localhost:2332</span> <span class="hljs-string">//</span> <span class="hljs-string">表示</span> <span class="hljs-string">http://localhost:2332可以访问数据</span>
<span class="hljs-attr">Access-Control-Allow-Methods:</span> <span class="hljs-string">GET,</span> <span class="hljs-string">POST,</span> <span class="hljs-string">PUT</span>
<span class="hljs-attr">Access-Control-Allow-Headers:</span> <span class="hljs-string">X-Custom-Header</span>
<span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=utf-8</span>
<span class="hljs-attr">Content-Encoding:</span> <span class="hljs-string">gzip</span>
<span class="hljs-attr">Content-Length:</span> <span class="hljs-number">0</span>
<span class="hljs-attr">Keep-Alive:</span> <span class="hljs-string">timeout=2,</span> <span class="hljs-string">max=100</span>
<span class="hljs-attr">Connection:</span> <span class="hljs-string">Keep-Alive</span>
<span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/plain</span>
</code></pre>
</li>
<li>
<p>如未通过预检，会返回一个正常的 HTTP 响应，但是没有任何 CORS 的头相关信息，浏览器认定为失败</p>
</li>
<li>
<p>当预检请求通过之后就发出正常的 HTTP 请求</p>
</li>
</ul>
<h1 id="%E4%BA%8B%E4%BB%B6%E6%B5%81" tabindex="-1"><a class="header-anchor" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81">事件流</a></h1>
<p>事件流描述的是从页面中接收事件的顺序，事件流包括下面几个阶段。</p>
<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
<li>addEventListener 第三个参数：true - 事件在捕获阶段执行；false（默认） - 事件在冒泡阶段执行</li>
</ul>
<h2 id="%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%89" tabindex="-1"><a class="header-anchor" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%89">事件流的应用：事件委托（事件代理）</a></h2>
<p>事件委托指的是，</p>
<ul>
<li>不直接在目标 dom 上设置监听函数，而是在其父元素上设置监听函数，</li>
<li>通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。</li>
</ul>
<p>举例：ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</p>
<p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>
<h2 id="target-%E5%92%8C-currenttarget-%E5%8C%BA%E5%88%AB" tabindex="-1"><a class="header-anchor" href="#target-%E5%92%8C-currenttarget-%E5%8C%BA%E5%88%AB">target 和 currentTarget 区别</a></h2>
<ul>
<li>event.target 返回触发事件的元素</li>
<li>event.currentTarget 返回绑定事件的元素</li>
</ul>
<h1 id="js-%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%8C%BA%E5%88%AB" tabindex="-1"><a class="header-anchor" href="#js-%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%8C%BA%E5%88%AB">js 的各种位置区别</a></h1>
<p>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条
offsetHeight：表示可视区域的高度，包含了 border 和滚动条
scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。
clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0
scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</p>
<h1 id="localstorage%E3%80%81sessionstorage" tabindex="-1"><a class="header-anchor" href="#localstorage%E3%80%81sessionstorage">localStorage、sessionStorage</a></h1>
<ul>
<li>关闭选项卡后，将删除存储在 sessionStorage 中的数据</li>
<li>localStorage 永远存在，除非手动删除</li>
<li>cookie 根据 expires 字段（过期时间）决定</li>
</ul>

      
        <div class="btt withToc" id="btt"></div>
      
    </div>
    
    <div class="table-of-contents"><ul><li title=输入 URL 到网页渲染过程><a href="#%E8%BE%93%E5%85%A5-url-%E5%88%B0%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B" data-anchor="#%E8%BE%93%E5%85%A5-url-%E5%88%B0%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">输入 URL 到网页渲染过程</a></li><li title=Web Worker><a href="#web-worker" data-anchor="#web-worker">Web Worker</a></li><li title=XSS、CSRF 攻击原理和防御><a href="#xss%E3%80%81csrf-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%92%8C%E9%98%B2%E5%BE%A1" data-anchor="#xss%E3%80%81csrf-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86%E5%92%8C%E9%98%B2%E5%BE%A1">XSS、CSRF 攻击原理和防御</a><ul><li title=SameSite><a href="#samesite" data-anchor="#samesite">SameSite</a></li></ul></li><li title=DOM api><a href="#dom-api" data-anchor="#dom-api">DOM api</a><ul><li title=创建新节点><a href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%8A%82%E7%82%B9" data-anchor="#%E5%88%9B%E5%BB%BA%E6%96%B0%E8%8A%82%E7%82%B9">创建新节点</a></li><li title=添加、移除、替换、插入><a href="#%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E6%9B%BF%E6%8D%A2%E3%80%81%E6%8F%92%E5%85%A5" data-anchor="#%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E6%9B%BF%E6%8D%A2%E3%80%81%E6%8F%92%E5%85%A5">添加、移除、替换、插入</a></li><li title=查找><a href="#%E6%9F%A5%E6%89%BE" data-anchor="#%E6%9F%A5%E6%89%BE">查找</a></li></ul></li><li title=前端路由原理><a href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86" data-anchor="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86">前端路由原理</a></li><li title=什么是 HTML 语义化><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-html-%E8%AF%AD%E4%B9%89%E5%8C%96" data-anchor="#%E4%BB%80%E4%B9%88%E6%98%AF-html-%E8%AF%AD%E4%B9%89%E5%8C%96">什么是 HTML 语义化</a></li><li title=单页应用（SPA）优缺点><a href="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%88spa%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9" data-anchor="#%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%88spa%EF%BC%89%E4%BC%98%E7%BC%BA%E7%82%B9">单页应用（SPA）优缺点</a></li><li title=白屏><a href="#%E7%99%BD%E5%B1%8F" data-anchor="#%E7%99%BD%E5%B1%8F">白屏</a><ul><li title=如何解决白屏问题><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98" data-anchor="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98">如何解决白屏问题</a></li><li title=计算首屏白屏时间><a href="#%E8%AE%A1%E7%AE%97%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4" data-anchor="#%E8%AE%A1%E7%AE%97%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4">计算首屏白屏时间</a></li></ul></li><li title=性能优化><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" data-anchor="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a><ul><li title=代码><a href="#%E4%BB%A3%E7%A0%81" data-anchor="#%E4%BB%A3%E7%A0%81">代码</a></li><li title=其他><a href="#%E5%85%B6%E4%BB%96" data-anchor="#%E5%85%B6%E4%BB%96">其他</a></li><li title=将静态资源放在其他域名的原因（CDN）><a href="#%E5%B0%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%94%BE%E5%9C%A8%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88cdn%EF%BC%89" data-anchor="#%E5%B0%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%94%BE%E5%9C%A8%E5%85%B6%E4%BB%96%E5%9F%9F%E5%90%8D%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88cdn%EF%BC%89">将静态资源放在其他域名的原因（CDN）</a></li><li title=script 标签的 defer 和 async><a href="#script-%E6%A0%87%E7%AD%BE%E7%9A%84-defer-%E5%92%8C-async" data-anchor="#script-%E6%A0%87%E7%AD%BE%E7%9A%84-defer-%E5%92%8C-async">script 标签的 defer 和 async</a></li><li title=缓存优化><a href="#%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96" data-anchor="#%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96">缓存优化</a></li><li title=js 为什么放最下面？><a href="#js-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8B%E9%9D%A2%EF%BC%9F" data-anchor="#js-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8B%E9%9D%A2%EF%BC%9F">js 为什么放最下面？</a></li><li title=css 为什么放最上面？><a href="#css-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8A%E9%9D%A2%EF%BC%9F" data-anchor="#css-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%94%BE%E6%9C%80%E4%B8%8A%E9%9D%A2%EF%BC%9F">css 为什么放最上面？</a></li><li title=gzip><a href="#gzip" data-anchor="#gzip">gzip</a></li><li title=重绘（repaint）与回流（reflow）><a href="#%E9%87%8D%E7%BB%98%EF%BC%88repaint%EF%BC%89%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88reflow%EF%BC%89" data-anchor="#%E9%87%8D%E7%BB%98%EF%BC%88repaint%EF%BC%89%E4%B8%8E%E5%9B%9E%E6%B5%81%EF%BC%88reflow%EF%BC%89">重绘（repaint）与回流（reflow）</a></li><li title=如何避免触发回流和重绘><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A7%A6%E5%8F%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98" data-anchor="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A7%A6%E5%8F%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98">如何避免触发回流和重绘</a></li></ul></li><li title=requestAnimationFrame><a href="#requestanimationframe" data-anchor="#requestanimationframe">requestAnimationFrame</a></li><li title=手写 Ajax><a href="#%E6%89%8B%E5%86%99-ajax" data-anchor="#%E6%89%8B%E5%86%99-ajax">手写 Ajax</a></li><li title=同源策略（跨域）><a href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%88%E8%B7%A8%E5%9F%9F%EF%BC%89" data-anchor="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%88%E8%B7%A8%E5%9F%9F%EF%BC%89">同源策略（跨域）</a><ul><li title=为什么会有同源策略><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5" data-anchor="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">为什么会有同源策略</a></li><li title=解决><a href="#%E8%A7%A3%E5%86%B3" data-anchor="#%E8%A7%A3%E5%86%B3">解决</a></li><li title=jsonp><a href="#jsonp" data-anchor="#jsonp">jsonp</a></li><li title=cors><a href="#cors" data-anchor="#cors">cors</a><ul><li title=请求的分类><a href="#%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB" data-anchor="#%E8%AF%B7%E6%B1%82%E7%9A%84%E5%88%86%E7%B1%BB">请求的分类</a></li></ul></li></ul></li><li title=事件流><a href="#%E4%BA%8B%E4%BB%B6%E6%B5%81" data-anchor="#%E4%BA%8B%E4%BB%B6%E6%B5%81">事件流</a><ul><li title=事件流的应用：事件委托（事件代理）><a href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%89" data-anchor="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%89">事件流的应用：事件委托（事件代理）</a></li><li title=target 和 currentTarget 区别><a href="#target-%E5%92%8C-currenttarget-%E5%8C%BA%E5%88%AB" data-anchor="#target-%E5%92%8C-currenttarget-%E5%8C%BA%E5%88%AB">target 和 currentTarget 区别</a></li></ul></li><li title=js 的各种位置区别><a href="#js-%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%8C%BA%E5%88%AB" data-anchor="#js-%E7%9A%84%E5%90%84%E7%A7%8D%E4%BD%8D%E7%BD%AE%E5%8C%BA%E5%88%AB">js 的各种位置区别</a></li><li title=localStorage、sessionStorage><a href="#localstorage%E3%80%81sessionstorage" data-anchor="#localstorage%E3%80%81sessionstorage">localStorage、sessionStorage</a></li></ul></div>
    

    <!-- bottom scripts -->
    <script src="//cdn.jsdelivr.net/npm/mark.js@8.11.1/dist/jquery.mark.min.js"></script>
    <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
    <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
    <script src="/my-book/resource/script.js"></script>
  </body>
</html>
