<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - 其他</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/29/2022, 3:18:03 PM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="menu" id="menu"></div>
    <div class="mobile_menu" id="mobile_menu">
      <img src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/bars.svg" alt="" />
    </div>
    <div class="content markdown-body"><h1>事件循环</h1>
<h2>是什么</h2>
<ul>
<li>由于使用场景的原因，js 是设计成单线程的，为了更好的处理异步任务，所以设计了这个事件循环的机制</li>
<li>一个浏览器通常有几个线程：渲染引擎线程、JS 引擎线程、定时触发器线程、事件触发线程、异步 http 请求线程</li>
<li>渲染线程和 JS 引擎线程是不能同时进行的</li>
<li>也就是说在执行 js 代码时，渲染会挂起；渲染 DOM 时，js 代码也不会执行。虽然 js 是单线程，但是浏览器是多线程的</li>
<li>在遇到异步任务时（setTimeout、DOM 事件、ajax 等），会转交给浏览器的其他工作线程(上面提到的几个线程)执行，执行完之后将回调函数放入到任务队列</li>
<li>一般来说，非阻塞性的任务采取同步的方式，直接在主线程的执行栈完成</li>
<li>阻塞性的任务都会采用异步来执行，然后回调函数会放到事件队列中</li>
<li>当主线程的任务执行完了（执行栈空了），js 会去询问事件队列有没有回到函数需要执行（所以 setTimeout 0 会等到最后才执行）</li>
<li>主线程在运行时会产生执行栈</li>
<li>栈中的代码调用某些异步 API 时会在任务队列中添加事件，</li>
<li>栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，</li>
<li>如此循环往复，形成事件循环机制</li>
</ul>
<h2>宏任务和微任务</h2>
<ul>
<li>任务队列又分微任务队列和宏任务队列</li>
<li>宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。</li>
<li>宏任务：script 标签中的代码、setTimeout/setInterval/setImmediate、UI rendering/DOM 事件、postMessage</li>
<li>微任务：Promise、MutationObserver、ajax 请求</li>
<li>当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行</li>
</ul>
<h2>执行过程</h2>
<p>先执行 script 中的同步任务，然后所有微任务 -&gt; 一个宏任务 -&gt; 所有微任务 -&gt; 一个宏任务</p>
<ol>
<li>执行完主线程中的任务</li>
<li>取出 微队列(Microtask Queue) 中任务执行直到清空</li>
<li>取出 宏队列(Macrotask Queue) 中一个任务执行</li>
<li>重复 2 和 3</li>
</ol>
<ul>
<li>如果微任务一直被添加，则会继续执行微任务，“卡死”宏任务</li>
<li>Promise 的 then 和 catch 才是微任务 ，本身的内部代码不是</li>
</ul>
<h2>js 为什么是单线程</h2>
<ul>
<li>与 js 的用途有关</li>
<li>如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，渲染器就不知道以哪个线程为准</li>
<li>所以，为了避免复杂性，设计成单线程</li>
<li>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</li>
</ul>
<h1>Web Worker</h1>
<p>现代浏览器为 JavaScript 创造的 多线程环境。可以新建并将部分任务分配到 worker 线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。 基本用法：</p>
<pre><code class="language-jsx">// 创建worker
const worker = new Worker('work.js');
// 向 worker 线程推送消息
worker.postMessage('Hello World');
// 监听 worker 线程发送过来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
};
</code></pre>
<p>限制:</p>
<ul>
<li>同源限制</li>
<li>无法使用 document / window / alert / confirm</li>
<li>无法加载本地资源</li>
</ul>
<h1>XSS、CSRF 攻击原理和防御</h1>
<p>XSS：</p>
<ul>
<li>通过利用网页开发时留下的漏洞，比如评论框，注入恶意 js 到网页</li>
<li>防御 xss：过滤 html 标签，转义页面上的输入内容和输出内容，过滤 on 开头属性，cookie 设置 httpOnly</li>
</ul>
<p>CSRF：</p>
<ul>
<li>设法伪造带有正确 Cookie 的 HTTP 请求</li>
<li>通常由于服务端没有对请求头做严格过滤引起的</li>
<li>CSRF 防御：
<ul>
<li>不要使用 GET 请求来修改数据</li>
<li>不要被第三方网站访问到用户的 cookie</li>
<li>Referer 头检测，设置白名单</li>
<li>接口不要被第三方网站请求、用 token 请求校验</li>
</ul>
</li>
</ul>
<h2>SameSite</h2>
<ul>
<li>是 cookie 的一个属性，用来防止 CSRF 攻击和用户追踪，用来限制第三方 Cookie</li>
<li>Strict<br>
完全禁止第三方 Cookie，可能造成不好的用户体验，比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态</li>
<li>Lax（默认值）
大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外</li>
<li>None</li>
<li>网站可以选择显式关闭 SameSite 属性，将其设为 None。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</li>
</ul>
<h1>DOM 操作 api</h1>
<h2>创建新节点</h2>
<ul>
<li>createDocumentFragment() //创建一个 DOM 片段</li>
<li>createElement() //创建一个具体的元素</li>
<li>createTextNode() //创建一个文本节点</li>
</ul>
<h2>添加、移除、替换、插入</h2>
<ul>
<li>appendChild() //添加</li>
<li>removeChild() //移除</li>
<li>replaceChild() //替换</li>
<li>insertBefore() //插入</li>
</ul>
<h2>查找</h2>
<ul>
<li>getElementsByTagName()</li>
<li>getElementsByName()</li>
<li>getElementById()</li>
<li>document.querySelector()</li>
<li>document.querySelectorAll()</li>
</ul>
<h1>前端路由原理</h1>
<p><strong>hash 模式：</strong></p>
<ul>
<li>在浏览器中，#号以及#号后面的字符称之为 hash，用 window.location.hash 读取；</li>
<li>hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，修改 hash 不会刷新页面。</li>
<li>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</li>
</ul>
<p><strong>history 模式：</strong></p>
<ul>
<li>history 采用了 HTML5 的新特性 pushState 和 replaceState 可以对浏览器历史记录、html 标题进行修改，以及 popState 事件的监听到状态变更。</li>
<li>history 模式下，前端的 URL 和实际向后端发起请求的 URL 一致。服务端如果缺少对该页面请求的处理，就会返回 404 错误。</li>
<li>需要在服务端增加一个覆盖所有情况的候选资源：比如 URL 匹配不到任何资源时，则返回同一个 index.html 页面，这个页面就是前端应用的入口页面。</li>
</ul>
<p>我个人更推荐用 history 模式，history 模式更利于 seo 优化，url 也比较美观。</p>
<h1>什么是 HTML 语义化</h1>
<p>HTML5 语义化标签是指：正确的标签包含正确的内容，结构良好，便于阅读，利于 SEO 优化，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签</p>
<h1>单页应用（SPA）优缺点</h1>
<p>优点：</p>
<ul>
<li>内容的改变不需要重新加载整个页面，用户体验好</li>
<li>相对对服务器压力小</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理</li>
</ul>
<p>缺点：</p>
<ul>
<li>首屏加载慢</li>
<li>前进后退路由需要自己管理，不能使用浏览器的前进后退功能</li>
<li>SEO（搜索优化）难度大</li>
</ul>
<h1>白屏</h1>
<h2>如何解决白屏问题</h2>
<p>往 html 中填充内容，比如渲染根元素中间加上“加载中”几个字，让渲染结束前的这段时间有内容可以显示。</p>
<h2>计算首屏白屏时间</h2>
<p>使用 Performance API：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;白屏&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      // 不兼容performance.timing 的浏览器，如IE8
      window.pageStartTime = Date.now();
    &lt;/script&gt;
    &lt;!-- 页面 CSS 资源 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot; /&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      // 白屏时间结束点
      window.firstPaint = Date.now();
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- 页面内容 --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>可使用 Performance API 时，
白屏时间 = firstPaint - performance.timing.navigationStart;</p>
<p>不可使用 Performance API 时，
白屏时间 = firstPaint - pageStartTime;</p>
<h1>输入 URL 到网页渲染过程</h1>
<ul>
<li>
<p>DNS 解析</p>
<ul>
<li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录</li>
<li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会去操作系统中找</li>
<li>路由缓存：路由器也有 DNS 缓存</li>
<li>ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求</li>
<li>根服务器：ISP 的 DNS 服务器找不到之后，就要向根服务器发出请求，进行递归查询</li>
</ul>
</li>
<li>
<p>获得请求 url 对应的 ip 地址</p>
</li>
<li>
<p>浏览器发送请求与服务器交互的过程</p>
<ul>
<li>首先浏览器利用 tcp 协议通过三次握手与服务器建立连接</li>
<li>浏览器根据解析到的 IP 地址和端口号发起请求</li>
<li>服务器接收到 http 请求之后，开始搜索内容，并返回响应报文</li>
<li>若状态码为 200 显示响应成功，浏览器接收到返回的 html，开始进行渲染</li>
</ul>
</li>
<li>
<p>渲染过程</p>
<ul>
<li>
<p>浏览器根据深度遍历的方式把 html 节点遍历成 dom 树</p>
</li>
<li>
<p>将 css 解析成 CSS DOM 树</p>
</li>
<li>
<p>将 dom 树和 CSS DOM 树构造成渲染树</p>
<ul>
<li>补充：构造渲染树的过程</li>
<li>从 DOM 树的根节点开始遍历每个可见的节点</li>
<li>对于每个可见的节点，找到 CSS 树中的对应的规则，并且应用他们</li>
<li>根据每个可见的节点及其对应的样式，组合生成渲染树</li>
</ul>
</li>
<li>
<p>当文档加载过程中遇到 js 文件，html 文档会挂起渲染的线程，要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，这意味着在 JS 执行完成前，后续资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的</p>
</li>
<li>
<p>根据得到的渲染树 计算所有节点在屏幕中的位置，进行布局（回流）</p>
</li>
<li>
<p>遍历渲染树并调用硬件的 API 绘制所有节点（重绘）</p>
</li>
</ul>
</li>
</ul>
<h1>性能优化</h1>
<h2>代码</h2>
<ul>
<li>缓存 dom 查找结果</li>
<li>用 innerHTML 代替 DOM 操作，减少 DOM 操作次数</li>
<li>使用局部变量和字面量比使用数组和对象有更少的读写消耗</li>
<li>原型链不要过深、对象嵌套不要太多</li>
<li>对于多次访问的嵌套对象，应该用变量缓存起来</li>
<li>不要频繁修改 DOM</li>
<li>如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称</li>
</ul>
<pre><code class="language-jsx">const el = document.querySelector('.myDiv');
el.style.borderLeft = '1px';
el.style.borderRight = '2px';
el.style.padding = '5px';
// 可以使用如下语句代替
const el = document.querySelector('.myDiv');
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';
// cssText会覆盖已存在的样式，所以使用 +=
</code></pre>
<ul>
<li>使用事件委托</li>
<li>如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快</li>
<li>CSS 能做的事情，尽量不用 JS 来做</li>
<li>避免 css 表达式比如 calc</li>
<li>代码中减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；</li>
</ul>
<h2>其他</h2>
<ul>
<li>减少 http 请求次数（雪碧图、字体图标）</li>
<li>style 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async</li>
<li>单页应用首屏加载放个 loading，优化用户感知，利用一些动画 过渡效果、骨架屏</li>
<li>使用 link 标签的 rel 属性设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）</li>
<li>借助 webpack-bundle-analyzer 工具分析打包出的文件包含哪些,大小占比如何,模块包含关系</li>
<li>注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢</li>
<li>webpack 的 tree-shaking 删除多余代码</li>
<li>压缩 js、css 代码</li>
<li>动态 polyfill，只针对不支持的浏览器引入 polyfill</li>
<li>减少 cookie 的体积</li>
<li>强缓存通用库，比如 jq、lodash</li>
<li>通用的库使用 CDN 加速，将通用的库抽离，不要打包进 bundle，比如 jq、lodash</li>
<li>使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，会得到缓存</li>
<li>通用的库按需加载，比如 antd</li>
<li>服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）</li>
<li>路由懒加载</li>
<li>图片懒加载</li>
<li>小图片使用字体图标代替</li>
<li>服务端渲染</li>
</ul>
<h2>将静态资源放在其他域名的原因（CDN）</h2>
<ul>
<li>浏览器对于相同域名有并发请求数限制</li>
<li>请求时不会发送 cookie，节省了流量</li>
<li>cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名</li>
</ul>
<h2>script 标签的 defer 和 async</h2>
<ul>
<li>没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。</li>
<li>async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。</li>
<li>defer：立即下载，将延迟到整个页面都解析完毕后再运行</li>
</ul>
<h2>缓存优化</h2>
<ul>
<li>Cache-Control：
<ul>
<li>不经常变的文件，比如 jQuery，设置 Cache-Control: max-age=31536000，</li>
<li>标准中规定 max-age 值最大不能超过一年，又因为是以秒为单位，所以值为 31536000，</li>
<li>如果某天这个文件需要修改，改变文件名、请求地址就行</li>
</ul>
</li>
<li>设置 Expires：
<ul>
<li>缓存过期时间,用来指定资源的到期时间,是服务器端的具体的时间点；</li>
<li>告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据,而不用再次请求；</li>
<li>max-age 的优化级高于 expires,当有 max-age 的时候,会无视 expires；当在有效时间内,如果服务器端的文件已经发生改变,但是浏览器端无法感知</li>
</ul>
</li>
</ul>
<h2>js 为什么放最下面？</h2>
<ul>
<li>当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，比如 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的</li>
</ul>
<h2>css 为什么放最上面？</h2>
<ul>
<li>CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染</li>
<li>css 是由单独的下载线程异步下载的</li>
<li>但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）</li>
</ul>
<h2>gzip</h2>
<ul>
<li>只对文本文件有效，比如 js、css，流文件无效，比如图片</li>
<li>需要客户端和服务端的同时支持</li>
<li>客户端支持：请求头中有个 Accept-Encoding 来标识对压缩的支持，content-encoding: gzip</li>
<li>服务端支持：能够返回经过 gzip 压缩的文件</li>
</ul>
<h2>重绘与回流</h2>
<ul>
<li>重绘：当元素样式的改变不影响布局时，触发重绘，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少。</li>
<li>回流：当元素的尺寸、结构或触发某些属性时，触发回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较耗性能的操作。</li>
</ul>
<p>触发回流的操作：</p>
<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 dom 元素</li>
<li>激活 CSS 伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<p>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p>
<h2>如何避免触发回流和重绘</h2>
<p>CSS：</p>
<p>避免使用 table 布局。
尽可能在 DOM 树的最末端改变 class。
避免设置多层内联样式。
将动画效果应用到 position 属性为 absolute 或 fixed 的元素上
避免使用 CSS 表达式（例如：calc()）
CSS3 硬件加速（GPU 加速）</p>
<p>JavaScript：</p>
<p>避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中
也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘
避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流</p>
<h1>requestAnimationFrame</h1>
<ul>
<li>使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用</li>
<li>浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘</li>
<li>设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果</li>
<li>代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘</li>
<li>优势在于可以充分利用显示器的刷新机制，比较节省系统资源</li>
<li>显示器有固定的刷新频率（60Hz 或 75Hz），也就是说，每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想就是与这个刷新频率保持同步</li>
<li>cancelAnimationFrame 用于取消重绘，它的参数是 requestAnimationFrame 返回的一个代表任务 ID 的整数值</li>
</ul>
<h1>手写 Ajax</h1>
<pre><code class="language-jsx">var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function () {
  // 通信成功时，状态值为4
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log(xhr.responseText);
    } else {
      console.error(xhr.statusText);
    }
  }
};
xhr.onerror = function (e) {
  console.error(xhr.statusText);
};
xhr.open('GET', 'http://www.example.com/page.php', true);
xhr.send(null);
</code></pre>
<p>XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。</p>
<p>0，表示 XMLHttpRequest 实例已经生成，但是实例的 open()方法还没有被调用。
1，表示 open()方法已经调用，但是实例的 send()方法还没有调用，仍然可以使用实例的 setRequestHeader()方法，设定 HTTP 请求的头信息。
2，表示实例的 send()方法已经调用，并且服务器返回的头信息和状态码已经收到。
3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的 responseType 属性等于 text 或者空字符串，responseText 属性就会包含已经收到的部分信息。
4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。</p>
<h1>同源策略（跨域）</h1>
<ul>
<li>不同协议、域名、端口，禁止请求，iframe、image、script、link 标签可以</li>
<li>nginx、jsonp、cors（Access-Control-Allow-Origin）</li>
<li>为什么会有同源策略： 如果没有同源策略，不同源的数据和资源（如 HTTP 头、Cookie、DOM、localStorage 等）就能相互随意访问，根本没有隐私和安全可言。</li>
</ul>
<h1>事件流</h1>
<p>事件流描述的是从页面中接收事件的顺序，事件流包括下面几个阶段。</p>
<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
<li>addEventListener 第三个参数：true - 事件在捕获阶段执行；false（默认） - 事件在冒泡阶段执行</li>
</ul>
<h2>事件流的应用：事件委托（事件代理）</h2>
<p>事件委托指的是，</p>
<ul>
<li>不直接在目标 dom 上设置监听函数，而是在其父元素上设置监听函数，</li>
<li>通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。</li>
</ul>
<p>举例：ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。</p>
<p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>
<h2>target 和 currentTarget 区别</h2>
<ul>
<li>event.target 返回触发事件的元素</li>
<li>event.currentTarget 返回绑定事件的元素</li>
</ul>
<h1>js 的各种位置区别</h1>
<p>clientHeight：表示的是可视区域的高度，不包含 border 和滚动条
offsetHeight：表示可视区域的高度，包含了 border 和滚动条
scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。
clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0
scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。</p>
<h1>localStorage、sessionStorage</h1>
<ul>
<li>关闭选项卡后，将删除存储在 sessionStorage 中的数据</li>
<li>localStorage 永远存在，除非手动删除</li>
<li>cookie 根据 expires 字段（过期时间）决定</li>
</ul>
</div>
  </body>
</html>
