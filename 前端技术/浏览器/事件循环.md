# 参考

- https://juejin.cn/post/6844904165462769678

# js 为什么是单线程

- 与 js 的用途有关
- 如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，渲染器就不知道以哪个线程为准
- 所以，为了避免复杂性，设计成单线程
- 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

# 事件循环

- 由于使用场景的原因，js 是设计成单线程的，为了更好的处理异步任务，所以设计了这个事件循环的机制
- 一个浏览器通常有几个线程：渲染引擎线程、JS 引擎线程、定时触发器线程、事件触发线程、异步 http 请求线程
- 渲染线程和 JS 引擎线程是不能同时进行的
- 也就是说在执行 js 代码时，渲染会挂起；渲染 DOM 时，js 代码也不会执行。虽然 js 是单线程，但是浏览器是多线程的
- 在遇到异步任务时（setTimeout、DOM 事件、ajax 等），会转交给浏览器的其他工作线程(上面提到的几个线程)执行，执行完之后将回调函数放入到任务队列
- 一般来说，非阻塞性的任务采取同步的方式，直接在主线程的执行栈完成
- 阻塞性的任务都会采用异步来执行，然后回调函数会放到事件队列中
- 当主线程的任务执行完了（执行栈空了），js 会去询问事件队列有没有回到函数需要执行（所以 setTimeout 0 会等到最后才执行）
- 主线程在运行时会产生执行栈
- 栈中的代码调用某些异步 API 时会在任务队列中添加事件，
- 栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，
- 如此循环往复，形成事件循环机制
- 事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行

# 宏任务和微任务

- 任务队列又分微任务队列和宏任务队列
- 宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。
- 宏任务（多为运行环境 api）：script 标签中的代码、UI 交互、setTimeout/setInterval/setImmediate、DOM 事件、postMessage、ajax 请求、requestAnimationFrame
- 微任务（多为语法）：Promise.then catch finally、MutationObserver、async/await、process.nextTick（NodeJS）
- 两者区别：
  - 宏任务：DOM 渲染后触发
  - 微任务：DOM 渲染前触发
- 当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行

# 为什么微任务执行更早

- 微任务是语法规定的
- 宏任务是由浏览器规定的（web api）
- 宏任务执行时间一般比较长
- 每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的

# 事件循环的具体流程

- 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；
- 执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；
- 当微任务队列清空后，一个事件循环结束；
- 接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止。

# 页面渲染

- 每次当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。通常我们浏览器页面刷新频率是 60fps，也就是意味着 16.67ms 要刷新一次，因此我们也要尽量保证一次事件循环控制在 16.67ms 之内，这也是我们需要做代码性能优化的一个原因。
- requestAnimationFrame 在重新渲染屏幕之前执行，非常适合用来做动画
- resize 和 scroll 事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上

# 执行过程

先执行 script 中的同步任务，然后所有微任务 -> 一个宏任务 -> 所有微任务 -> 一个宏任务

1. 执行完主线程中的任务
2. 取出 微队列(Microtask Queue) 中任务执行直到清空
3. 取出 宏队列(Macrotask Queue) 中一个任务执行
4. 重复 2 和 3

- 如果微任务一直被添加，则会继续执行微任务，“卡死”宏任务
- Promise 的 then 和 catch 才是微任务 ，本身的内部代码不是
