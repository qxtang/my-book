<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - 浏览器缓存</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/31/2022, 10:14:08 AM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="content markdown-body"><h1>参考</h1>
<ul>
<li><a href="https://www.jianshu.com/p/54cc04190252">https://www.jianshu.com/p/54cc04190252</a></li>
</ul>
<h1>浏览器缓存</h1>
<ul>
<li>Web 缓存种类： 数据库缓存，CDN 缓存，服务器缓存（例如 redis），浏览器缓存</li>
<li>浏览器实现了 http 缓存</li>
<li>浏览器缓存类型：强缓存，协商缓存</li>
<li>只有 get 请求会缓存，post 请求不会</li>
</ul>
<h1>缓存位置</h1>
<h2>Memory Cache</h2>
<ul>
<li>内存中缓存</li>
<li>主要包含的是当前页面中已经抓取到的资源，已经下载的样式、脚本、图片</li>
<li>读取高效、持续性很短</li>
<li>随着进程的释放而释放，杀进程或者关闭 Tab 页面会被释放</li>
<li>对于大文件来说，大概率是不存储在 Memory Cache 的，反之优先</li>
</ul>
<h2>Disk Cache</h2>
<ul>
<li>磁盘缓存</li>
<li>浏览器获取当前系统内存使用率，过高的话，优先存储进 Disk Cache</li>
<li>所有类型资源都可以放</li>
<li>速度较慢</li>
<li>不会被释放</li>
<li>容量大</li>
</ul>
<h1>缓存过程</h1>
<p>首次请求：</p>
<p><img src="../../resource/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%A6%96%E6%AC%A1%E8%AF%B7%E6%B1%82.drawio.png" alt="首次请求"></p>
<p>总体大致流程：</p>
<p><img src="../../resource/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="总体大致流程"></p>
<h2>强缓存</h2>
<ul>
<li>
<p>当符合命中强缓存的条件，不向服务器发送请求，直接从缓存中读取资源，返回 200 状态码</p>
</li>
<li>
<p>如果响应头有如下字段（按优先级小到大排序）：expires &lt; pragma &lt; cache-control，则为强缓存</p>
</li>
<li>
<p>cache-control 优先级最高，当不支持 http1.1 的环境才会使用 expires 或者 pragma</p>
</li>
<li>
<p>expires</p>
<ul>
<li>资源到期时间、格式为格林尼治时间戳</li>
<li>如果未超过过期时间，直接使用该缓存</li>
<li>缺点：要求客户端和服务端时钟严格同步，本地时间可以自己修改</li>
</ul>
</li>
<li>
<p>pragma</p>
<ul>
<li>HTTP 1.0</li>
<li>用于禁用网页缓存</li>
<li>取值为 no-cache，和 cache-control 的 no-cache 效果一样</li>
</ul>
</li>
<li>
<p>cache-control</p>
<ul>
<li>HTTP 1.1 新增</li>
<li>取值
<ul>
<li>public：资源客户端和服务器都可以缓存</li>
<li>privite：资源只有客户端可以缓存</li>
<li>no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证</li>
<li>no-store：不使用缓存</li>
<li>max-age：缓存保质期</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>协商缓存</h2>
<ul>
<li>强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程</li>
<li>会向服务器发送请求</li>
<li>协商缓存过程
<ul>
<li>服务器发现资源无需更新，返回 304</li>
<li>浏览器从本地缓存中获取资源，继续使用</li>
<li>如果服务器发现该资源更新了，返回该资源，状态码 200</li>
<li>浏览器更新该资源和缓存标识到本地缓存</li>
</ul>
</li>
</ul>
<h3>相关 header</h3>
<p>Last-Modified / If-Modified-Since</p>
<ul>
<li>存在的问题：时间单位只精确到秒，如果文件 1 秒内改变多次，无法确保缓存精度；有可能文件内容没变，但是修改时间因为某些原因变了，人为修改之类的</li>
<li>Last-Modified（响应头）
<ul>
<li>资源在服务器最后被修改的时间</li>
</ul>
</li>
<li>If-Modified-Since（请求头）
<ul>
<li>携带上次请求返回的 Last-Modified</li>
<li>告诉服务器该资源上次请求时的最后被修改时间</li>
<li>服务器做对比后决定协商缓存是否生效，返回 304 或 200</li>
</ul>
</li>
</ul>
<p>Etag / If-None-Match</p>
<ul>
<li>优先级高于 Last-Modified，解决 Last-Modified 的问题，但性能比 Last-Modified 差，Etag 需要计算</li>
<li>Etag（响应头）
<ul>
<li>当前资源文件唯一标识，由服务器生成，由文件内容决定</li>
</ul>
</li>
<li>If-None-Match（请求头）
<ul>
<li>携带上次请求该资源时返回的 Etag，告诉服务器</li>
<li>服务器做对比，一致则代表生效，返回 304 或 200</li>
</ul>
</li>
</ul>
<h1>实际应用</h1>
<ul>
<li>需要实时更新频繁变动的资源，设置 cache-control 为 no-cache</li>
<li>不常变化的资源，例如 jquery，设置 cache-control 为 max-age=一个很长的时间</li>
<li>单页应用部署时，入口 html 文件使用协商缓存（确保 html 入口是最新的，能够及时更新）</li>
</ul>
<h1>按下 F5 或 ctrl+F5 时发生了什么</h1>
<ul>
<li>ctrl+f5：强制刷新，直接从服务器加载资源，跳过强缓存和协商缓存</li>
<li>f5：跳过强缓存，会检查协商缓存</li>
<li>浏览器地址栏中输入 URL 回车：走正常流程</li>
</ul>
</div>
  </body>
</html>
