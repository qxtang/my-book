[{"id":"工作沉淀","dirname":"工作沉淀","filename":"","basename":"","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","children":[{"id":"工作沉淀/Fiddler 真机调试微信 h5.md","filename":"Fiddler 真机调试微信 h5.md","basename":"Fiddler 真机调试微信 h5","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"需求：真机上通过 https 和微信可信域名访问本地服务前提条件手机和电脑处在同一局域网环境电脑安装 Fiddler本地 hosts 文件添加映射假设可信域名为 abc.com假设电脑局域网 ip 为 192.168.1.106编辑 hosts 文件，将域名映射到电脑局域网 ip# 微信开发192.168.1.106 abc.com设置 Fiddlertools -&gt; optionshttps 相关设置代理相关设置，这里设置代理端口号为 8002，可以设置任意合法端口号修改 webpack 配置开启 httpshttps://webpack.js.org/configuration/dev-server/#devserverhttps本地服务端口号改成 443此时可在电脑浏览器通过 https://abc.com 访问本地服务修改手机代理进入手机 wlan 设置，选择连接的 wifi，代理选择手动主机名填电脑局域网 ip，端口填 Fiddler 代理设置中的端口号手机安装 Fiddler 证书手机浏览器访问 http://[电脑局域网ip]:[Fiddler 代理端口号]，这里是 http://192.168.1.106:8002点击下载 Fiddler 证书，进入手机 wlan 设置安装证书此时手机浏览器可通过 https://abc.com 访问电脑上的本地服务。结束"},{"id":"工作沉淀/GitFlow 笔记.md","filename":"GitFlow 笔记.md","basename":"GitFlow 笔记","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"简单记录工作中使用 gitflow 模型管理代码版本、保证代码安全的方法。参考文章：A successful Git branching modelGit 工作流程Git 分支管理策略git flow 的使用GitFlow 原理浅析gitflow 现在被认为过于复杂，可能不适用于现代软件开发：如何看待 Git flow 发明人称其不适用于持续交付？Issues with git-flow在阿里，我们如何管理代码分支？分支类型master只有一条主分支只读，只能从分支 release 或 hotfix 合并进来所有发生在 master 分支的修改应该打 tag 做记录，方便追溯develop只有一条主开发分支，基于 master 分支克隆包含所有要发布到下一个 release 的代码只读，只能从 feature 或 release 合并进来feature 功能分支完成开发后，合并到 develop，合并到 develop 前，提交合并申请，与 develop 分支进行比较做代码审查，审查通过则允许合并从 develop 拉取 release 分支，提测release 或 hotfix 分支上线完毕，合并回 develop。feature功能开发分支，基于 develop 分支克隆，主要用于新需求新功能的开发有多条，按功能划分，如：/feature/20200712-新增用户、/feature/20200801-登陆注册可以几个人一起开发一条 feature，也可以一人负责一条 feature功能开发完毕后，提测前，合并到 develop 分支feature 类型的分支可同时存在多个，用于团队中多个功能同时开发，属于临时分支，功能完成后可选择删除release版本分支，用于测试与上线，基于 feature 分支合并到 develop 之后，从 develop 分支克隆有多条，按版本划分，如：/release/20200712-第一版v0.1、/release/20200713-第二版v0.2release 类型的分支主要用于测试和修改 bug，完成上线后合并回 develop 与 master 分支hotfix补丁分支，基于 master 分支克隆，主要用于对线上的版本进行 BUG 修复有多条，按版本划分，如：/hotfix/20200712-修复xss漏洞、/hotfix/20200713-修复新增用户失败bug修复完毕后合并回 develop 与 master 分支主要工作流程示例初始化项目，创建 master 分支，然后从 master 拉取 develop 分支根据需求划分功能，从 develop 拉取 feature 分支进行编码开发，如/feature/20200712-新增用户、/feature/20200801-登陆注册feature 分支完成后，合并到 develop 前，提交合并申请，与 develop 比较，进行代码审查，合并完成可以选择删除当前 feature需要发布时，从 develop 拉取 release 分支进行测试，例如/release/20200712-第一版，测试过程中在该条 release 分支上修改 BUG，测试通过后将该条 release 分支发布回归：任一 release 分支通过测试上线后，合并该 release 分支到 develop 与 master，master 分支打 tag，当前 release 不可修改，线上有问题须从 master 拉取 hotfix 分支进行修改通知所有进行中的 feature、release 把 master 合进来一次上线之后若发现 bug，从 master 拉取 hotfix 进行 bug 修改，如/hotfix/20200713-修复新增用户失败bughotfix 通过测试上线后，合并 hotfix 分支到 develop 与 master，master 分支打 tag版本回退：如果需进行版本回退，则选择上一版本号的 release 分支进行发布"},{"id":"工作沉淀/Nginx 笔记.md","filename":"Nginx 笔记.md","basename":"Nginx 笔记","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"工作中经常用的，简单记录一下。实用跨域# 这里约定代理请求url path是以/apis/开头location ^~/apis/ {    # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配    rewrite ^/apis/(.*)$ /$1 break;    ...    proxy_pass https://www.tianqiapi.com/;}处理前端单页应用的 history 路由模式location / {    try_files $uri $uri/ /index.html;}适配 PC 和移动环境location / {    # 移动、pc设备适配    if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {        set $mobile_request &#x27;1&#x27;;    }    if ($mobile_request = &#x27;1&#x27;) {        rewrite ^.+ http://mysite-base-H5.com;    }}端口转发http {    ...    upstream dmp8001 {        server 127.0.0.1:8001;    }    server {        listen       80;        server_name  abc.com;        location / {            ...            proxy_pass http://dmp8001;        }    }    ...}善用正则# 动态校验企业微信 h5 应用可信域名location ~ WW_verify_(.*).txt {    return 200 $1;}虚拟主机server {    listen 12332;    server_name 127.0.0.1;    location / {        root D:/Desktop/test;        index index.html index.htm;    }}防媒体文件盗链location ~* \\.(gif|jpg|png|jpeg|mp4)$ {    expires 30d;    valid_referers *.hugao8.com www.hugao8.com m.hugao8.com *.baidu.com *.google.com;    if ($invalid_referer) {        rewrite ^/ http://ww4.sinaimg.cn/bmiddle/051bbed1gw1egjc4xl7srj20cm08aaa6.jpg;        # return 404;    }}简单实现负载均衡轮询（默认），请求过来后，Nginx 随机分配流量到任一服务器upstream backend {    server 127.0.0.1:3000;    server 127.0.0.1:3001;}weight=number 设置服务器的权重，默认为 1，权重大的会被优先分配upstream backend {    server 127.0.0.1:3000 weight=2;    server 127.0.0.1:3001 weight=1;}backup 标记为备份服务器。当主服务器不可用时，将传递与备份服务器的连接upstream backend {    server 127.0.0.1:3000 backup;    server 127.0.0.1:3001;}代理这个集群server {    listen      9000;    server_name localhost;    location / {        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Scheme $scheme;        proxy_pass backend;    }}关于 location 的匹配location 的几种匹配方式普通匹配：location = URI { configuration } #精确匹配location ^~ URI { configuration } #非正则匹配location [空格] URI { configuration } #前缀匹配正则匹配：location ~ URI { configuration } #区分大小写location ~* URI { configuration } #不区分大小写几种匹配方式的说明与优先级整体规则按照先普通匹配，然后再正则匹配，如果正则不匹配，则回退至上一个普通匹配。其中普通匹配没有顺序之分，哪个匹配最精确，就使用哪个 location，正则匹配按照规则的书写顺序进行。= 精确匹配，匹配后停止后续匹配，直接执行该匹配后的 configuration。[空格] 前缀匹配，匹配后，继续更长前缀匹配和正则匹配。^~ 不属于正则匹配，匹配该规则后，停止继续正则匹配。~ 区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。~* 不区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。示例location = / {    [ configuration A ]}location / {    [ configuration B ]}location /user/ {    [ configuration C ]}location ^~ /images/ {    [ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ {    [ configuration E ]}请求/精准匹配 A，不再往下查找。请求/index.html匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。请求/user/index.html匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。请求/user/1.jpg匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。请求/images/1.jpg匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。请求/documents/about.html匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。总结location 的配置有两种形式，普通和正则。查找匹配的时候，先查找普通，选择最长匹配项，再查找正则。正则的优先级高于普通。正则查找是按照在配置文件中的顺序进行的，因此正则顺序很重要，建议越精细的放的越靠前。使用=精准匹配可以加快查找的效率，如果经常被访问建议使用精确匹配=。"},{"id":"工作沉淀/动态校验企微应用可信域名.md","filename":"动态校验企微应用可信域名.md","basename":"动态校验企微应用可信域名","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"动态校验企微应用可信域名在企业微信后台创建自己的自建应用时，如应用页面需使用微信 JS-SDK、跳转小程序等，需完成域名归属验证，需要下载校验文件到自己服务器的根目录下，并能够通过 [自己的域名]/[校验文件名] 访问，以完成校验，如果有很多不同的企业需要安装你的应用，那么每一次安装都需要上传一遍校验文件，很麻烦，一次偶然，我将下载下来的校验文件打开，发现文件名与文件内容是有匹配的：也就是说，当企微请求 [自己的域名]/WW_verify_[随机串].txt 时，我们的服务器能将 随机串 响应给企微就可以通过校验，使用 nginx 的正则表达式能力，就可以轻松实现，匹配请求路径中 WW_verify_ 与 .txt 之间的内容，直接返回，location ~ WW_verify_(.*).txt {  return 200 $1;}这样在任何企业安装我们的应用时，只要填写的是我们的域名，就能直接点击确定通过可信域名校验，完全不需要上传校验文件了，大大减少了在不同企业安装应用的成本，非常舒服，已在公司的企微云客多项目中实践验证。"},{"id":"工作沉淀/工作中遇到问题汇总.md","filename":"工作中遇到问题汇总.md","basename":"工作中遇到问题汇总","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"配置 nginx 使用 location 前缀匹配，某些匹配有相同的前缀，流量转发到了后面的规则解决：前缀匹配后，会继续更长前缀匹配和正则匹配。可换成使用 ~ 来匹配，这是区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。小程序适配 iphonex 机型底部安全区域解决：padding-bottom: constant(safe-area-inset-bottom);后端返回的 id 是 number 类型，数字太大超出了 JavaScript 的数字安全范围，出现了精度丢失，拿到响应结果时最后两位变成了 0解决：后端修改类型为 string小程序: hideLoading 能把 toast 也隐藏掉https://developers.weixin.qq.com/community/develop/doc/00020212ec8200bc146731f2f51800https://developers.weixin.qq.com/community/develop/doc/000008d41284382afbf6bdf6051c00?_at=1572260036178导出 excel 跨域问题解决：BFF 层转发请求，转字节流（用 BFF 来请求这个文件，转成字节流给前端）css module 的局限性，无法准确预测类名// 例如这样的写法，使用了 css module 不会生效.parent {  color: red;}// 鼠标经过某个子节点想要修改父节点的样式.children {  &amp;:hover .parent {    color: yellow;  }}敏捷迭代遇到的一些问题bug 多，跟测时间长自测不够充分ui 验收时也会将 bug 加进来评估存在不足，后面赶工时，质量受影响省应用赛参赛作品，MySQL 数据库使用 utf8 编码格式 无法保存 emoji 表情解决：改成 utf8mb4是 MySQL 的一个历史遗留问题，utf8mb4 才是真正的 UTF-8在 MySQL 中，“utf8”编码只支持每个字符最多三个字节，中文是占 3 个字节，其他数字、英文、符号占一个字节而真正的 UTF-8 是每个字符最多四个字节，emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节MySQL 一直没有修复这个 bug，他们在 2010 年发布了一个叫作“utf8mb4”的字符集，巧妙的绕过了这个问题他们并没有对新的字符集广而告之（可能是因为这个 bug 让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用“utf8”，但这些建议都是错误的"},{"id":"工作沉淀/我的最佳实践.md","filename":"我的最佳实践.md","basename":"我的最佳实践","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"总结开发中常用的习惯和模式。参考https://isamatov.com/simple-tips-for-writing-clean-react-components/https://react-typescript-cheatsheet.netlify.app/https://juejin.im/post/5e021eb96fb9a01628014095Javascript先声明后调用声明变量优先使用 const常量大写不要忽略抛异常、不要忘了在 Promise\\async await 抛异常缓存耗时的计算，比如 dom 节点查找结果、设备信息查询结果等尽可能使用原生方法，因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，效率更高，比如 Array 的 filter少用 for-in，比其他循环方式明显要慢，因为 for-in 要搜索原型属性基于函数的迭代 forEach 比一般的循环要慢，如果对运行速度要求很严格，不要使用使用枚举或策略模式减少 elseif，使用 Map、Object 优化 switch-case?? 空值合并操作符、?. 链合并运算符少写 console（或提交代码时删除 console），善于利用浏览器或 IDE 自带的 debugger 工具来调试，项目跑起来一堆的日志让队友很头疼多元判断时，可将条件拼接成字符串存到 Object 里/** * 按钮点击事件 * @param {number} status 活动状态：1未开始 2进行中 3 结束 * @param {string} identity 身份标识：guest游客 admin管理员 */const onButtonClick = (status, identity) =&gt; {  if (identity == &#x27;guest&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  } else if (identity == &#x27;admin&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  }};// 可优化为const actions = new Map([  [    &#x27;guest_1&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;guest_2&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;guest_3&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;admin_1&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;admin_2&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;admin_3&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;default&#x27;,    () =&gt; {      /*do sth*/    },  ],]);/** * 按钮点击事件 * @param {string} identity 身份标识：guest游客 admin管理员 * @param {number} status 活动状态：1未开始 2进行中 3 结束 */const onButtonClick = (identity, status) =&gt; {  let action = actions.get(`${identity}_${status}`) || actions.get(&#x27;default&#x27;);  action.call(this);};可适当使用对象区分作用域使用 Array.includes 来优化多个条件的判断使用 Array.every 和 Array.some 来处理全部/部分满足条件减少嵌套，提前使用 return 语句用有意义且常用的单词命名变量// 错误：const yyyymmdstr = moment().format(&#x27;YYYY/MM/DD&#x27;);// 正确:const currentDate = moment().format(&#x27;YYYY/MM/DD&#x27;);保持统一命名可能同一个项目对于获取用户信息，会有三个不一样的命名，应该保持统一。// 错误：getUserInfo();getClientData();getCustomerRecord();// 正确：getUser();尽量少写魔法值，每个常量都该命名// 错误：// 三个月之后你还能知道 86400000 是什么吗?setTimeout(doSomeThing, 86400000);// 正确：const MILLISECOND_IN_A_DAY = 86400000;setTimeout(doSomeThing, MILLISECOND_IN_A_DAY);避免无意义的前缀如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。// 错误：const car = {  carMake: &#x27;Honda&#x27;,  carModel: &#x27;Accord&#x27;,  carColor: &#x27;Blue&#x27;,};function paintCar(car) {  car.carColor = &#x27;Red&#x27;;}// 正确：const car = {  make: &#x27;Honda&#x27;,  model: &#x27;Accord&#x27;,  color: &#x27;Blue&#x27;,};function paintCar(car) {  car.color = &#x27;Red&#x27;;}使用函数参数默认值// 错误：function doSomeThing(name) {  const username = name || &#x27;tony&#x27;;  // ...}// 正确：function doSomeThing(name = &#x27;tony&#x27;) {  // ...}参数越少越好如果参数超过两个，使用解构语法，不用考虑参数的顺序。// 错误：function createMenu(title, body, buttonText, cancellable) {  // ...}// 正确：function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#x27;Foo&#x27;,  body: &#x27;Bar&#x27;,  buttonText: &#x27;Baz&#x27;,  cancellable: true,});抽象重复代码很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数，要想优化重复代码需要有较强的抽象能力。不传 flag 参数不要通过 flag 的 true 或 false，来判断执行逻辑。不污染全局在 JavaScript 中不要污染全局，会容易产生难以预料的 bug。删除弃用代码可以在代码库历史版本中找到它。使用 class链式调用这种模式让的代码简洁优雅，在类的方法最后返回 this 就可以了。class Car {    constructor(make, model, color) {      this.make = make;      this.model = model;      this.color = color;    }    setMake(make) {      this.make = make;      return this;    }    setModel(model) {      this.model = model;      return this;    }    setColor(color) {      this.color = color;      return this;    }    save() {      console.log(this.make, this.model, this.color);      return this;    }}const car = new Car(&#x27;Ford&#x27;,&#x27;F-150&#x27;,&#x27;red&#x27;)  .setColor(&#x27;pink&#x27;);  .save();单一功能原则如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。封闭开放原则“当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码”比如我想修改一个公共组件的样式来适配自己的页面，但又需要保证其他使用这个组件的页面不受影响，可以通过增加一个主题参数，根据该参数加载一份新的样式文件React定义类组件时，使用 PropTypes 对属性进行类型检查和赋予默认值（deprecate）组件属性超过 3 个则换行多用函数组件，更小的打包体积，更高的执行效率多用 PureComponent，PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责react 组件文件用 jsx，用大驼峰命名 jsx 文件表达式中的 jsx 使用圆括号包裹每个文件只写一个组件，但是多个无状态组件可以放在单个文件中，文件名要与默认导出的类名一致组合优于继承性能原因尽量不写内联函数，比如点击事件封装切换类型的组件时，使用一个配置数组来减少判断（策略模式）多使用解构，例如声明函数组件的 props 和 默认值export default ({ name = &#x27;小明&#x27;, sex = &#x27;男&#x27; }) =&gt; (  &lt;&gt;    我叫 {name}，性别 {sex}  &lt;/&gt;);没有子元素的组件写成自闭合// 错误：&lt;Foo&gt;&lt;/Foo&gt;// 正确：&lt;Foo/&gt;组件属性命名保持统一，使兼容性良好，避免无意义前缀// 错误，心塞&lt;MyInput inputValue onInputChange wrapStyle wrapClassName /&gt;// 正确&lt;MyInput value onChange style className /&gt;避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render// 错误：render() {    const obj = {num: 1}    return (        &lt;Child obj={obj} onClick={()=&gt;{...}} /&gt;    );}避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现// 错误：render() {    const a = 8;    return (        &lt;div&gt;            {                a &gt; 0 ? a &lt; 9 ? ... : ... : ...            }        &lt;/div&gt;    );}// 正确：f() {    ...}render() {    const a = 8;    return (        &lt;div&gt;            {                this.f()            }        &lt;/div&gt;    );}使用运算符&amp;&amp;简化三元运算在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false，因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。例如：{  loading ? &lt;Loading /&gt; : null;}可简化为{  loading &amp;&amp; &lt;Loading /&gt;;}尽量避免使用展开运算符来展开 props变得难以理解和维护，容易出 bug遇到事件处理，使用一个返回新函数的方法例如：import React from &#x27;react&#x27;;export default function SampleComponent({ onValueChange }) {  const handleChange = (key) =&gt; {    return (e) =&gt; onValueChange(key, e.target.value);  };  return (    &lt;form&gt;      &lt;input onChange={handleChange(&#x27;name&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;email&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;phone&#x27;)} /&gt;    &lt;/form&gt;  );}这样看起来比较简洁使用 Hook components比如要封装一个弹窗组件：// 组件import React, { useCallback, useState } from &#x27;react&#x27;;import ConfirmationDialog from &#x27;components/global/ConfirmationDialog&#x27;;export default function useConfirmationDialog({ headerText, bodyText, confirmationButtonText, onConfirmClick }) {  const [isOpen, setIsOpen] = useState(false);  const onOpen = () =&gt; {    setIsOpen(true);  };  const Dialog = useCallback(    () =&gt; (      &lt;ConfirmationDialog        headerText={headerText}        bodyText={bodyText}        isOpen={isOpen}        onConfirmClick={onConfirmClick}        onCancelClick={() =&gt; setIsOpen(false)}        confirmationButtonText={confirmationButtonText}      /&gt;    ),    [isOpen]  );  return {    Dialog,    onOpen,  };}// 使用import React from &#x27;react&#x27;;import { useConfirmationDialog } from &#x27;./useConfirmationDialog&#x27;;function Client() {  const { Dialog, onOpen } = useConfirmationDialog({    headerText: &#x27;Delete this record?&#x27;,    bodyText: &#x27;Are you sure you want delete this record? This cannot be undone.&#x27;,    confirmationButtonText: &#x27;Delete&#x27;,    onConfirmClick: handleDeleteConfirm,  });  function handleDeleteConfirm() {}  const handleDeleteClick = () =&gt; {    onOpen();  };  return (    &lt;div&gt;      &lt;Dialog /&gt;      &lt;button onClick={handleDeleteClick} /&gt;    &lt;/div&gt;  );}export default Client;这种模式可以少写很多与组件相关的 state，比如弹窗的 visible、title 之类的将业务逻辑封装进 hooks，业务逻辑与 UI 分离（关注点分离）// 例如：import React from &#x27;react&#x27;;import ItemDisplay from &#x27;./ItemDisplay&#x27;;export default function SampleComponent() {  const { data, handleDelete, handleEdit, handleAdd } = useCustomHook();  return (    &lt;div&gt;      &lt;div&gt;        {data.map((item) =&gt; (          &lt;ItemDisplay item={item} /&gt;        ))}      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={handleDelete} /&gt;        &lt;button onClick={handleAdd} /&gt;        &lt;button onClick={handleEdit} /&gt;      &lt;/div&gt;    &lt;/div&gt;  );}不要把所有状态存放在 redux，redux 只用于存放用户登录信息、主题等信息不要任何变量都使用状态，可以使用 useRef 或成员属性（类组件）来储存与更新渲染无关的变量，可以通过已保存的状态来推断出的状态可使用 useMemo 来计算，而不要创建新状态尽量不要在组件中声明新的组件// 错误，不建议function A() {  const B = () =&gt; {    return &lt;p&gt;hello&lt;/p&gt;;  };  return (    &lt;div&gt;      &lt;B /&gt;    &lt;/div&gt;  );}原因：高耦合影响性能，A 每一次渲染都会重新声明一遍 B尽量避免向组件传递避免为了优化少量性能过度设计代码，反而降低了代码的可维护性、易读性，浪费时间Typescript接口命名以大写字母“I”开头，来自：http://wiki.eclipse.org/Naming_Conventions#Classes_and_Interfaces少写 any类型定义文件(.d.ts)如何放置临时的类型，直接在使用时定义组件个性化类型，直接定义在 ts(x)文件中范围/全局数据，定义在.d.ts 文件中其他移除生产环境的控制台打印开发环境 node 和 npm 版本需要一致，因为不同版本 npm 行为不一样第三方库的按需加载"},{"id":"工作沉淀/敏捷迭代.md","filename":"敏捷迭代.md","basename":"敏捷迭代","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"敏捷模型总览敏捷模型组织架构客户化小组专项+小车道小组组建与职责"},{"id":"工作沉淀/登录方案.md","filename":"登录方案.md","basename":"登录方案","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"登录方案方案一：仅 jwt后端直接签发 jwt，后端不存储缺点：一旦下发，后端无法拒绝携带该 jwt 的请求，无法踢除用户方案二：jwt + redis后端备份一份 token 存入 redis，请求进来时，使用前端传来的 jwt 从 redis 查询出对应 token，做对比，若 redis 中的 token 过期或不存在则视为无权限方案三：长短 token首次登录设置两个 token，都保存进 redisaccess_token：标准 JWT 格式，即请求时的授权令牌，过期时间较短，一般 2 个小时，redis key：uuid-access，value：jwtrefresh_token：用于刷新 access_token，过期时间较长，一般 1 个月，redis key：uuid-refresh，value：jwt添加凭 refresh_token 刷新 access_token 的接口前端请求封装先发起请求，如果接口返回 access_token 过期，先刷新 access_token，再进行一次重试为了让活跃用户保持登录，其他方案频繁续签会有性能问题，该方案解决此问题问题前端请求刷新 token 有延迟，如何防止多次请求同时发起多次刷新 token请求封装中设置刷新 token 防抖锁，如果一次刷新任务进行中，则其他刷新请求取消同时发起多个请求时，access_token 正好过期，同时多次提示无权限请求封装中，如果刷新 token 锁处于关闭状态，则把请求任务保存进一个数组，等待锁打开再执行哈希加盐密码保存哈希函数单向不可逆加密算法直接哈希的缺陷有可能被查表法、逆向查表法、彩虹表等方式破解首先将一些比较常用的密码的哈希值算好，然后建立一张表，当然密码越多，这张表就越大。当你知道某个密码的哈希值时，你只需要在你建立好的表中查找该哈希值，如果找到了，你就知道对应的密码了加盐盐就是一个随机生成的字符串将盐与原始密码连接在一起（前或后都可以），然后将连接后的字符串加密盐和加密后的密码一起保存进数据库登录时将盐和密码都查出来，前端传来的密码同样算法加密后进行比对直接 md5 加密保存（我毕业设计的做法）也是一种不可逆加密算法，输入任意长度的信息，经过处理，输出都是 128 位的信息值小于 8 位的密码用 md5 加密都很不安全可以破解，至于原因，做为前端开发我暂时没有继续探究缺点为什么不能用用户 id 当做盐用户 id 有可能是会变的，用户 id 一旦有变，登录时计算出来的结果就会不一样"},{"id":"工作沉淀/设计稿多端适配方案.md","filename":"设计稿多端适配方案.md","basename":"设计稿多端适配方案","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"问题如何让不同尺寸的屏幕能以正常比例呈现设计稿方案动态修改 html 标签 font-size，样式单位统一用 rem，数值为设计稿尺寸除以 basevar fn = function () {  var designWidth = 1920; // 设计稿尺寸  var base = 16; // 1rem 的占比，不要小于 12  var html = document.getElementsByTagName(&#x27;html&#x27;)[0];  var clientWidth = document.body.clientWidth || document.documentElement.clientWidth;  html.style.fontSize = (clientWidth / designWidth) * base + &#x27;px&#x27;;};document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () {  fn();});window.onresize = function () {  fn();};dpr 是什么设备像素比，通过 window.devicePixelRatio 获取是设备上物理像素和设备独立像素（dips）的比例，window.devicePixelRatio = 物理像素 / dips简单的讲其实就是 dpr 决定了 css 1px 等于多少屏幕物理像素物理像素显示器上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值设备独立像素（dips）也叫密度无关像素，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素（比如: css 像素），然后由相关系统转换为物理像素viewport用于定义视口的各种行为：视口宽度、初始缩放、最小最大缩放比例、是否允许用户手动缩放"}]},{"id":"其他笔记","dirname":"其他笔记","filename":"","basename":"","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","children":[{"id":"其他笔记/Fiber.md","filename":"Fiber.md","basename":"Fiber","path":"/home/runner/work/my-book/my-book/其他笔记","relative_path":"其他笔记","output_path":"/home/runner/work/my-book/my-book/dist/其他笔记","content":"未完待续Fiber是 React 核心算法的重新实现，是 React 团队两年多研究的结晶，是对 reconciliation 的重新编写，重新实现了 reconciler（协调器）目标是提高其对动画、布局和手势等领域的适用性允许将更新分解成更小的任务，达到增量渲染，将渲染工作拆分为块并将其分散到多个帧上，更新不会长时间阻止主线程（比如用户输入，动画之类）其他主要功能包括能够在新更新到来时暂停，中止或重用工作注意：并不会减少总工作量或更新所需的时间为什么 Fiber旧版 React 在处理 UI 时，使用栈递归遍历树结构，整个过程同步无法被打断，如果树结构太大层级很深，会一直占用浏览器主线程，可能导致动画丢帧，看起来断断续续（JS 线程和 GUI 线程是互斥的）改变了之前 react 的组件渲染机制，新的架构使原来同步渲染的组件可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程，保证任务在浏览器空闲的时候执行Fiber 架构思想浏览器现有 api：requestIdleCallback （闲时调用）来实现异步渲染，但 React 为了照顾绝大多数的浏览器，自己实现了 requestIdleCallback两个阶段：Reconciliation 与 Commit。Reconciliation 阶段对应早期版本的 diff 过程，Commit 阶段对应早期版本的 patch 过程，以 render 为界阶段一（Reconciliation）：生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率阶段二（Commit）：需要更新的节点一次过批量更新，这个过程不能被打断Reconciliation 如果遇到更高优先级事件，则进行打断，渲染到一半的组件，会从头开始渲染，在 Reconciliation 阶段，一些生命周期可能会重新执行，例如componentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate这些生命周期函数则会在 Commit 阶段调用componentDidMountcomponentDidUpdatecomponentWillUnmountFiber 树React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复workInProgress Fiber 树在 React 中最多会同时存在两棵 Fiber 树，当前显示在页面是 current Fiber 树，在内存中构建的 Fiber 树称为 workInProgress Fiber 树，workingProgress Fiber 这棵树是在内存中构建的，构建完成才统一替换，这样不会产生不完全的真实 dom。一旦更新完成，react 会直接将 current 树替换成 workingProgress Fiber 树，以便快速完成 DOM 的更新。也是 react 提升性能的一部分Fiber 数据结构interface FiberNode {  stateNode: any; // 节点实例  child: any; // 子节点  sibling: any; // 兄弟节点  return: any; // 父节点}Fiber 为什么使用链表React 使用单链表树遍历算法实现在没有递归的情况下遍历树，树形结构并不满足中途暂停对异步友好，它使暂停遍历并使阻止堆栈增长成为可能目前的虚拟 DOM 是树结构，当任务被打断后，树结构无法恢复之前的任务继续执行，所以需要一种新的数据结构，即链表，链表可以包含多个指针，可以轻易找到下一个节点，继而恢复任务的执行Fiber 采用的链表中包含三个指针，parent 指向其父 Fiber 节点，child 指向其子 Fiber 节点，sibling 指向其兄弟 Fiber 节点。一个 Fiber 节点对应一个任务节点Fiber 为什么深度优先查找 context 的消费节点，当 context 改变之后, 需要找出依赖该 context 的所有子节点"},{"id":"其他笔记/函数式编程.md","filename":"函数式编程.md","basename":"函数式编程","path":"/home/runner/work/my-book/my-book/其他笔记","relative_path":"其他笔记","output_path":"/home/runner/work/my-book/my-book/dist/其他笔记","content":"函数式编程是什么函数式编程是一种编程范式，目标是使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变，旨在尽可能地提高代码的无状态性和不变性主要思想是把运算过程尽量写成一系列嵌套的函数调用，比如柯里化、react 的高阶函数函数式库：Ramda.js、lodash、RxJS命令模式中 run 函数的好处将函数本身参数化，非侵入式的修改函数，无需重写任何内部逻辑为什么纯函数易于维护：无状态的代码不会改变或破坏全局的状态易于测试：不依赖外部资源的算法灵活便于重用、保持业务逻辑代码的纯净任务分解，一定程度增加代码可读性函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的"},{"id":"其他笔记/浏览器架构.md","filename":"浏览器架构.md","basename":"浏览器架构","path":"/home/runner/work/my-book/my-book/其他笔记","relative_path":"其他笔记","output_path":"/home/runner/work/my-book/my-book/dist/其他笔记","content":"参考：https://juejin.cn/post/6844904046411644941https://zhuanlan.zhihu.com/p/149063367浏览器架构（以 chrome 为例）各个进程以及负责的工作chrome 采用多进程架构Browser（主进程）浏览器界面显示，用户交互，前进、后退、收藏前进和后退按钮同时这个进程还会控制那些我们看不见的部分，包括网络请求的发送以及文件的读写协调控制其他子进程（创建、销毁）Plugin控制网页使用的所有插件，例如 flash 插件每种类型的插件对应一个进程，仅当使用该插件时才创建GPU3D 绘制，负责独立于其它进程的 GPU 任务。它之所以被独立为一个进程是因为它要处理来自于不同 tab 的渲染请求并把它在同一个界面上画出来Renderer（渲染进程），最重要渲染进程，即浏览器内核这就是主要与前端开发打交道的进程，负责页面渲染，脚本执行，事件处理等负责 tab 内和网页展示相关的所有工作。Chrome 会尽可能为每一个 tab 甚至是页面里面的每一个 iframe 都分配一个单独的渲染进程渲染进程渲染进程包含几大类子线程：GUI 渲染线程负责渲染页面，布局和绘制页面需要重绘和回流时，该线程就会执行与 js 引擎线程互斥，防止渲染结果不可预期JS 引擎线程负责处理解析和执行 javascript 脚本程序只有一个 JS 引擎线程（单线程）与 GUI 渲染线程互斥，防止渲染结果不可预期事件触发线程用来控制事件循环当事件满足触发条件时，将事件放入到 JS 引擎所在的执行队列中定时器线程setInterval 与 setTimeout 所在的线程定时任务并不是由 JS 引擎计时的，是由定时触发线程来计时的计时完毕后，通知事件触发线程异步网络请求线程浏览器有一个单独的线程用于处理 AJAX 请求当请求完成时，若有回调函数，通知事件触发线程其中 GUI 线程和 JS 引擎线程是互斥的，由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致一个 tab 一个渲染进程的优缺点优点：提供安全性和沙盒性，当其中一个 tab 的崩溃时，你可以随时关闭这个 tab 并且其他 tab 不受到影响缺点：内存消耗大网站隔离功能会为网站内不同站点的 iframe 分配一个独立的渲染进程由来：如果一个 tab 只有一个进程的话不同站点的 iframe 都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略常见浏览器内核IE：Trident 内核，也是俗称的 IE 内核Chrome：以前是 Webkit 内核，现在是 Blink 内核Firefox：Gecko 内核苹果 Safari：Webkit 内核"}]},{"id":"index.md","filename":"index.md","basename":"index","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","content":"✒工作与日常学习笔记via：doc-builder"}]