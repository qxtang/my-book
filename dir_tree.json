[{"id":"工作沉淀","dirname":"工作沉淀","filename":"","basename":"","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","children":[{"id":"工作沉淀/Fiddler 真机调试微信 h5.md","filename":"Fiddler 真机调试微信 h5.md","basename":"Fiddler 真机调试微信 h5","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"需求：真机上通过 https 和微信可信域名访问本地服务前提条件手机和电脑处在同一局域网环境电脑安装 Fiddler本地 hosts 文件添加映射假设可信域名为 abc.com假设电脑局域网 ip 为 192.168.1.106编辑 hosts 文件，将域名映射到电脑局域网 ip# 微信开发192.168.1.106 abc.com设置 Fiddlertools -&gt; optionshttps 相关设置代理相关设置，这里设置代理端口号为 8002，可以设置任意合法端口号修改 webpack 配置开启 httpshttps://webpack.js.org/configuration/dev-server/#devserverhttps本地服务端口号改成 443此时可在电脑浏览器通过 https://abc.com 访问本地服务修改手机代理进入手机 wlan 设置，选择连接的 wifi，代理选择手动主机名填电脑局域网 ip，端口填 Fiddler 代理设置中的端口号手机安装 Fiddler 证书手机浏览器访问 http://[电脑局域网ip]:[Fiddler 代理端口号]，这里是 http://192.168.1.106:8002点击下载 Fiddler 证书，进入手机 wlan 设置安装证书此时手机浏览器可通过 https://abc.com 访问电脑上的本地服务。结束"},{"id":"工作沉淀/GitFlow 学习笔记.md","filename":"GitFlow 学习笔记.md","basename":"GitFlow 学习笔记","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"简单记录工作中使用 gitflow 模型管理代码版本、保证代码安全的方法。参考文章：A successful Git branching modelGit 工作流程Git 分支管理策略git flow 的使用GitFlow 原理浅析gitflow 现在被认为过于复杂，可能不适用于现代软件开发：如何看待 Git flow 发明人称其不适用于持续交付？Issues with git-flow在阿里，我们如何管理代码分支？分支类型master只有一条主分支只读，只能从分支 release 或 hotfix 合并进来所有发生在 master 分支的修改应该打 tag 做记录，方便追溯develop只有一条主开发分支，基于 master 分支克隆包含所有要发布到下一个 release 的代码只读，只能从 feature 或 release 合并进来feature 功能分支完成开发后，合并到 develop，合并到 develop 前，提交合并申请，与 develop 分支进行比较做代码审查，审查通过则允许合并从 develop 拉取 release 分支，提测release 或 hotfix 分支上线完毕，合并回 develop。feature功能开发分支，基于 develop 分支克隆，主要用于新需求新功能的开发有多条，按功能划分，如：/feature/20200712-新增用户、/feature/20200801-登陆注册可以几个人一起开发一条 feature，也可以一人负责一条 feature功能开发完毕后，提测前，合并到 develop 分支feature 类型的分支可同时存在多个，用于团队中多个功能同时开发，属于临时分支，功能完成后可选择删除release版本分支，用于测试与上线，基于 feature 分支合并到 develop 之后，从 develop 分支克隆有多条，按版本划分，如：/release/20200712-第一版v0.1、/release/20200713-第二版v0.2release 类型的分支主要用于测试和修改 bug，完成上线后合并回 develop 与 master 分支hotfix补丁分支，基于 master 分支克隆，主要用于对线上的版本进行 BUG 修复有多条，按版本划分，如：/hotfix/20200712-修复xss漏洞、/hotfix/20200713-修复新增用户失败bug修复完毕后合并回 develop 与 master 分支主要工作流程示例初始化项目，创建 master 分支，然后从 master 拉取 develop 分支根据需求划分功能，从 develop 拉取 feature 分支进行编码开发，如/feature/20200712-新增用户、/feature/20200801-登陆注册feature 分支完成后，合并到 develop 前，提交合并申请，与 develop 比较，进行代码审查，合并完成可以选择删除当前 feature需要发布时，从 develop 拉取 release 分支进行测试，例如/release/20200712-第一版，测试过程中在该条 release 分支上修改 BUG，测试通过后将该条 release 分支发布回归：任一 release 分支通过测试上线后，合并该 release 分支到 develop 与 master，master 分支打 tag，当前 release 不可修改，线上有问题须从 master 拉取 hotfix 分支进行修改通知所有进行中的 feature、release 把 master 合进来一次上线之后若发现 bug，从 master 拉取 hotfix 进行 bug 修改，如/hotfix/20200713-修复新增用户失败bughotfix 通过测试上线后，合并 hotfix 分支到 develop 与 master，master 分支打 tag版本回退：如果需进行版本回退，则选择上一版本号的 release 分支进行发布"},{"id":"工作沉淀/Nginx 学习笔记.md","filename":"Nginx 学习笔记.md","basename":"Nginx 学习笔记","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"工作中经常用的，简单记录一下。实用跨域# 这里约定代理请求url path是以/apis/开头location ^~/apis/ {    # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配    rewrite ^/apis/(.*)$ /$1 break;    ...    proxy_pass https://www.tianqiapi.com/;}处理前端单页应用的 history 路由模式location / {    try_files $uri $uri/ /index.html;}适配 PC 和移动环境location / {    # 移动、pc设备适配    if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) {        set $mobile_request &#x27;1&#x27;;    }    if ($mobile_request = &#x27;1&#x27;) {        rewrite ^.+ http://mysite-base-H5.com;    }}端口转发http {    ...    upstream dmp8001 {        server 127.0.0.1:8001;    }    server {        listen       80;        server_name  abc.com;        location / {            ...            proxy_pass http://dmp8001;        }    }    ...}善用正则# 动态校验企业微信 h5 应用可信域名location ~ WW_verify_(.*).txt {    return 200 $1;}虚拟主机server {    listen 12332;    server_name 127.0.0.1;    location / {        root D:/Desktop/test;        index index.html index.htm;    }}防媒体文件盗链location ~* \\.(gif|jpg|png|jpeg|mp4)$ {    expires 30d;    valid_referers *.hugao8.com www.hugao8.com m.hugao8.com *.baidu.com *.google.com;    if ($invalid_referer) {        rewrite ^/ http://ww4.sinaimg.cn/bmiddle/051bbed1gw1egjc4xl7srj20cm08aaa6.jpg;        # return 404;    }}简单实现负载均衡轮询（默认），请求过来后，Nginx 随机分配流量到任一服务器upstream backend {    server 127.0.0.1:3000;    server 127.0.0.1:3001;}weight=number 设置服务器的权重，默认为 1，权重大的会被优先分配upstream backend {    server 127.0.0.1:3000 weight=2;    server 127.0.0.1:3001 weight=1;}backup 标记为备份服务器。当主服务器不可用时，将传递与备份服务器的连接upstream backend {    server 127.0.0.1:3000 backup;    server 127.0.0.1:3001;}代理这个集群server {    listen      9000;    server_name localhost;    location / {        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Scheme $scheme;        proxy_pass backend;    }}关于 location 的匹配location 的几种匹配方式普通匹配：location = URI { configuration } #精确匹配location ^~ URI { configuration } #非正则匹配location [空格] URI { configuration } #前缀匹配正则匹配：location ~ URI { configuration } #区分大小写location ~* URI { configuration } #不区分大小写几种匹配方式的说明与优先级整体规则按照先普通匹配，然后再正则匹配，如果正则不匹配，则回退至上一个普通匹配。其中普通匹配没有顺序之分，哪个匹配最精确，就使用哪个 location，正则匹配按照规则的书写顺序进行。= 精确匹配，匹配后停止后续匹配，直接执行该匹配后的 configuration。[空格] 前缀匹配，匹配后，继续更长前缀匹配和正则匹配。^~ 不属于正则匹配，匹配该规则后，停止继续正则匹配。~ 区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。~* 不区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。示例location = / {    [ configuration A ]}location / {    [ configuration B ]}location /user/ {    [ configuration C ]}location ^~ /images/ {    [ configuration D ]}location ~* \\.(gif|jpg|jpeg)$ {    [ configuration E ]}请求/精准匹配 A，不再往下查找。请求/index.html匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。请求/user/index.html匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。请求/user/1.jpg匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。请求/images/1.jpg匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。请求/documents/about.html匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。总结location 的配置有两种形式，普通和正则。查找匹配的时候，先查找普通，选择最长匹配项，再查找正则。正则的优先级高于普通。正则查找是按照在配置文件中的顺序进行的，因此正则顺序很重要，建议越精细的放的越靠前。使用=精准匹配可以加快查找的效率，如果经常被访问建议使用精确匹配=。"},{"id":"工作沉淀/动态校验企微应用可信域名.md","filename":"动态校验企微应用可信域名.md","basename":"动态校验企微应用可信域名","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"动态校验企微应用可信域名在企业微信后台创建自己的自建应用时，如应用页面需使用微信 JS-SDK、跳转小程序等，需完成域名归属验证，需要下载校验文件到自己服务器的根目录下，并能够通过 [自己的域名]/[校验文件名] 访问，以完成校验，如果有很多不同的企业需要安装你的应用，那么每一次安装都需要上传一遍校验文件，很麻烦，一次偶然，我将下载下来的校验文件打开，发现文件名与文件内容是有匹配的：也就是说，当企微请求 [自己的域名]/WW_verify_[随机串].txt 时，我们的服务器能将 随机串 响应给企微就可以通过校验，使用 nginx 的正则表达式能力，就可以轻松实现，将请求路径中 WW_verify_ 与 .txt 之间的内容返回，location ~ WW_verify_(.*).txt {    return 200 $1;}这样在任何企业安装我们的应用时，只要填写的是我们的域名，就能直接点击确定通过可信域名校验，完全不需要上传校验文件了，非常舒服，已经在公司的企微云客多项目中实践验证。"},{"id":"工作沉淀/工作中遇到问题汇总.md","filename":"工作中遇到问题汇总.md","basename":"工作中遇到问题汇总","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"换行符不同导致大量冲突解决：使用 git 钩子在提交时统一风格配置 nginx 使用 location 前缀匹配，流量转发到了后面的规则解决：前缀匹配后，会继续更长前缀匹配和正则匹配。可换成使用 ~ 来匹配，这是区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。图片被盗链解决：nginx 添加白名单小程序适配 iphonex 机型底部安全区域解决：padding-bottom: constant(safe-area-inset-bottom);后端返回的 id 是 number 类型，数字太大超出了 JavaScript 的数字安全范围，出现了精度丢失，拿到响应结果时最后两位变成了 0解决：后端修改类型为 string小程序: hideLoading 能把 toast 也隐藏掉下载跨域问题解决：BFF 层转发请求，转字节流（用 BFF 来请求这个文件，转成字节流给前端）css module 的局限性，无法准确预测类名// 例如这样的写法，使用了 css module 不会生效.parent {  color: red;}// 鼠标经过某个子节点想要修改父节点的样式.children {  &amp;:hover .parent {    color: yellow;  }}敏捷迭代遇到的一些问题bug 多，跟测时间长自测不够充分ui 验收时也会将 bug 加进来评估存在不足，后面赶工时，质量受影响开发毕业设计系统时，MySQL 数据库使用 utf8 编码格式 无法保存 emoji 表情解决：改成 utf8mb4是 MySQL 的一个历史遗留问题，utf8mb4 才是真正的 UTF-8在 MySQL 中，“utf8”编码只支持每个字符最多三个字节，中文是占 3 个字节，其他数字、英文、符号占一个字节而真正的 UTF-8 是每个字符最多四个字节，emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节MySQL 一直没有修复这个 bug，他们在 2010 年发布了一个叫作“utf8mb4”的字符集，巧妙的绕过了这个问题他们并没有对新的字符集广而告之（可能是因为这个 bug 让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用“utf8”，但这些建议都是错误的"},{"id":"工作沉淀/我的最佳实践.md","filename":"我的最佳实践.md","basename":"我的最佳实践","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"总结开发中常用的习惯和模式。参考Simple tips for writing clean React componentsReact TypeScript CheatsheetJavaScript 设计模式Javascript先声明后调用声明变量优先使用 const常量大写不要忽略抛异常、不要忘了在 Promise\\async await 抛异常缓存耗时的计算，比如 dom 节点查找结果、设备信息查询结果等尽可能使用原生方法，因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，效率更高，比如 Array 的 filter少用 for-in，比其他循环方式明显要慢，因为 for-in 要搜索原型属性基于函数的迭代 forEach 比一般的循环要慢，如果对运行速度要求很严格，不要使用使用枚举或策略模式减少 elseif，使用 Map、Object 优化 switch-case?? 空值合并操作符、?. 链合并运算符少写 console（或提交代码时删除 console），善于利用浏览器或 IDE 自带的 debugger 工具来调试，项目跑起来一堆的日志让队友很头疼多元判断时，可将条件拼接成字符串存到 Object 里/** * 按钮点击事件 * @param {number} status 活动状态：1未开始 2进行中 3 结束 * @param {string} identity 身份标识：guest游客 admin管理员 */const onButtonClick = (status, identity) =&gt; {  if (identity == &#x27;guest&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  } else if (identity == &#x27;admin&#x27;) {    if (status == 1) {      //do sth    } else if (status == 2) {      //do sth    } else if (status == 3) {      //do sth    } else {      //do sth    }  }};// 可优化为const actions = new Map([  [    &#x27;guest_1&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;guest_2&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;guest_3&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;admin_1&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;admin_2&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;admin_3&#x27;,    () =&gt; {      /*do sth*/    },  ],  [    &#x27;default&#x27;,    () =&gt; {      /*do sth*/    },  ],]);/** * 按钮点击事件 * @param {string} identity 身份标识：guest游客 admin管理员 * @param {number} status 活动状态：1未开始 2进行中 3 结束 */const onButtonClick = (identity, status) =&gt; {  let action = actions.get(`${identity}_${status}`) || actions.get(&#x27;default&#x27;);  action.call(this);};可适当使用对象区分作用域使用 Array.includes 来优化多个条件的判断使用 Array.every 和 Array.some 来处理全部/部分满足条件减少嵌套，提前使用 return 语句用有意义且常用的单词命名变量// 错误：const yyyymmdstr = moment().format(&#x27;YYYY/MM/DD&#x27;);// 正确:const currentDate = moment().format(&#x27;YYYY/MM/DD&#x27;);保持统一命名可能同一个项目对于获取用户信息，会有三个不一样的命名，应该保持统一。// 错误：getUserInfo();getClientData();getCustomerRecord();// 正确：getUser();尽量少写魔法值，每个常量都该命名// 错误：// 三个月之后你还能知道 86400000 是什么吗?setTimeout(doSomeThing, 86400000);// 正确：const MILLISECOND_IN_A_DAY = 86400000;setTimeout(doSomeThing, MILLISECOND_IN_A_DAY);避免无意义的前缀如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。// 错误：const car = {  carMake: &#x27;Honda&#x27;,  carModel: &#x27;Accord&#x27;,  carColor: &#x27;Blue&#x27;,};function paintCar(car) {  car.carColor = &#x27;Red&#x27;;}// 正确：const car = {  make: &#x27;Honda&#x27;,  model: &#x27;Accord&#x27;,  color: &#x27;Blue&#x27;,};function paintCar(car) {  car.color = &#x27;Red&#x27;;}使用函数参数默认值// 错误：function doSomeThing(name) {  const username = name || &#x27;tony&#x27;;  // ...}// 正确：function doSomeThing(name = &#x27;tony&#x27;) {  // ...}参数越少越好如果参数超过两个，使用解构语法，不用考虑参数的顺序。// 错误：function createMenu(title, body, buttonText, cancellable) {  // ...}// 正确：function createMenu({ title, body, buttonText, cancellable }) {  // ...}createMenu({  title: &#x27;Foo&#x27;,  body: &#x27;Bar&#x27;,  buttonText: &#x27;Baz&#x27;,  cancellable: true,});抽象重复代码很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数，要想优化重复代码需要有较强的抽象能力。不传 flag 参数不要通过 flag 的 true 或 false，来判断执行逻辑。不污染全局在 JavaScript 中不要污染全局，会容易产生难以预料的 bug。删除弃用代码可以在代码库历史版本中找到它。使用 class链式调用这种模式让的代码简洁优雅，在类的方法最后返回 this 就可以了。class Car {    constructor(make, model, color) {      this.make = make;      this.model = model;      this.color = color;    }    setMake(make) {      this.make = make;      return this;    }    setModel(model) {      this.model = model;      return this;    }    setColor(color) {      this.color = color;      return this;    }    save() {      console.log(this.make, this.model, this.color);      return this;    }}const car = new Car(&#x27;Ford&#x27;,&#x27;F-150&#x27;,&#x27;red&#x27;)  .setColor(&#x27;pink&#x27;);  .save();单一功能原则如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。封闭开放原则“当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码”比如我想修改一个公共组件的样式来适配自己的页面，但又需要保证其他使用这个组件的页面不受影响，可以通过增加一个主题参数，根据该参数加载一份新的样式文件React定义类组件时，使用 PropTypes 对属性进行类型检查和赋予默认值（deprecate）组件属性超过 3 个则换行多用函数组件，更小的打包体积，更高的执行效率多用 PureComponent，PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责react 组件文件用 jsx，用大驼峰命名 jsx 文件表达式中的 jsx 使用圆括号包裹每个文件只写一个组件，但是多个无状态组件可以放在单个文件中，文件名要与默认导出的类名一致组合优于继承性能原因尽量不写内联函数，比如点击事件封装切换类型的组件时，使用一个配置数组来减少判断（策略模式）多使用解构，例如声明函数组件的 props 和 默认值export default ({ name = &#x27;小明&#x27;, sex = &#x27;男&#x27; }) =&gt; (  &lt;&gt;    我叫 {name}，性别 {sex}  &lt;/&gt;);没有子元素的组件写成自闭合// 错误：&lt;Foo&gt;&lt;/Foo&gt;// 正确：&lt;Foo/&gt;组件属性命名保持统一，使兼容性良好，避免无意义前缀// 错误，心塞&lt;MyInput inputValue onInputChange wrapStyle wrapClassName /&gt;// 正确&lt;MyInput value onChange style className /&gt;避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render// 错误：render() {    const obj = {num: 1}    return (        &lt;Child obj={obj} onClick={()=&gt;{...}} /&gt;    );}避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现// 错误：render() {    const a = 8;    return (        &lt;div&gt;            {                a &gt; 0 ? a &lt; 9 ? ... : ... : ...            }        &lt;/div&gt;    );}// 正确：f() {    ...}render() {    const a = 8;    return (        &lt;div&gt;            {                this.f()            }        &lt;/div&gt;    );}使用运算符&amp;&amp;简化三元运算在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false，因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。例如：{  loading ? &lt;Loading /&gt; : null;}可简化为{  loading &amp;&amp; &lt;Loading /&gt;;}尽量避免使用展开运算符来展开 props变得难以理解和维护，容易出 bug遇到事件处理，使用一个返回新函数的方法例如：import React from &#x27;react&#x27;;export default function SampleComponent({ onValueChange }) {  const handleChange = (key) =&gt; {    return (e) =&gt; onValueChange(key, e.target.value);  };  return (    &lt;form&gt;      &lt;input onChange={handleChange(&#x27;name&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;email&#x27;)} /&gt;      &lt;input onChange={handleChange(&#x27;phone&#x27;)} /&gt;    &lt;/form&gt;  );}这样看起来比较简洁使用 Hook components比如要封装一个弹窗组件：// 组件import React, { useCallback, useState } from &#x27;react&#x27;;import ConfirmationDialog from &#x27;components/global/ConfirmationDialog&#x27;;export default function useConfirmationDialog({ headerText, bodyText, confirmationButtonText, onConfirmClick }) {  const [isOpen, setIsOpen] = useState(false);  const onOpen = () =&gt; {    setIsOpen(true);  };  const Dialog = useCallback(    () =&gt; (      &lt;ConfirmationDialog        headerText={headerText}        bodyText={bodyText}        isOpen={isOpen}        onConfirmClick={onConfirmClick}        onCancelClick={() =&gt; setIsOpen(false)}        confirmationButtonText={confirmationButtonText}      /&gt;    ),    [isOpen]  );  return {    Dialog,    onOpen,  };}// 使用import React from &#x27;react&#x27;;import { useConfirmationDialog } from &#x27;./useConfirmationDialog&#x27;;function Client() {  const { Dialog, onOpen } = useConfirmationDialog({    headerText: &#x27;Delete this record?&#x27;,    bodyText: &#x27;Are you sure you want delete this record? This cannot be undone.&#x27;,    confirmationButtonText: &#x27;Delete&#x27;,    onConfirmClick: handleDeleteConfirm,  });  function handleDeleteConfirm() {}  const handleDeleteClick = () =&gt; {    onOpen();  };  return (    &lt;div&gt;      &lt;Dialog /&gt;      &lt;button onClick={handleDeleteClick} /&gt;    &lt;/div&gt;  );}export default Client;这种模式可以少写很多与组件相关的 state，比如弹窗的 visible、title 之类的将业务逻辑封装进 hooks，业务逻辑与 UI 分离（关注点分离）// 例如：import React from &#x27;react&#x27;;import ItemDisplay from &#x27;./ItemDisplay&#x27;;export default function SampleComponent() {  const { data, handleDelete, handleEdit, handleAdd } = useCustomHook();  return (    &lt;div&gt;      &lt;div&gt;        {data.map((item) =&gt; (          &lt;ItemDisplay item={item} /&gt;        ))}      &lt;/div&gt;      &lt;div&gt;        &lt;button onClick={handleDelete} /&gt;        &lt;button onClick={handleAdd} /&gt;        &lt;button onClick={handleEdit} /&gt;      &lt;/div&gt;    &lt;/div&gt;  );}不要把所有状态存放在 redux，redux 只用于存放用户登录信息、主题等信息不要任何变量都使用状态，可以使用 useRef 或成员属性（类组件）来储存与更新渲染无关的变量，可以通过已保存的状态来推断出的状态可使用 useMemo 来计算，而不要创建新状态尽量不要在组件中声明新的组件// 错误，不建议function A() {  const B = () =&gt; {    return &lt;p&gt;hello&lt;/p&gt;;  };  return (    &lt;div&gt;      &lt;B /&gt;    &lt;/div&gt;  );}原因：高耦合影响性能，A 每一次渲染都会重新声明一遍 B尽量避免向组件传递避免为了优化少量性能过度设计代码，反而降低了代码的可维护性、易读性，浪费时间Typescript接口命名以大写字母“I”开头，来自：eclipse 的建议少写 any类型定义文件(.d.ts)如何放置临时的类型，直接在使用时定义组件个性化类型，直接定义在 ts(x)文件中范围/全局数据，定义在.d.ts 文件中"},{"id":"工作沉淀/敏捷迭代.md","filename":"敏捷迭代.md","basename":"敏捷迭代","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"敏捷模型总览敏捷模型组织架构客户化小组专项+小车道小组组建与职责"},{"id":"工作沉淀/登录方案.md","filename":"登录方案.md","basename":"登录方案","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"登录方案方案一：仅 jwt后端直接签发 jwt，后端不存储缺点：一旦下发，后端无法拒绝携带该 jwt 的请求，无法踢除用户方案二：jwt + redis后端备份一份 token 存入 redis，请求进来时，使用前端传来的 jwt 从 redis 查询出对应 token，做对比，若 redis 中的 token 过期或不存在则视为无权限方案三：长短 token首次登录设置两个 token，都保存进 redisaccess_token：标准 JWT 格式，即请求时的授权令牌，过期时间较短，一般 2 个小时，redis key：uuid-access，value：jwtrefresh_token：用于刷新 access_token，过期时间较长，一般 1 个月，redis key：uuid-refresh，value：jwt添加凭 refresh_token 刷新 access_token 的接口前端请求封装先发起请求，如果接口返回 access_token 过期，先刷新 access_token，再进行一次重试为了让活跃用户保持登录，其他方案频繁续签会有性能问题，该方案解决此问题问题前端请求刷新 token 有延迟，如何防止多次请求同时发起多次刷新 token请求封装中设置刷新 token 防抖锁，如果一次刷新任务进行中，则其他刷新请求取消同时发起多个请求时，access_token 正好过期，同时多次提示无权限请求封装中，如果刷新 token 锁处于关闭状态，则把请求任务保存进一个数组，等待锁打开再执行哈希加盐密码保存哈希函数单向不可逆加密算法直接哈希的缺陷有可能被查表法、逆向查表法、彩虹表等方式破解首先将一些比较常用的密码的哈希值算好，然后建立一张表，当然密码越多，这张表就越大。当你知道某个密码的哈希值时，你只需要在你建立好的表中查找该哈希值，如果找到了，你就知道对应的密码了加盐盐就是一个随机生成的字符串将盐与原始密码连接在一起（前或后都可以），然后将连接后的字符串加密盐和加密后的密码一起保存进数据库登录时将盐和密码都查出来，前端传来的密码同样算法加密后进行比对为什么不能用用户 id 当做盐用户 id 有可能是会变的，用户 id 一旦有变，登录时计算出来的结果就会不一样"},{"id":"工作沉淀/设计稿多端适配方案.md","filename":"设计稿多端适配方案.md","basename":"设计稿多端适配方案","path":"/home/runner/work/my-book/my-book/工作沉淀","relative_path":"工作沉淀","output_path":"/home/runner/work/my-book/my-book/dist/工作沉淀","content":"问题如何让不同尺寸的屏幕能以正常比例呈现设计稿方案动态修改 html 标签 font-size，样式单位统一用 rem，数值为设计稿尺寸除以 basevar fn = function () {  var designWidth = 1920; // 设计稿尺寸  var base = 16; // 1rem 的占比，不要小于 12  var html = document.getElementsByTagName(&#x27;html&#x27;)[0];  var clientWidth = document.body.clientWidth || document.documentElement.clientWidth;  html.style.fontSize = (clientWidth / designWidth) * base + &#x27;px&#x27;;};document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () {  fn();});window.onresize = function () {  fn();};dpr 是什么设备像素比，通过 window.devicePixelRatio 获取是设备上物理像素和设备独立像素（dips）的比例，window.devicePixelRatio = 物理像素 / dips简单的讲其实就是 dpr 决定了 css 1px 等于多少屏幕物理像素物理像素显示器上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值设备独立像素（dips）也叫密度无关像素，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素（比如: css 像素），然后由相关系统转换为物理像素viewport用于定义视口的各种行为：视口宽度、初始缩放、最小最大缩放比例、是否允许用户手动缩放"}]},{"id":"前端技术","dirname":"前端技术","filename":"","basename":"","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","children":[{"id":"前端技术/浏览器","dirname":"浏览器","filename":"","basename":"","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","children":[{"id":"前端技术/浏览器/事件循环.md","filename":"事件循环.md","basename":"事件循环","path":"/home/runner/work/my-book/my-book/前端技术/浏览器","relative_path":"前端技术/浏览器","output_path":"/home/runner/work/my-book/my-book/dist/前端技术/浏览器","content":"参考https://juejin.cn/post/6844904165462769678js 为什么是单线程与 js 的用途有关如果 js 被设计了多线程，如果有一个线程要修改一个 dom 元素，另一个线程要删除这个 dom 元素，渲染器就不知道以哪个线程为准所以，为了避免复杂性，设计成单线程为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。事件循环由于使用场景的原因，js 是设计成单线程的，为了更好的处理异步任务，所以设计了这个事件循环的机制一个浏览器通常有几个线程：渲染引擎线程、JS 引擎线程、定时触发器线程、事件触发线程、异步 http 请求线程渲染线程和 JS 引擎线程是不能同时进行的也就是说在执行 js 代码时，渲染会挂起；渲染 DOM 时，js 代码也不会执行。虽然 js 是单线程，但是浏览器是多线程的在遇到异步任务时（setTimeout、DOM 事件、ajax 等），会转交给浏览器的其他工作线程(上面提到的几个线程)执行，执行完之后将回调函数放入到任务队列一般来说，非阻塞性的任务采取同步的方式，直接在主线程的执行栈完成阻塞性的任务都会采用异步来执行，然后回调函数会放到事件队列中当主线程的任务执行完了（执行栈空了），js 会去询问事件队列有没有回到函数需要执行（所以 setTimeout 0 会等到最后才执行）主线程在运行时会产生执行栈栈中的代码调用某些异步 API 时会在任务队列中添加事件，栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制事件循环不一定每轮都伴随着重渲染，但是如果有微任务，一定会伴随着微任务执行宏任务和微任务任务队列又分微任务队列和宏任务队列宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。宏任务（多为运行环境 api）：script 标签中的代码、UI 交互、setTimeout/setInterval/setImmediate、DOM 事件、postMessage、ajax 请求、requestAnimationFrame宏任务代表一个个离散的、独立工作单元，运行完任务后，浏览器可以继续其他调度，如重新渲染页面的 UI 或执行垃圾回收微任务（多为语法）：Promise.then catch finally、MutationObserver、async/await、process.nextTick（NodeJS）微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的 UI。微任务的案例包括 promise 回调函数、DOM 发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染 UI 之前执行指定的行为，避免不必要的 UI 重绘，UI 重绘会使应用程序的状态不连续两者区别：宏任务：DOM 渲染后触发微任务：DOM 渲染前触发当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行为什么微任务执行更早微任务是语法规定的宏任务是由浏览器规定的（web api）宏任务执行时间一般比较长每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的事件循环的具体流程从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行；执行完该宏任务下所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，直至微任务队列清空为止；当微任务队列清空后，一个事件循环结束；接着从宏任务队列中，找到下一个执行的宏任务，开始第二个事件循环，直至宏任务队列清空为止当微任务队列处理完成并清空时，事件循环会检查是否需要更新 UI 渲染，如果是，则会重新渲染 UI 视图单次循环迭代中，最多处理一个宏任务（其余的在队列中等待），而队列中的所有微任务都会被处理页面渲染每次当一次事件循环结束后，即一个宏任务执行完成后以及微任务队列被清空后，浏览器就会进行一次页面更新渲染。通常我们浏览器页面刷新频率是 60fps，也就是意味着 16.67ms 要刷新一次，因此我们也要尽量保证一次事件循环控制在 16.67ms 之内，这也是我们需要做代码性能优化的一个原因。requestAnimationFrame 在重新渲染屏幕之前执行，非常适合用来做动画resize 和 scroll 事件其实自带节流，它只在 Event Loop 的渲染阶段去派发事件到 EventTarget 上执行过程先执行 script 中的同步任务，然后所有微任务 -&gt; 一个宏任务 -&gt; 所有微任务 -&gt; 一个宏任务执行完主线程中的任务取出 微队列(Microtask Queue) 中任务执行直到清空取出 宏队列(Macrotask Queue) 中一个任务执行重复 2 和 3如果微任务一直被添加，则会继续执行微任务，“卡死”宏任务Promise 的 then 和 catch 才是微任务 ，本身的内部代码不是"},{"id":"前端技术/浏览器/浏览器.md","filename":"浏览器.md","basename":"浏览器","path":"/home/runner/work/my-book/my-book/前端技术/浏览器","relative_path":"前端技术/浏览器","output_path":"/home/runner/work/my-book/my-book/dist/前端技术/浏览器","content":"输入 URL 到网页渲染过程输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求查询资源缓存，强缓存、协商缓存DNS 解析为了让我们更快的拿到想要的 IP，DNS 广泛使用了缓存技术：浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会去操作系统中找路由缓存：路由器也有 DNS 缓存ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求根服务器：ISP 的 DNS 服务器找不到之后，就要向根服务器发出请求，进行递归查询CDN：DNS 服务器会返回一个跟用户最接近的点的 IP 地址给用户，CDN 节点的服务器负责响应用户的请求，提供所需的内容dns-prefetch：DNS Prefetch 是一种 DNS 预解析技术。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行 DNS 的解析，减少用户等待时间，提高用户体验。获得请求 url 对应的 ip 地址，根据解析到的 IP 地址和端口号发起请求tcp 协议通过三次握手与服务器建立连接服务器（nginx、apache 等）处理请求并返回 HTTP 报文，浏览器收到开始渲染渲染过程参考：你真的了解回流和重绘吗浏览器根据深度遍历的方式把 html 节点遍历成 dom 树将 css 解析成 CSS DOM 树将 dom 树和 CSS DOM 树构造成渲染树补充：构造渲染树的过程，从 DOM 树的根节点开始遍历每个可见的节点，对于每个可见的节点，找到 CSS 树中的对应的规则，并且应用他们，根据每个可见的节点及其对应的样式，组合生成渲染树当文档加载过程中遇到 js 文件，html 文档会挂起渲染的线程，要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，这意味着在 JS 执行完成前，后续资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的根据得到的渲染树 计算所有节点在屏幕中的位置，进行布局（回流）遍历渲染树并调用硬件的 API 绘制所有节点（重绘）断开 TCP 连接：TCP 四次挥手Web Worker现代浏览器为 JavaScript 创造的 多线程环境。可以新建并将部分任务分配到 worker 线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。 基本用法：// 创建workerconst worker = new Worker(&#x27;work.js&#x27;);// 向 worker 线程推送消息worker.postMessage(&#x27;Hello World&#x27;);// 监听 worker 线程发送过来的消息worker.onmessage = function (event) {  console.log(&#x27;Received message &#x27; + event.data);};限制:同源限制无法使用 document / window / alert / confirm无法加载本地资源XSS、CSRF 攻击原理和防御XSS：通过利用网页开发时留下的漏洞，比如评论框，注入恶意 js 到网页防御 xss：过滤 html 标签，转义页面上的输入内容和输出内容，过滤 on 开头属性，cookie 设置 httpOnlyCSRF：设法伪造带有正确 Cookie 的 HTTP 请求通常由于服务端没有对请求头做严格过滤引起的CSRF 防御：不要使用 GET 请求来修改数据不要被第三方网站访问到用户的 cookieReferer 头检测，设置白名单接口不要被第三方网站请求、用 token 请求校验SameSite是 cookie 的一个属性，用来防止 CSRF 攻击和用户追踪，用来限制第三方 CookieStrict完全禁止第三方 Cookie，可能造成不好的用户体验，比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态Lax（默认值）大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外None网站可以选择显式关闭 SameSite 属性，将其设为 None。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。DOM api创建新节点createDocumentFragment() //创建一个 DOM 片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点添加、移除、替换、插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入查找getElementsByTagName()getElementsByName()getElementById()document.querySelector()document.querySelectorAll()前端路由原理hash 模式：在浏览器中，#号以及#号后面的字符称之为 hash，用 window.location.hash 读取；hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，修改 hash 不会刷新页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。history 模式：history 采用了 HTML5 的新特性 pushState 和 replaceState 可以对浏览器历史记录、html 标题进行修改，以及 popState 事件的监听到状态变更。history 模式下，前端的 URL 和实际向后端发起请求的 URL 一致。服务端如果缺少对该页面请求的处理，就会返回 404 错误。需要在服务端增加一个覆盖所有情况的候选资源：比如 URL 匹配不到任何资源时，则返回同一个 index.html 页面，这个页面就是前端应用的入口页面。我个人更推荐用 history 模式，history 模式更利于 seo 优化，url 也比较美观。什么是 HTML 语义化HTML5 语义化标签是指：正确的标签包含正确的内容，结构良好，便于阅读，利于 SEO 优化，比如 nav 表示导航条，类似的还有 article、header、footer 等等标签单页应用（SPA）优缺点优点：内容的改变不需要重新加载整个页面，用户体验好相对对服务器压力小前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理缺点：首屏加载慢前进后退路由需要自己管理，不能使用浏览器的前进后退功能SEO（搜索优化）难度大白屏如何解决白屏问题往 html 中填充内容，比如渲染根元素中间加上“加载中”几个字，让渲染结束前的这段时间有内容可以显示。计算首屏白屏时间使用 Performance API：&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;白屏&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      // 不兼容performance.timing 的浏览器，如IE8      window.pageStartTime = Date.now();    &lt;/script&gt;    &lt;!-- 页面 CSS 资源 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;common.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;page.css&quot; /&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      // 白屏时间结束点      window.firstPaint = Date.now();    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 页面内容 --&gt;  &lt;/body&gt;&lt;/html&gt;可使用 Performance API 时，白屏时间 = firstPaint - performance.timing.navigationStart;不可使用 Performance API 时，白屏时间 = firstPaint - pageStartTime;性能优化代码缓存 dom 查找结果用 innerHTML 代替 DOM 操作，减少 DOM 操作次数使用局部变量和字面量比使用数组和对象有更少的读写消耗原型链不要过深、对象嵌套不要太多对于多次访问的嵌套对象，应该用变量缓存起来不要频繁修改 DOM如果要修改 DOM 的多个样式可以用 cssText 一次性将要改的样式写入，或将样式写到 class 里，再修改 DOM 的 class 名称const el = document.querySelector(&#x27;.myDiv&#x27;);el.style.borderLeft = &#x27;1px&#x27;;el.style.borderRight = &#x27;2px&#x27;;el.style.padding = &#x27;5px&#x27;;// 可以使用如下语句代替const el = document.querySelector(&#x27;.myDiv&#x27;);el.style.cssText += &#x27;border-left: 1px; border-right: 2px; padding: 5px;&#x27;;// cssText会覆盖已存在的样式，所以使用 +=使用事件委托如无必要，不要重写原生方法，因为原生方法底层是用 C/C++实现的，速度更快CSS 能做的事情，尽量不用 JS 来做避免 css 表达式比如 calc代码中减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；其他减少 http 请求次数（雪碧图、字体图标）style 放顶部、js 放底部，非关键性的脚本（比如百度统计），script 标签加上 defer 或者 async单页应用首屏加载放个 loading，优化用户感知，利用一些动画 过渡效果、骨架屏使用 link 标签的 rel 属性设置 prefetch、preload（preload 将会把资源得下载顺序权重提高，使得关键数据提前下载好，优化页面打开速度）借助 webpack-bundle-analyzer 工具分析打包出的文件包含哪些,大小占比如何,模块包含关系注意项目中是否使用了字体，字体加载也会让首屏加载变得很慢webpack 的 tree-shaking 删除多余代码压缩 js、css 代码动态 polyfill，只针对不支持的浏览器引入 polyfill减少 cookie 的体积强缓存通用库，比如 jq、lodash通用的库使用 CDN 加速，将通用的库抽离，不要打包进 bundle，比如 jq、lodash使用公共 CDN，好处：如果其他网站刚好也用过同一个资源，会得到缓存通用的库按需加载，比如 antd服务端开启 gzip（gzip 只对文本文件有效，比如 js、css，流文件无效，比如图片）路由懒加载图片懒加载小图片使用字体图标代替服务端渲染将静态资源放在其他域名的原因（CDN）浏览器对于相同域名有并发请求数限制请求时不会发送 cookie，节省了流量cookie 会发送给二级域名，所以这些静态资源不放在二级域名，放在单独一级域名script 标签的 defer 和 async没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本async：立即下载，下载完立即执行，不确定顺序执行。对于完全独立的脚本来才去使用 async，比如谷歌统计百度统计。一定会在页面的 load 事件前执行，但不确定在 DOMContentLoaded 事件触发前后执行。defer：立即下载，将延迟到整个页面都解析完毕后再运行缓存优化Cache-Control：不经常变的文件，比如 jQuery，设置 Cache-Control: max-age=31536000，标准中规定 max-age 值最大不能超过一年，又因为是以秒为单位，所以值为 31536000，如果某天这个文件需要修改，改变文件名、请求地址就行设置 Expires：缓存过期时间,用来指定资源的到期时间,是服务器端的具体的时间点；告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据,而不用再次请求；max-age 的优化级高于 expires,当有 max-age 的时候,会无视 expires；当在有效时间内,如果服务器端的文件已经发生改变,但是浏览器端无法感知js 为什么放最下面？当文档加载过程中遇到 js 文件，html 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 js 文件加载完毕，还要等待解析执行完毕，才可以恢复 html 文档的渲染线程，因为 JS 有可能会修改 DOM，比如 document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 js 阻塞后续资源下载的原因。所以平时的代码中，js 是放在 html 文档末尾的css 为什么放最上面？CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染css 是由单独的下载线程异步下载的但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）gzip只对文本文件有效，比如 js、css，流文件无效，比如图片需要客户端和服务端的同时支持客户端支持：请求头中有个 Accept-Encoding 来标识对压缩的支持，content-encoding: gzip服务端支持：能够返回经过 gzip 压缩的文件重绘（repaint）与回流（reflow）重绘：当元素样式的改变不影响布局时，触发重绘，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少。回流、重排：当元素的尺寸、结构或触发某些属性时，触发回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较耗性能的操作。触发回流的操作：页面初次渲染浏览器窗口大小改变元素尺寸、位置、内容发生改变元素字体大小变化添加或者删除可见的 dom 元素激活 CSS 伪类（例如：:hover）查询某些属性或调用某些方法回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。如何避免触发回流和重绘CSS：避免使用 table 布局。尽可能在 DOM 树的最末端改变 class。避免设置多层内联样式。将动画效果应用到 position 属性为 absolute 或 fixed 的元素上避免使用 CSS 表达式（例如：calc()）CSS3 硬件加速（GPU 加速）JavaScript：避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘避免频繁读取会引发回流/重绘的属性或方法（offsetTop、offsetLeft、offsetWidth、offsetHeight、getBoundingClientRect 等），如果确实需要多次使用，就用一个变量缓存起来对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流requestAnimationFrame使用一个回调函数作为参数。这个回调函数会在浏览器重绘之前调用浏览器用于定时循环操作的一个接口，类似于 setTimeout，主要用途是按帧对网页进行重绘设置这个 API 的目的是为了让各种网页动画效果（DOM 动画、Canvas 动画、SVG 动画、WebGL 动画）能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果代码中使用这个 API，就是告诉浏览器希望执行一个动画，让浏览器在下一个动画帧安排一次网页重绘优势在于可以充分利用显示器的刷新机制，比较节省系统资源显示器有固定的刷新频率（60Hz 或 75Hz），也就是说，每秒最多只能重绘 60 次或 75 次，requestAnimationFrame 的基本思想就是与这个刷新频率保持同步cancelAnimationFrame 用于取消重绘，它的参数是 requestAnimationFrame 返回的一个代表任务 ID 的整数值为了提高性能和电池寿命，因此在大多数浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的 &lt;iframe&gt; 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命当浏览器渲染线程被过度占用时这个 API 调用间隔会非常不稳定，它并不是银弹使用：function test(timestamp) {  console.log(timestamp);  requestAnimationFrame(test);}requestAnimationFrame(test);手写 Ajaxvar xhr = new XMLHttpRequest();xhr.onreadystatechange = function () {  // 通信成功时，状态值为4  if (xhr.readyState === 4) {    if (xhr.status === 200) {      console.log(xhr.responseText);    } else {      console.error(xhr.statusText);    }  }};xhr.onerror = function (e) {  console.error(xhr.statusText);};xhr.open(&#x27;GET&#x27;, &#x27;http://www.example.com/page.php&#x27;, true);xhr.send(null);XMLHttpRequest.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。0，表示 XMLHttpRequest 实例已经生成，但是实例的 open()方法还没有被调用。1，表示 open()方法已经调用，但是实例的 send()方法还没有调用，仍然可以使用实例的 setRequestHeader()方法，设定 HTTP 请求的头信息。2，表示实例的 send()方法已经调用，并且服务器返回的头信息和状态码已经收到。3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的 responseType 属性等于 text 或者空字符串，responseText 属性就会包含已经收到的部分信息。4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。同源策略（跨域）不同协议、域名、端口，禁止请求，iframe、image、script、link 标签可以nginx、jsonp、cors（Access-Control-Allow-Origin）为什么会有同源策略： 如果没有同源策略，不同源的数据和资源（如 HTTP 头、Cookie、DOM、localStorage 等）就能相互随意访问，根本没有隐私和安全可言。事件流事件流描述的是从页面中接收事件的顺序，事件流包括下面几个阶段。事件捕获阶段处于目标阶段事件冒泡阶段addEventListener 第三个参数：true - 事件在捕获阶段执行；false（默认） - 事件在冒泡阶段执行事件流的应用：事件委托（事件代理）事件委托指的是，不直接在目标 dom 上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素 DOM 的类型，来做出不同的响应。举例：ul 和 li 标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在 li 标签上直接添加，而是在 ul 父元素上添加。好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。target 和 currentTarget 区别event.target 返回触发事件的元素event.currentTarget 返回绑定事件的元素js 的各种位置区别clientHeight：表示的是可视区域的高度，不包含 border 和滚动条offsetHeight：表示可视区域的高度，包含了 border 和滚动条scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。clientTop：表示边框 border 的厚度，在未指定的情况下一般为 0scrollTop：滚动后被隐藏的高度，获取对象相对于由 offsetParent 属性指定的父坐标(css 定位的元素或 body 元素)距离顶端的高度。localStorage、sessionStorage关闭选项卡后，将删除存储在 sessionStorage 中的数据localStorage 永远存在，除非手动删除cookie 根据 expires 字段（过期时间）决定"},{"id":"前端技术/浏览器/浏览器架构.md","filename":"浏览器架构.md","basename":"浏览器架构","path":"/home/runner/work/my-book/my-book/前端技术/浏览器","relative_path":"前端技术/浏览器","output_path":"/home/runner/work/my-book/my-book/dist/前端技术/浏览器","content":"参考：https://juejin.cn/post/6844904046411644941https://zhuanlan.zhihu.com/p/149063367浏览器架构（以 chrome 为例）各个进程具体负责的工作内容Browser：负责浏览器的“Chrome”部分， 包括导航栏，书签， 前进和后退按钮。同时这个进程还会控制那些我们看不见的部分，包括网络请求的发送以及文件的读写。Renderer：负责 tab 内和网页展示相关的所有工作。Chrome 会尽可能为每一个 tab 甚至是页面里面的每一个 iframe 都分配一个单独的渲染进程Plugin：控制网页使用的所有插件，例如 flash 插件GPU：负责独立于其它进程的 GPU 任务。它之所以被独立为一个进程是因为它要处理来自于不同 tab 的渲染请求并把它在同一个界面上画出来多进程架构为了节省内存，Chrome 会限制被启动的进程数目，当进程数达到一定的界限后，Chrome 会将访问同一个网站的 tab 都放在一个进程里面跑，每一个 tab 页面可以看作是一个渲染进程，包含几大类子线程：GUI 线程JS 引擎线程事件触发线程定时器线程网络请求线程其中 GUI 线程和 JS 引擎线程是互斥的：由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致好处提供安全性和沙盒性，当其中一个 tab 的崩溃时，你可以随时关闭这个 tab 并且其他 tab 不受到影响坏处内存消耗大网站隔离功能会为网站内不同站点的 iframe 分配一个独立的渲染进程由来：如果一个 tab 只有一个进程的话不同站点的 iframe 都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略"},{"id":"前端技术/浏览器/浏览器缓存.md","filename":"浏览器缓存.md","basename":"浏览器缓存","path":"/home/runner/work/my-book/my-book/前端技术/浏览器","relative_path":"前端技术/浏览器","output_path":"/home/runner/work/my-book/my-book/dist/前端技术/浏览器","content":"参考https://www.jianshu.com/p/54cc04190252浏览器缓存Web 缓存种类： 数据库缓存，CDN 缓存，服务器缓存（例如 redis），浏览器缓存浏览器实现了 http 缓存浏览器缓存类型：强缓存，协商缓存只有 get 请求会缓存，post 请求不会缓存位置Memory Cache内存中缓存主要包含的是当前页面中已经抓取到的资源，已经下载的样式、脚本、图片读取高效、持续性很短随着进程的释放而释放，杀进程或者关闭 Tab 页面会被释放对于大文件来说，大概率是不存储在 Memory Cache 的，反之优先Disk Cache磁盘缓存浏览器获取当前系统内存使用率，过高的话，优先存储进 Disk Cache所有类型资源都可以放速度较慢不会被释放容量大缓存过程首次请求：总体大致流程：强缓存当符合命中强缓存的条件，不向服务器发送请求，直接从缓存中读取资源，返回 200 状态码如果响应头有如下字段（按优先级小到大排序）：expires &lt; pragma &lt; cache-control，则为强缓存cache-control 优先级最高，当不支持 http1.1 的环境才会使用 expires 或者 pragmaexpires资源到期时间、格式为格林尼治时间戳如果未超过过期时间，直接使用该缓存缺点：要求客户端和服务端时钟严格同步，本地时间可以自己修改pragmaHTTP 1.0用于禁用网页缓存取值为 no-cache，和 cache-control 的 no-cache 效果一样cache-controlHTTP 1.1 新增取值public：资源客户端和服务器都可以缓存privite：资源只有客户端可以缓存no-cache：客户端缓存资源，但是是否缓存需要经过协商缓存来验证no-store：不使用缓存max-age：缓存保质期协商缓存强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程会向服务器发送请求协商缓存过程服务器发现资源无需更新，返回 304浏览器从本地缓存中获取资源，继续使用如果服务器发现该资源更新了，返回该资源，状态码 200浏览器更新该资源和缓存标识到本地缓存相关 headerLast-Modified / If-Modified-Since存在的问题：时间单位只精确到秒，如果文件 1 秒内改变多次，无法确保缓存精度；有可能文件内容没变，但是修改时间因为某些原因变了，人为修改之类的Last-Modified（响应头）资源在服务器最后被修改的时间If-Modified-Since（请求头）携带上次请求返回的 Last-Modified告诉服务器该资源上次请求时的最后被修改时间服务器做对比后决定协商缓存是否生效，返回 304 或 200Etag / If-None-Match优先级高于 Last-Modified，解决 Last-Modified 的问题，但性能比 Last-Modified 差，Etag 需要计算Etag（响应头）当前资源文件唯一标识，由服务器生成，由文件内容决定If-None-Match（请求头）携带上次请求该资源时返回的 Etag，告诉服务器服务器做对比，一致则代表生效，返回 304 或 200实际应用需要实时更新频繁变动的资源，设置 cache-control 为 no-cache不常变化的资源，例如 jquery，设置 cache-control 为 max-age=一个很长的时间单页应用部署时，入口 html 文件使用协商缓存（确保 html 入口是最新的，能够及时更新）按下 F5 或 ctrl+F5 时发生了什么ctrl+f5：跳过强缓存和协商缓存，直接从服务器加载资源f5：跳过强缓存，会检查协商缓存浏览器地址栏中输入 URL 回车：走正常流程"}]},{"id":"前端技术/AST抽象语法树.md","filename":"AST抽象语法树.md","basename":"AST抽象语法树","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"参考AST 抽象语法树——最基础的 javascript 重点知识，99%的人根本不了解平庸前端码农之蜕变 — AST解析器 Parser把 js 源码转化为抽象语法树（AST）常用解析器babel-parseracorn解析步骤两步：词法分析、语法分析词法分析把字符串形式的代码转换为 令牌（tokens）流，可以把令牌看作是一个扁平的语法片段数组例如：// 源n * n;// 词法分析结果[  { type: { ... }, value: &quot;n&quot;, start: 0, end: 1, loc: { ... } },  { type: { ... }, value: &quot;*&quot;, start: 2, end: 3, loc: { ... } },  { type: { ... }, value: &quot;n&quot;, start: 4, end: 5, loc: { ... } },]每一个 type 有一组属性来描述该令牌：{  type: {    label: &#x27;name&#x27;,    keyword: undefined,    beforeExpr: false,    startsExpr: true,    rightAssociative: false,    isLoop: false,    isAssign: false,    prefix: false,    postfix: false,    binop: null,    updateContext: null  },}语法分析根据词法分析的结果，也就是令牌 tokens，将其转换成 AST// 源function square(n) {  return n * n;}// ATS{  type: &quot;FunctionDeclaration&quot;,  id: {    type: &quot;Identifier&quot;,    name: &quot;square&quot;  },  params: [{    type: &quot;Identifier&quot;,    name: &quot;n&quot;  }],  body: {    type: &quot;BlockStatement&quot;,    body: [{      type: &quot;ReturnStatement&quot;,      argument: {        type: &quot;BinaryExpression&quot;,        operator: &quot;*&quot;,        left: {          type: &quot;Identifier&quot;,          name: &quot;n&quot;        },        right: {          type: &quot;Identifier&quot;,          name: &quot;n&quot;        }      }    }]  }}应用IDE 使用，如代码风格检测(eslint 等)、代码的格式化，代码高亮，代码错误等等代码的混淆压缩转换代码工具，如 babelvue 模板编译过程prettierbabel-plugin-importhttps://github.com/umijs/babel-plugin-import将 antd 组件 import 语句转换成按需引入写法的 babel 插件，对 AST 的经典应用这个插件现在不是必须的了，antd 的组件库提供了 ES Module 的构建产物，直接通过 import {} from 的形式也可以 tree-shaking"},{"id":"前端技术/Babel.md","filename":"Babel.md","basename":"Babel","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"概念一个 JavaScript 翻译器将 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在各种环境中通过 Polyfill 方式在目标环境中添加缺失的特性 （通过引入第三方 polyfill 模块，例如 core-js）基本工作原理第 1 步 解析（Parse）通过解析器 babylon 将代码解析成抽象语法树第 2 步 转换（TransForm）通过 babel-traverse plugin 对抽象语法树进行深度优先遍历，遇到需要转换的，就直接在 AST 对象上对节点进行添加、更新及移除操作，比如遇到箭头函数，就转换成普通函数，最后得到新的 AST 树第 3 步 生成（Generate）通过 babel-generator 将 AST 树生成 es5 代码配置主要分为 presets 和 plugins.babelrc._ 和 babel.config._ 区别.babelrc._ 仅适用于项目的某个部分babel.config._ 会影响整个项目中的代码，包含 node_modules 中的代码推荐使用 babel.config._，Babel 自身使用的就是这种格式presets逆序处理，从后往前，这主要是为了确保向后兼容，由于大多数用户将 &quot;es2015&quot; 放在 &quot;stage-0&quot; 之前，可以是数组、对象、字符串{  &quot;presets&quot;: [    &quot;presetA&quot;, // bare string    [&quot;presetA&quot;], // wrapped in array    [&quot;presetA&quot;, {}] // 2nd argument is an empty options object  ]}useBuiltIns{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;,      {        &quot;useBuiltIns&quot;: &quot;usage&quot;,        &quot;debug&quot;: true,        &quot;corejs&quot;: 3 // 建议使用 3，core-js@2 分支中已经不会再添加新特性，新特性都会添加到 core-js@3      }    ]  ]}babel 在转译的时候，会将源代码分成 syntax（语法） 和 api 两部分来处理，语法处理通过配置 presets，babel 使用 polyfill 来处理 api，@babel/preset-env 中有一个配置选项 useBuiltIns，用来告诉 babel 如何处理 api，由于这个选项默认值为 false，即不处理 api，所以代码转译后默认没有处理 api，可以通过手动引入 polyfill，但是 polyfill 没有动态引入会增加包的体积设置 useBuiltIns 的值为 &quot;entry&quot;，同时在源代码的最上方手动引入 @babel/polyfill 这个库（该库一共分为两部分，第一部分是 core-js，第二部分是 regenerator-runtime。其中 core-js 为其他团队开源的另一个独立项目），此时 babel 根据项目 browserslist，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 import '@babel/polyfill'，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill将 useBuiltIns 改为 &quot;usage&quot;，babel 就可以按需加载 polyfill，并且不需要手动引入 @babel/polyfill存在的问题polyfill 会直接在全局对象上定义方法，比如 Array.include，众所周知前端开发不鼓励污染全局变量，babel 会向翻译后的每一个文件原地定义许多帮助函数，用于转义语法，比如 __spreadArray、__generator,plugins本质是一个 JS 程序, 指示 Babel 如何对代码进行转换排列顺序很重要plugins 在 presets 之前运行plugins 顺序从前往后排列，与 presets 相反核心与其周边@babel/corebabel 使用了微内核的架构风格，也就是说它们的核心非常小，大部分功能都是通过插件扩展实现的，@babel/core 就是这个内核，包含核心功能作用：加载和处理配置(config)加载插件调用 Parser 进行语法解析，生成 AST调用 Traverser 遍历 AST，并使用访问者模式应用'插件'对 AST 进行转换生成代码，包括 SourceMap 转换和源代码生成@babel/cli命令行工具@babel/plugin-transform-runtime、@babel/runtime这个插件就是为了解决 useBuiltIns polyfill 污染全局的问题和每一个文件都有辅助函数问题，将 babel 转译时添加到文件中的内联辅助函数统一隔离到 babel-runtime 提供的 helper 模块中编译时，直接从 helper 模块加载，不在每个文件中重复的定义辅助函数，从而减少包的尺寸其中 @babel/plugin-transform-runtime 的作用是转译代码，转译后的代码中可能会引入 @babel/runtime-corejs3 里面的模块。前者运行在编译时，后者运行在运行时。类似 polyfill，后者需要被打包到最终产物里在浏览器中运行@babel/plugin-transform-runtime 通常仅在开发时使用，但是运行时最终代码需要依赖 @babel/runtime，所以 @babel/runtime 必须要作为生产依赖被安装typescript 的 importHelpers 配置和 tslib 也是类似的原理安装：$ yarn add @babel/plugin-transform-runtime -D$ yarn add @babel/runtime-corejs3修改配置如下：{  &quot;presets&quot;: [    [      &quot;@babel/preset-env&quot;      // 移除，否则和下面重复了      // {      //   &quot;useBuiltIns&quot;: &quot;usage&quot;,      //   &quot;debug&quot;: true      // }    ]  ],  &quot;plugins&quot;: [    [      &quot;@babel/plugin-transform-runtime&quot;,      {        &quot;corejs&quot;: 3 // 指定 runtime-corejs 的版本，目前有 2 3 两个版本      }    ]  ]}引入了这个插件后：api 从之前的直接修改原型改为了从一个统一的模块中引入，避免了对全局变量及其原型的污染helpers 从之前的原地定义改为了从一个统一的模块中引入，使得打包的结果中每个 helper 只会存在一个@babel/parser将源代码解析为 AST已经内置支持很多语法. 例如 JSX、Typescript、Flow、以及最新的 ECMAScript 规范@babel/traverse实现了访问者模式，对 AST 进行遍历，转换插件会通过它获取感兴趣的 AST 节点，对节点继续操作@babel/generator将 AST 转换为源代码，支持 SourceMap@babel/preset-env语法转换插件的集合可以根据目标浏览器运行环境配置（browserslist、targets），将 ES2015+ 的语法转换为 es5 语法，不需要一个个语法插件去安装（比如@babel/plugin-transform-arrow-functions）core.js新 api 集合@babel/polyfill@babel/polyfill 融合了 core-js 和 regenerator-runtime，因此 babel-polyfill 本质就是 corejs引入 @bable/polyfill 就相当于在代码中引入下面两个库import &#x27;core-js/stable&#x27;;import &#x27;regenerator-runtime/runtime&#x27;;官方提示已经 deprecated，推荐使用 core-js@3 + @babel/preset-env 即可🚨 As of Babel 7.4.0, this package has been deprecated in favor of directly including core-js/stable (to polyfill ECMAScript features) and regenerator-runtime/runtime (needed to use transpiled generator functions)regenerator-runtime生成器函数、async、await 函数经 babel 编译后，regenerator-runtime 模块用于提供功能实现，运行时依赖，需要打包进产物"},{"id":"前端技术/Browserslist.md","filename":"Browserslist.md","basename":"Browserslist","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"Browserslist用特定的语句来查询浏览器列表# 查询 Chrome 最后的两个版本npx browserslist &quot;last 2 Chrome versions&quot;chrome 96chrome 95autoprefixer 和 babel 都会用到开发过程中为了减小垫片的体积，避免使用过多没必要的垫片当我们确认的浏览器版本号，那么它的垫片体积就可以确认例如：当我们确认的浏览器版本号，那么它的垫片体积就会确认caniuse-lite 与 caniuse-dbbrowserslist 是从 caniuse-lite 这个库中查询数据的，caniuse-lite 是 caniuse-db 的精简版本，对 caniuse-db 的数据按一定规则做了简化，减少了库的大小caniuse-db 则是 can i use 网站的数据源，提供了网站查询所需的所有数据，caniuse-db 发布时会同步发布 caniuse-litecaniuse-lite 这个库也由 browserslist 团队进行维护由于它们都不属于线上数据库，使用时会将数据克隆至本地，所以可能会存在本地数据不是最新的情况，browserslist 提供了更新 caniuse-lite 的命令，可定期运行以获取最新数据npx browserslist@latest --update-db原理browserslist 根据正则解析查询语句，对浏览器版本数据库 caniuse-lite 进行查询，返回所得的浏览器版本列表因为 browserslist 并不维护数据库，因此它会经常提醒你去更新 caniuse-lite 这个库"},{"id":"前端技术/CSS.md","filename":"CSS.md","basename":"CSS","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"CSS层叠上下文z-index 属性值并不是在任何元素上都有效果。它仅在定位元素上有效果。（定义了 position 属性，且属性值为非 static 值的元素）产生层叠上下文：设置 position 为非 static 值css3 新特性选择器 nth-child边框圆角渐变色颜色透明度多列布局弹性布局过渡、动画flex媒体查询一行的时候居中，多行的时候左对齐利用行内元素的特点，父元素 text-align: center，子元素设为行内元素，设置 text-align: left怎么清除浮动clear:both;br 标签清浮动，br 标签存在一个属性：clear。这个属性能够清除浮动，在 br 标签中设置属性 clear，并赋值 all。即能清除掉浮动。CSS 选择器优先级!important内联样式ID 选择器类选择器/属性选择器/伪类选择器元素选择器/关系选择器/伪元素选择器通配符选择器BFCBFC 全称为块级格式化上下文。它决定了元素如何对其内容进行定位以及与其他元素的关系和相互作用，BFC 提供了一个环境，HTML 元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成 BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。可以说 BFC 就是一个作用范围，把它理解成是一个独立的容器，并且这个容器里的布局与这个容器外毫不相干。触发 BFC 的条件：根元素或其它包含它的元素浮动元素 (元素的 float 不是 none)绝对定位元素 (元素具有 position 为 absolute 或 fixed)内联块 (元素具有 display: inline-block)表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性)表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性)具有 overflow 且值不是 visible 的块元素弹性盒（flex 或 inline-flex）display: flow-rootcolumn-span: all行级块级区别块级可设置宽高，单独成行行内元素设置宽高无效，宽高由内容撑起盒模型标准盒模型：高宽仅为内容怪异盒模型：高宽包括内容+边框+内边距水平居中内行元素使用 text-align: centermargin: auto元素为绝对定位使用 left:0; right:0; margin: auto使用 flex垂直居中单行文字使用 lineheight使用 flex绝对定位元素：bottom:0; top:0; margin:auto绝对定位元素：top:50%; margin-top:-(元素高度一半)各个单位区别 rem、em、vh、px画一条 0.5px 的直线height: 1px;transform: scale(0.5);link 与 @import 的区别link 功能较多，可以定义 RSS，定义 Rel 等作用，而@import 只能用于加载 css当解析到 link 时，页面会同步加载所引的 css，而@import 所引用的 css 会等到页面加载完才被加载@import 需要 IE5 以上才能使用link 可以使用 js 动态引入，@import 不行渐进增强和优雅降级渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。"},{"id":"前端技术/Fiber.md","filename":"Fiber.md","basename":"Fiber","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"Fiber什么是 FiberFiber 在英文中的意思为纤维化，即细化，在计算机科学中是比线程还要细的一个东西，把整个更新过程碎片化是 React 核心算法的重新实现，是 React 团队两年多研究的结晶，是对 reconciliation 的重新编写，重新实现了 reconciler（协调器）目标是提高其对动画、布局和手势等领域的适用性允许将更新分解成更小的任务，达到增量渲染，将渲染工作拆分为块并将其分散到多个帧上，更新不会长时间阻止主线程（比如用户输入，动画之类）其他主要功能包括能够在新更新到来时暂停，中止或重用工作注意：并不会减少总工作量或更新所需的时间为什么 Fiber旧版 React 在处理 UI 时，使用栈递归遍历树结构，整个过程同步无法被打断，如果树结构太大层级很深，会一直占用浏览器主线程，可能导致动画丢帧，看起来断断续续（JS 线程和 GUI 线程是互斥的）改变了之前 react 的组件渲染机制，新的架构使原来同步渲染的组件可以异步化，可中途中断渲染，执行更高优先级的任务。释放浏览器主线程，保证任务在浏览器空闲的时候执行Fiber 架构思想浏览器现有 api：requestIdleCallback （闲时调用）来实现异步渲染，但 React 为了照顾绝大多数的浏览器，自己实现了 requestIdleCallback两个阶段：Reconciliation 与 Commit。Reconciliation 阶段对应早期版本的 diff 过程，Commit 阶段对应早期版本的 patch 过程，以 render 为界Reconciliation 阶段可被打断，Commit 阶段不可被打断Reconciliation 如果遇到更高优先级事件，则进行打断，渲染到一半的组件，会从头开始渲染，在 Reconciliation 阶段，一些生命周期可能会重新执行，例如componentWillMountcomponentWillReceivePropsshouldComponentUpdatecomponentWillUpdate这些生命周期函数则会在 Commit 阶段调用componentDidMountcomponentDidUpdatecomponentWillUnmountFiber 为什么使用链表React 使用单链表树遍历算法实现在没有递归的情况下遍历树，树形结构并不满足中途暂停对异步友好，它使暂停遍历并使阻止堆栈增长成为可能目前的虚拟 DOM 是树结构，当任务被打断后，树结构无法恢复之前的任务继续执行，所以需要一种新的数据结构，即链表，链表可以包含多个指针，可以轻易找到下一个节点，继而恢复任务的执行Fiber 采用的链表中包含三个指针，parent 指向其父 Fiber 节点，child 指向其子 Fiber 节点，sibling 指向其兄弟 Fiber 节点。一个 Fiber 节点对应一个任务节点Fiber 为什么深度优先查找 context 的消费节点，当 context 改变之后, 需要找出依赖该 context 的所有子节点"},{"id":"前端技术/Hooks.md","filename":"Hooks.md","basename":"Hooks","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"Hooks为什么 hooks类组件的性能消耗比较大，因为类组件需要创建类组件的实例，而且不能销毁函数式组件性能消耗小，因为函数式组件不需要创建实例，渲染的时候就执行一下，得到返回的 react 元素后就直接把中间量全部都销毁复用状态逻辑：Hook 使你在无需修改组件结构的情况下复用状态逻辑，可以将含有 state 的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试，在组件之间复用状态逻辑很难，如果要增加职责的话，就要加一层 HOC，容易形成“嵌套地狱”，一个套一个复杂 class 组件会变得难以理解，比如 componentDidMount 和 componentWillUnmount 是区分开的，Hook 可以将组件中相互关联的部分拆分成更小的函数class 比普通函数更难理解和使用，尤其是 this代码组织上，hooks 将业务逻辑聚合后，整个工程可阅读性大大增加友好渐进式的，项目中可以同时使用 class 和 hooksvue 中 mixin 的缺点难以追溯的方法与属性（不知道这个属性或方法是谁的）hook 为什么不能放在循环、条件、嵌套函数执行（为什么顺序调用对 React Hooks 很重要？）Not Magic, just ArraysHook 通过数组实现的，每次 useState 都会改变下标，React 需要利用调用顺序来正确更新相应的状态，否则会引起调用顺序的错乱，从而造成意想不到的错误能确保 Hook 在每一次渲染中都按照同样的顺序被调用，让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确React 依靠 Hook 调用的顺序来知道哪个 state 对应哪个 useState，Hook 的调用顺序在每次渲染中都是相同的，只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联Hook 需要在我们组件的最顶层调用Hooks 重渲染时是依赖于固定顺序调用，来保证被正确识别，依赖数组来维护，有一个 setter 数组和一个索引，该索引在每个 hooks 被调用时递增，并在组件 render 时重置用数组解构语法来命名 useState() 返回的 state 变量，但这些变量不会连接到 React 组件上，数据的存储是独立于组件之外的步骤初始化：创建两个空数组 setters 与 states，创建一个指针设置为 0首次渲染：每当 useState() 被调用时，如果它是首次渲染，它会通过 push 将一个 setter 方法（绑定了指针“cursor”位置）放进 setters 数组中，同时，也会将另一个对应的状态放进 states 数组中去后续渲染：每次的后续渲染都会重置指针“cursor”的位置，并会从每个数组中读取对应的值处理设置事件：每个 setter 对应一个指针位置的引用，当触发任何 setter 调用的时候，会去改变状态数组中对应索引的值开发工作中可以使用 eslint 配置相关规则发现这一错误hooks 特性Effect 拿到的总是定义它的那次渲染中的 props 和 state，在任意一次渲染中，props 和 state 是始终保持不变的，它们都属于一次特定的渲染，同样，每次渲染都有它自己的 Effects可通过 ref 来保存值，实现在所有的渲染帧中共享React 会记住我们设置的 effect 函数，并且会在每次 DOM 更改后、浏览器绘制屏幕后，去调用，这使得应用更流畅，不会阻塞屏幕的更新，上一次的 effect 会在重新渲染后被清除依赖项不要对 React 撒谎：effect 中用到的所有组件内的值都应该包含在依赖中可以使用 setState 的函数形式，获取上一次调用对应 setter 时传的状态值如果某些函数仅在 effect 中调用，可以把它们的定义移到 effect 中，这样可以不再需要去考虑依赖如果一个函数没有使用组件内的任何值，可以把它提到组件外面去定义成纯函数，然后就可以自由地在 effects 中使用（或者把它包装成 useCallback）useEffect 第一个参数，不能返回 Promise，所以不能传递异步函数，可以自己在里面声明再执行hooks 缺点响应式的 useEffect 写函数组件时，你不得不改变一些写法习惯。你必须清楚代码中 useEffect 和 useCallback 的“依赖项数组”的改变时机。有时候，你的 useEffect 依赖某个函数的不可变性，这个函数的不可变性又依赖于另一个函数的不可变性，这样便形成了一条依赖链。一旦这条依赖链的某个节点意外地被改变了，你的 useEffect 就被意外地触发了hooks 常用 APIuseCallback：返回一个记忆函数，缓存了每次渲染时那些回调函数的实例，可以配合 React.memo 起到减少不必要的渲染的作用useMemo：返回一个记忆值，传递一个工厂函数和数组。useMemo 只会在数组其中一个输入发生更改时重新调用工厂函数去计算这个值。此优化有助于避免在每个渲染上进行高开销的计算。useRef：useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传递的参数（initialValue）。返回的对象将存留在整个组件的生命周期中。useRef 在 react hook 中的作用, 正如官网说的, 它像一个变量, 类似于 this , 它就像一个盒子, 你可以存放任何东西. createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用useImperativeMethods：自定义使用 ref 时公开给父组件的实例值，往往与 forwardRef 一起使用useLayoutEffect：签名与 useEffect 相同，但在所有 DOM 变化后同步触发Hook 使用规则和注意约定以 use 开头并且紧跟大写字母（因为约定的力量在于：我们不用细看实现，也能通过命名来了解一个它是什么）只在最顶层使用 Hook，不要在循环，条件或嵌套函数中调用 Hook，能确保 Hook 在每一次渲染中都按照同样的顺序被调用只在 React 函数中调用 Hook，不要在普通的 JavaScript 函数中调用 Hook，确保组件的状态逻辑在代码中清晰可见（Eslint 通过判断一个方法是不是大坨峰命名来判断它是否是 React 函数）自定义 hooks自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。自定义 Hook 必须以 “use” 开头，不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的使用规则在两个组件中使用相同的 Hook 不会共享 state，自定义 Hook 是一种重用状态逻辑的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的useEffect 为什么不能传入异步函数理由是 effect function 应该返回一个销毁函数（effect：是指 return 返回的 cleanup 函数），如果 useEffect 第一个参数传入 async，返回值则变成了 Promise，会导致 react 在调用销毁函数的时候报错：function.apply is undefined为什么这样设计useEffect 的返回值是要在卸载组件时调用的，React 需要在 mount 的时候马上拿到这个值，不能有延迟解决使用 IIFE 或者声明异步函数再执行，推荐使用 IIFE 写法，因为声明的异步函数可能有外部依赖无法及时更新useEffect(() =&gt; {  (async) =&gt; {    const res = await fetch(SOME_API);    setValue(res.data);  };}, []);编写自定义 hook useAsyncEffect// 自定义hookfunction useAsyncEffect(effect: () =&gt; Promise&lt;void | (() =&gt; void)&gt;, dependencies?: any[]) {  return useEffect(() =&gt; {    const cleanupPromise = effect();    return () =&gt; {      cleanupPromise.then((cleanup) =&gt; cleanup &amp;&amp; cleanup());    };  }, dependencies);}// 使用useAsyncEffect(async () =&gt; {  const count = await fetchData();  setCount(count);}, [fetchData]);useEffect 实现防抖useEffect(() =&gt; {  const timer = setTimeout(async () =&gt; {    await fetchData(deps);  }, 500);  return () =&gt; clearTimeout(timer);}, [deps]);不能直接向 useEffect 传递防抖函数，因为 useEffect 常依赖 props 或者 useState 返回的值，当两种值改变后，都会触发 Function 组件重新渲染，那么 useEffect 又会重新执行一遍，生成一个新的防抖后的函数函数式组件与类组件有何不同？心智模型上函数式组件捕获了渲染所用的值类组件，this 是可变的函数式组件捕获了渲染所使用的值"},{"id":"前端技术/Nodejs.md","filename":"Nodejs.md","basename":"Nodejs","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"Nodejsnode 模块模块规范Node 模块系统借鉴 CommonJS 来实现CommonJS 对模块的定义主要分为：模块引用、模块定义和模块标识 3 个部分模块引用存在 require() 方法，这个方法接受模块标识，以此引入一个模块的 API 到当前上下文中模块定义上下文提供了 exports 对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口在模块中，还存在一个 module 对象，它代表模块自身，而 exports 是 module 的属性在 Node 中，一个文件就是一个模块，将方法挂载在 exports 对象上作为属性即可定义导出的方式模块标识就是传递给 require() 方法的参数符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径可以没有文件名后缀.js模块实现在 Node 中引入模块，需要经历 3 个步骤：路径分析、文件定位、编译执行Node 模块分为两类：Node 提供的模块（核心模块）、用户编写的模块（文件模块）两种类型区别核心模块部分在 Node 源代码的编译过程中，编译进了二进制执行文件。在 Node 进程启动时，部分核心模块已被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢缓存优先特性Node 对引入过的模块都会进行缓存，以减少二次引入时的开销，Node 缓存的是编译和执行之后的对象路径分析标识符的分类：核心模块、.或..开始的相对路径、以/开始的绝对路径、非路径形式核心模块：核心模块的优先级仅次于缓存加载；它在 Node 的源代码编译过程中已经编译为二进制代码，加载过程最快路径形式：1、转为真实路径；2、将编译执行后的结果存放到缓存中；自定义模块（非路径形式，可能是一个包的形式）：这类模块的查找是最费时的，也是所有方式中最慢的一种文件定位扩展名分析：允许在标识符中不包含文件扩展名，会按.js、.json、.node 的次序补足扩展名，依次尝试，调用了 fs 模块同步阻塞式地判断文件是否存在，所以如果是 .node 和 .json 文件，在传递给 require() 的标识符中带上扩展名，会加快一点速度可能没有查找到对应文件，如果得到一个目录，此时将目录当做一个包来处理，查找 package.json 的 main 属性，同样进行拓展名分析如果 package.json 和 main 字段没有找到，则寻找文件夹下的 index 文件，同样进行拓展名分析最后都没找到则抛出查找失败的异常编译执行.js 文件：通过 fs 模块同步读取文件后编译执行.node 文件：这是用 C/C++ 编写的扩展文件，通过 dlopen() 方法加载最后编译生成的文件.json 文件：通过 fs 模块同步读取文件后，用 JSON.parse() 解析返回结果其余扩展名：它们都被当做.js 文件载入每一个编译成功的模块都会将其文件路径作为索引缓存在 Module._cache 对象上，以提高二次引入的性能模块内部全局变量的由来require、exports、module、__filename、__dirname等变量的由来：在编译的过程中，Node 对获取的 JavaScript 文件内容进行了头尾包装。在头部添加了 (function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了 \\n})这样每个模块文件之间都进行了作用域隔离包结构package.json：包描述文件bin：用于存放可执行二进制文件的目录lib：用于存放 JavaScript 代码的目录doc：用于存放文档的目录test：用于存放单元测试用例的代码node 事件循环与浏览器的区别浏览器的事件循环是在 HTML5 中定义的规范，而 Node 中则是由 libuv 库实现cluster 原理pipe 原理nodejs 异常处理try catch，缺点明显：无法处理异步代码块内出现的异常，比如 setTimeout使用 event 原生模块，监听 error 事件原生模块的 callback 函数一般都会抛出错误（第一个参数）特点它是一个 Javascript 运行环境依赖于 Chrome V8 引擎进行代码解释事件驱动非阻塞 I/O单进程，单线程nodejs 解决的问题并发连接异步机制、事件驱动整个过程没有阻塞新用户的连接，也不需要维护已有用户的连接。基于这样的机制，理论上陆续有用户请求连接，NodeJS 都可以进行响应，因此 NodeJS 能支持比 Java、PHP 程序更高的并发量.虽然维护事件队列也需要成本I/O 阻塞Java、PHP 也有办法实现并行请求（子线程），但 NodeJS 通过回调函数（Callback）和异步机制会做得很自然。NodeJS 的优缺点优点：高并发（最重要的优点）适合 I/O 密集型应用缺点：不适合 CPU 密集型应用，由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释放，使得后续 I/O 无法发起；只支持单核 CPU，不能充分利用 CPU可靠性低，一旦代码某个环节崩溃，整个系统都崩溃开源组件库质量参差不齐，更新快，向下不兼容解决方案：Nginx 反向代理，负载均衡，开多个进程，绑定多个端口开多个进程监听同一个端口，使用 cluster 模块；使用比如 pm2 之类的工具应用场景RESTful API统一 Web 应用的 UI 层大量 Ajax 请求的应用npxnpx 想要解决的主要问题，就是调用项目内部安装的模块，可以避免全局安装模块npx 的原理很简单，就是运行的时候，会到 nodemodules/.bin 路径和环境变量PATH 里面*，*检查命令是否存在_。由于 npx 会检查环境变量PATH，所以系统命令也可以调用"},{"id":"前端技术/React.md","filename":"React.md","basename":"React","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"React渲染原理虚拟 dom使用 javascript 对象表示 DOM 结构的树形数据结构这个树结构包含整个 DOM 结构的信息真实 DOM 的内存表示，一种编程概念为框架带来了跨平台的能力，抽象了原本的渲染过程，实现了跨平台的能力结合 diff 算法，可以减少 JavaScript 操作真实 DOM 的带来的性能消耗虚拟 dom 优势：直接操作/频繁操作 DOM 的性能差虚拟 DOM 不会立马进行排版与重绘操作虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 DOM 节点排版与重绘损耗虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部key 的作用Keys 是一个辅助标识 用于追踪列表中被修改元素的。在 diff 算法中，会借助元素的 key 值来判断该元素是不是新创建的，而减少不必要的重新渲染。reconciliation（协调算法）当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。当一个组件更新时，组件实例会保持不变，因此可以在不同的帧保持 state 一致。React 将更新该组件实例的 props 以保证与最新的元素保持一致，并且调用该实例的 componentWillReceiveProps()、componentWillUpdate()、componentDidUpdate()当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素，使得树的转换效率得以提高Key 应该具有稳定，可预测，以及列表内唯一的特质，不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失也可以使用元素在数组中的下标作为 key。这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢diff 过程比对新老虚拟 dom 的变化，然后将变化的部分更新到视图上把树形结构按照层级分解，只比较同级元素给列表结构的每个单元添加唯一的 key 属性，方便比较对比不同类型的元素对比同一类型的元素对比同类型的组件元素对子节点进行递归为什么有 diff在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。diff 为什么不能用下标当基于下标的组件进行重新排序时，组件 state 可能会遇到一些问题。由于组件实例是基于它们的 key 来决定是否更新以及复用，如果 key 是一个下标，那么修改顺序时会修改当前的 key，导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动Refs通过 ref，允许访问 dom不得不直接访问时才使用，否则容易造成混乱Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例。Hooks 中的 useRef 可以用来保存多帧共享数据React 常用 apiReact.PureComponent：React.PureComponent 与 React.Component 完全相同，但是在 shouldComponentUpdate() 中实现时，使用了 props 和 state 的浅比较，可以提高性能React.memo：是一个高阶组件，与 React.PureComponent 类似，但是他用于包裹函数式组件，而不是类组件；如果函数式组件在给定相同的 props 的情况下渲染相同的结果，你可以在调用 React.memo 将其包装起来，以便在某些情况下通过记忆结果来提高性能。 这意味着 React 将跳过组件渲染，并重用最后渲染的结果。React.createRef：创建一个 ref ，它可以通过 ref 属性附加到 React 元素React.forwardRef：创建一个 React 组件，将它接收的 ref 属性转发给组件树中的另一个组件。接受渲染函数作为参数。React 将用 props 和 ref 作为两个参数来调用这个函数。此函数应返回 React 节点React.lazy：定义动态加载的组件。有助于减少包大小，以延迟加载在初始渲染期间未使用的组件，要求被&lt;React.Suspense&gt;组件包裹。这是指定加载指示器的方式React.Suspense：指定加载指示器PureComponent 的陷阱PureComponent 创建了默认的 shouldComponentUpdate 行为，这个默认的 shouldComponentUpdate 行为会一一比较 props 和 state 中所有的属性，只有当其中任意一项发生改变是，才会进行重绘PureComponent 使用浅比较判断组件是否需要重绘，即比较指针的异同所以如果 props 和 state 是引用对象，比如对象、数组，修改属性或元素，不会导致重绘React 异常处理设置编边界包裹组件，实现 componentDidCatch为什么不要在 render 中 setState？会造成死循环为什么不要在 render 中声明组件不要在 render 中声明组件，不然每次渲染都是声明的一个新的组件，组件的一些非受控状态就会丢失，比如聚焦状态，浏览器选中文字状态为什么推荐组合、HOC，而不是继承React 希望组件是按照最小可用的思想来进行封装，就是一个组件只做一件的事情，这叫单一职责原则函数式编程中，函数组合是组合两个或多个函数以产生新函数的过程。将函数组合在一起就像将一系列管道拼接在一起，让我们的数据流过setStatesetState 如何深合并方法一：使用展开运算符方法二：先直接赋值，再调一次 setState({})setState 时发生了什么将传递给 setState 的对象合并到组件的当前状态。构建一个新的虚拟 dom。将新树与旧数比较，计算出新旧树的节点差异，确定需要更新的真实 dom。调用 render 方法更新 UI。setState 什么时候异步什么时候同步与调用时的环境相关在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState 是“异步”的，如果需要马上同步去获取新值，setState 可以传入第二个参数，在回调中即可获取最新值在 原生事件 和 setTimeout 中，setState 是同步的，可以马上获取更新后的值原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而 setTimeout 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.statesetState 在 react 生命周期和合成事件会批量覆盖执行当遇到多个 setState 调用的时候会提取单次传递 setState 对象，将它们进行合并（类似 Object.assign，遇到相同 key 会覆盖前面的 key）setState 在原生事件，setTimeout、setInterval、promise 等异步操作中，state 会同步更新所谓合成事件就是：react 为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在 jsx 中常见的 onClick、onChange 这些都是合成事件批量更新机制在 合成事件 和 生命周期钩子 中，setState 更新队列时，存储的是 合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新函数型式由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在 fn 中返回新的 state 对象即可，例如 this.setState((state, props) =&gt; newState)；使用函数型式，可以用于避免 setState 的批量更新的逻辑，传入的函数将会被 顺序调用注意事项setState 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次当组件已被销毁，如果再次调用 setState，React 会报错警告，通常有两种解决办法：将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount 中标记为 true，在 setState 前进行判断单向数据流规定数据只能由外层组件向内层组件进行传递和更新。组件的 props 是只读的。否则容易导致数据紊乱、出现不可控操作。让组件之间的关系变得简单、可预测。如果数据在兄弟子组件之间共享，那么数据应该存储在父组件，并同时传递给需要数据的两个子组件。高阶组件（HOC）高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的增强组件。高阶组件自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式和编程技巧。常见的有 react-redux 里的 connect 和 react-router 中的 withRouter。作用：复用组件逻辑，操作状态和参数，渲染劫持场景和应用：权限控制性能监控，包裹组件的生命周期，进行统一埋点日志打点双向绑定可以借助 ES7 提供的 Decorators （装饰器）来让写法变得优雅，安装并配置 babel 插件：babel-plugin-transform-decorators-legacy使用注意：不要在 render 方法内创建高阶组件，会导致组件每次都会被卸载后重新挂载不要改变原始组件，高阶组件应该是没有副作用的纯函数，这样破坏了对高阶组件的约定，也改变了高阶组件的初衷，使用高阶组件是为了增强而非改变生命周期1、挂载卸载过程constructor() 必须写super(),否则会导致this指向错误componentWillMount() 即将过时不要使用componentDidMount() dom节点已经生成，可以在这里调用ajax请求componentWillUnmount() 在这里移除事件订阅和定时器2、更新过程componentWillReceiveProps(nextProps) 即将过时不要使用，接受父组件改变后的props需要重新渲染shouldComponentUpdate(nextProps,nextState) 性能优化componentWillUpdate(nextProps,nextState) 即将过时不要使用componentDidUpdate(prevProps,prevState)render() 插入jsx生成的dom结构，diff算法比较更新前后的新旧DOM树，找到最小的有差异的节点，重新渲染在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 多次调用 的情况，产生一些意外错误新版的建议生命周期如下：class Component extends React.Component {  // 替换 `componentWillReceiveProps`  // 初始化和 update 时被调用  // 静态函数，无法使用 this  static getDerivedStateFromProps(nextProps, prevState) {}  // 判断是否需要更新组件  // 可以用于组件性能优化  shouldComponentUpdate(nextProps, nextState) {}  // 组件被挂载后触发  componentDidMount() {}  // 替换  componentWillUpdate;  // 可以在更新之前获取最新 dom 数据  getSnapshotBeforeUpdate() {}  // 组件更新后调用  componentDidUpdate() {}  // 组件即将销毁  componentWillUnmount() {}  // 组件已销毁  componentDidUnmount() {}}生命周期使用建议：在 constructor 初始化 state在 componentDidMount 中进行事件监听，并在 componentWillUnmount 中解绑事件在 componentDidMount 中进行数据的请求，而不是在 componentWillMount需要根据 props 更新 state 时，使用 getDerivedStateFromProps(nextProps, prevState)可以在 componentDidUpdate 监听 props 或者 state 的变化在 componentDidUpdate 使用 setState 时，必须加条件，否则会死循环getSnapshotBeforeUpdate(prevProps, prevState) 可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前shouldComponentUpdate: 默认每次调用 setState，一定会最终走到 diff 阶段，但可以通过 shouldComponentUpdate 的生命钩子返回 false 来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能react 性能优化是哪个周期函数shouldComponentUpdate这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘比较消耗性能，如果能在 shouldComponentUpdate 方法中能够写出更优化的逻辑，可以提高性能。React 中的事件处理为了解决跨浏览器兼容性问题，React 会将 浏览器原生事件 封装为 合成事件 传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，它屏蔽了底层浏览器的细节差异，保证了行为的一致性。React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层（document）进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。react 合成事件是什么，和原生事件的区别React 合成事件机制，React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，然后 React 将事件封装给正式的函数处理运行和处理如果 DOM 上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，React 实现了一个中间层当用户在为 onClick 添加函数时，React 并没有将 Click 事件绑定在 DOM 上面，而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层constructor 中 super 与 props 参数一起使用的目的是什么是 ES6 规定的，在子类的 constructor 中必须先调用 super 初始化父类才能引用 this。在调用方法之前，子类构造函数无法使用 this 引用 super() 。什么是受控组件受控：value 和 state 绑在一起的。非受控：可通过浏览器 api 获取值。为什么一定要 import “react”JSX 实际上是 React.createElement 的语法糖，jsx 会被翻译成 React.createElementreact 性能优化方案重写 shouldComponentUpdate 来避免不必要的 dom 操作。使用 production 版本的 react.js。使用 key 来帮助 React 识别列表中所有子组件的最小变化。React.memoPureComponentuseMeno、useCallbackContext当不想在组件树中通过逐层传递 props 或者 state 的方式来传递数据时，可以使用 Context 来实现 跨层级 的组件数据传递React.createContext：创建一个上下文的容器(组件), defaultValue 可以设置共享的默认数据Provider(生产者): 和他的名字一样。用于生产共享数据的地方。生产什么呢？ 那就看 value 定义的是什么了。value:放置共享的数据Consumer(消费者):这个可以理解为消费者。 他是专门消费供应商(Provider 上面提到的)产生数据。Consumer 需要嵌套在生产者下面。才能通过回调的方式拿到共享的数据源。当然也可以单独使用，那就只能消费到上文提到的 defaultValueLink 组件和 a 标签 区别Link 做了 3 件事情：有 onclick 那就执行 onclickclick 的时候阻止 a 标签默认事件、不会跳转和刷新页面再取得跳转 href（即是 to），用 history（前端路由两种方式之一，history &amp; hash）跳转，此时只是链接变了，并没有刷新页面switch 标签作用有标签，则其中的在路径相同的情况下，只匹配第一个，这个可以避免重复匹配withRouter 作用让被修饰的组件可以从属性中获取 history,location,match路由组件可以直接获取这些属性，而非路由组件就必须通过 withRouter 修饰后才能获取这些属性了ReduxRedux 是一个 数据管理中心，它通过一定的使用规则和限制，保证着数据的健壮性、可追溯和可预测性。它与 React 无关，可以独立运行于任何 JavaScript 环境中。整个应用只有唯一的状态树，也就是所有状态维护在一个 Store 中规定只能通过一个纯函数 (Reducer) 来描述修改Redux 组件Store – 整个程序的状态/对象树保存在 Store 中，一个工程只有一个 store。它具有以下方法供使用：getState 获取 statedispatch 触发 action, 更新 statesubscribe 订阅数据变更，注册监听器Action – 这是一个用来描述发生了什么事情的对象。它作为一个行为载体，用于映射相应的 Reducer，并且它可以成为数据的载体，将数据从应用传递至 store 中，是 store 唯一的数据源Reducer – 这是一个确定状态将如何变化的地方。用于描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质如何在 Redux 中定义 ActionReact 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。Reducer 的作用Reducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。为什么 reducer 中不能做异步操作（为什么是纯函数）使用纯函数才能保证相同的输入得到相同的输入，保证状态的可预测reducer 的职责不允许有副作用，副作用简单来说就是不确定性，如果 reducer 有副作用，那么返回的 state 就不确定redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数React-Redux: 将 store 通过 context 传入组件中connect: 一个高阶组件，可以方便在 React 组件中使用 Redux异步 Action 方案常用 redux-thunk、redux-saga，后来阿里出了个 dvaredux-thunk 在一个 action 中返回一个函数执行异步操作，异步操作结束后，再去 dispatch 另一个 actionredux-saga：generator 风格dva：基于 redux-sagaReact 编程模型宿主树用于展示 UI会随时间变化稳定性，宿主树相对稳定通用性，宿主树可以被拆分为外观和行为一致的 UI 模式宿主实例宿主树的节点渲染器渲染器决定如何与特定的宿主环境通信以及如何管理它的宿主实例让开发者能以一种更好的方式操控宿主实例，而不用在意低级视图 API 范例React 元素最小的构建单元一个普通的 JavaScript 对象，用来描述一个宿主实例React 元素也能形成一棵树React 元素并不是永远存在的，它们总是在重建和删除之间不断循环React 元素具有不可变性。不能改变 React 元素中的子元素或者属性，如果想要在稍后渲染一些不同的东西，需要从头创建新的 React 元素树来描述它类似电影中放映的每一帧入口告诉 React ，将特定的 React 元素树渲染到真正的宿主实例中去，例如，React DOM 的入口就是 ReactDOM.render()协调确定应该对宿主实例做什么来响应新的信息如果相同的元素类型在同一个地方先后出现两次，React 会重用已有的宿主实例组件即返回 React 元素的函数一致性React 将所有的工作分成了“渲染阶段”和“提交阶段”。渲染阶段是当 React 调用你的组件然后进行协调的时段，在此阶段进行干涉是安全的，提交阶段就是 React 操作宿主树的时候，而这个阶段永远是同步的批量更新React 会在组件内所有事件触发完成后再进行批量更新，避免浪费的重复渲染上下文事实上，当 React 渲染时，维护了一个上下文栈副作用React 会推迟执行 effect 直到浏览器重新绘制屏幕有一个极少使用的 Hook 能够让你选择退出这种行为并进行一些同步的工作，请尽量避免使用它：useLayoutEffect自定义 Hooks自定义 Hooks 让不同的组件共享可重用的状态逻辑。注意状态本身是不共享的。每次调用 Hook 都只声明了其自身的独立状态。渲染器react-dom、react-dom/server、 react-native、 react-test-renderer 都是常见的渲染器不管你的目标平台是什么，react 包都是可用的，从 react 包中导出的一切，比如 React.Component、React.createElement、 React.Children 和 Hooks，都是独立于目标平台的渲染器包则暴露特定平台的 API，例如 ReactDOM.render()react 包仅仅是让你使用 React 的特性，但是它不知道这些特性是如何实现的。渲染器包(react-dom、react-native 等)提供了 React 特性的实现以及平台特定的逻辑每个渲染器都在已创建的类上设置了一个特殊的字段，这个字段叫做 updater"},{"id":"前端技术/Typescript.md","filename":"Typescript.md","basename":"Typescript","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"Typescript什么是 typescriptTypescript 是强类型的 Javascript 超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript 并不直接在浏览器上运行，需要编译器编译成纯 Javascript 来运行，对 js 进行静态类型检查为什么用 ts使工程更严谨参数校验，利于团队规范基础类型number、string、boolean、Array、object、Symbol、Tuple、enum、never、void、null、undefined、any泛型泛型代表的是泛指某一类型，更像是一个类型变量。由尖括号包裹主要作用是创建逻辑可复用的组件泛型可以作用在函数、类、接口上泛型还可以被约束使用泛型的场景当你的函数、接口或类将处理多种数据类型时当函数、接口或类在多个地方使用该数据类型时类型断言我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法就可以使用断言类型断言对运行没有什么影响，仅供编译器使用。向编译器提供我们所希望的分析代码的提示。表示断言的两种方式： 1：&lt;类型&gt;变量 2：变量 as 类型 （在 tsx 中只能使用这种方式）TS 接口可以定义对象、数组、函数、类等作用就是为一个变量类型进行命名，定义契约可以相互继承可以继承类可选属性与额外检查TS 类特性：继承、多态、抽象、封装、实例TS 装饰器是一种特殊类型的声明，它能被附加在类、方法、属性、访问符、参数上装饰器使用@expression 这种方式，expression 求值后必须为一个函数，它在运行时调用，被装饰器声明的信息作为参数传入Declare在.ts 中使用的第三方库时没有.d.ts 声明文件的时候，我们可以通过 declare 来写申明文件可以声明该模块，甚至可以直接声明一个值为 any 的同名的变量，然后我们就可以在代码中直接使用该三方库了tsconfig.json该文件存在于 Typescript 项目的根目录里，其作用是指定相关选项告诉 ts 编译器如何编译 ts 文件.d.ts 文件用 ts 写的模块在发布的时候仍然是用 js 发布，这就导致一个问题：ts 那么多类型数据都没了，所以需要一个 d.ts 文件来标记某个 js 库里面对象的类型然后 typings 就是一个网络上的 d.ts 数据库对编辑器能有智能提示"},{"id":"前端技术/Vue.md","filename":"Vue.md","basename":"Vue","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"VueVue 生命周期beforeCreatecreatedbeforeMountmounted dom加载完毕，可以进行ajax请求和dom操作beforeUpdateupdatedbeforeDestroydestroyed组件通信方式props / $emit 适用 父子组件通信parent / children 适用 父子组件通信事件总线 EventBusvuex 状态管理库什么是 mvvmModel-View-ViewModel 的缩写mvvm 是一种设计思想Model 层代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来ViewModel 是一个同步 View 和 Model 的对象在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互双向绑定原理vue2 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。Vue2 中使用 Object.definePorperty() 的缺陷Object.definePorperty()递归遍历所有对象的所有属性，当数据层级较深时，会造成性能影响。Object.definePorperty()只能作用在对象上，不能作用在数组上。Object.definePorperty()只能监听定义时的属性，不能监听新增属性。由于 Object.definePorperty()不能作用于数组，vue2.0 选择通过重写数组方法原型的方式对数组数据进行监听，但是仍然无法监听数组索引的变化和长度的变更Vue3.x 改用 Proxy 替代 Object.defineProperty，因为 Proxy 可以直接监听对象和数组的变化，数组变化也能监听到，不需要深度遍历监听，并且作为新标准将受到浏览器厂商重点持续的性能优化Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。说一下 vue2.x 中如何监测数组变化使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。data 和 computed 的区别data 中的属性并不会随赋值变量的改动而改动，而 computed 会为什么 vue 中 data 必须是一个函数js 中，对象为引用类型由于数据对象都指向同一个 data 对象，当在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改使用返回对象的函数，每次都创建一个新对象，引用地址不同，则不会出现这个问题nextTick定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 理解：nextTick()，是将回调函数延迟在下一次 dom 更新数据后调用，简单的理解是：当数据更新了，在 dom 中渲染后，自动执行该函数。什么时候用：Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中当项目中你想在改变 DOM 元素的数据后基于新的 dom 做点什么，对新 DOM 一系列的 js 操作都需要放进 Vue.nextTick()的回调函数中在使用某个第三方插件时 ，希望在 vue 生成的某些 dom 动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法，比如 swipebox 插件v-if 和 v-show 的区别v-if 是动态的向 DOM 树内添加或者删除 DOM 元素v-show 是通过设置 DOM 元素的 display 样式属性控制显隐Vue 事件绑定原理原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。Vue 模版编译原理简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：生成 AST 树优化codegen首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。 编译的最后一步是将优化后的 AST 树转换为可执行的代码。keep-alivekeep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。常用的两个属性 include/exclude，允许组件有条件的进行缓存。两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。Vue 的性能优化编码阶段尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcherv-if 和 v-for 不能连用如果需要使用 v-for 给每项元素绑定事件时使用事件代理SPA 页面采用 keep-alive 缓存组件在更多的情况下，使用 v-if 替代 v-showkey 保证唯一使用路由懒加载、异步组件防抖、节流第三方模块按需导入长列表滚动到可视区域动态加载图片懒加载SEO 优化服务端渲染 SSR打包优化压缩代码使用 cdn 加载第三方模块抽离公共文件用户体验骨架屏缓存优化（客户端缓存、服务端缓存、服务端开启 gzip 压缩等）vue3 新特性基于 Proxy 的观察者机制，目前，Vue 的反应系统是使用 Object.defineProperty 的 getter 和 setter。 但是，Vue 3 将使用 ES2015 Proxy 作为其观察者机制。 这消除了以前存在的警告，使速度加倍，并节省了一半的内存开销更好的支持 TS 和 JSXvuex核心属性state 全局唯一数据源getters 类似过滤器和计算属性，从 store 中的 state 中派生出一些状态mutations 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，类似 redux 里的 reducer，同步任务actions 类似 redux 里的异步 reducer，可以执行异步任务modules 模块，使用单一状态树，应用的所有状态会集中到一个比较大的对象，变得复杂、臃肿。Vuex 允许我们将 store 分割成模块（module）Vuex 中状态储存在哪里，怎么改变它？存储在 state 中，改变 Vuex 中的状态的唯一途径就是显式地提交 (commit) mutation。Vuex 中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变 state 里面的状态，是不允许，所以先用深度克隆复制对象，再修改。"},{"id":"前端技术/Webpack.md","filename":"Webpack.md","basename":"Webpack","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"WebpackWebpack原理：是一个 JavaScript 的模块打包工具。基于入口文件，自动地递归解析入口所需要加载的所有资源，然后用不同的 loader 来处理不同的文件，用 Plugin 来扩展 webpack 的功能通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。概念：Entry: 入口文件，Webpack 会从该文件开始进行分析与编译；Output: 出口路径，打包后创建 bundler 的文件路径以及文件名；Module: 源码目录中的每一个文件，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；Chunk: webpack 打包过程中的产物，在进行模块的依赖分析的时候，代码分割出来的代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；Loader: 模块加载器，进行各种文件类型的加载与转换，比如 babel-loader 将 jsx 转为 React.createElement；Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；Bundle: webpack 打包出来的文件，webpack 最终输出的东西，可以直接在浏览器运行。在抽离 css(当然也可以是图片、字体文件之类的)的情况下，一个 chunk 是会输出多个 bundle 的，但是默认情况下一般一个 chunk 也只是会输出一个 bundle工作流程概括就是：加载 - 编译 - 输出初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译确定入口：根据配置中的 entry 找出所有的入口文件编译模块，发广播：按文件类型，调用相应的 Loader 对模块进行编译，并在合适的时机点触发广播事件，Plugin 收听这些事件执行相应方法，再找出该模块依赖的模块，递归执行本步骤输出资源：将编译后的所有代码包装成一个个代码块（Chunk），并按依赖和配置确定输出内容，这个步骤，仍然可以通过 Plugin 进行文件的修改，是可以修改输出内容的最后机会保存：最后，根据 output 配置，把文件内容一一写入到文件系统，完成webpack 打包原理根据配置中的 entry 找出所有的入口文件。从入口文件出发,调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。在经过上一步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。文件指纹hash：所有的 bundle 使用同一个 hash 值，跟每一次 webpack 打包的过程有关chunkhash：根据每一个 chunk 的内容进行 hash，同一个 chunk 的所有 bundle 产物的 chunkhash 值是一样的。因此若其中一个 bundle 的修改，同一 chunk 的所有产物 hash 也会被修改contenthash：与文件内容本身相关注意：开发环境热更新下只能使用 hash 或者不使用 hash。在生产环境中我们一般使用 contenthash 或者 chunkhash，因为在热更新模式下，会导致 chunkhash 和 contenthash 计算错误rollup 和 webpack 区别webpack 拆分代码， 按需加载；Rollup 所有资源放在同一个地方，一次性加载，利用 tree-shake 特性来剔除项目中未使用的代码，减少冗余对于应用使用 webpack，对于类库使用 Rollup，rollup 适用于基础库的打包，如 vue、react如果你需要代码拆分(Code Splitting)，或者你有很多静态资源需要处理，再或者你构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择。如果您的代码库是基于 ES2015 模块的，而且希望你写的代码能够被其他人直接使用，你需要的打包工具可能是 Rollup。常见 loaderimage-loader：加载并且压缩图片文件file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能、把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；ts-loader: 加载 ts / tsx 文件，编译 TypeScript；style-loader: 将 css 代码以"},{"id":"前端技术/npm.md","filename":"npm.md","basename":"npm","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"团队管理最佳实践开发环境 node 和 npm 版本需要一致，因为不同版本 npm 行为不一样npm 的使用可以通过环境变量读取 package.json 中的属性：process.env.npm_package_name获取当前正在运行的 npm script 脚本名称：process.env.npm_lifecycle_event可通过添加 pre- 和 post- 前缀声明钩子脚本使用 link 调试本地包npx 工具：直接运行 node_modules/.bin 目录下的可执行文件npm run 新建的 Shell 环境，会将当前目录的 node_modules/.bin 加入 PATH 环境变量，执行结束后，再将 PATH 环境变量恢复，这意味着，当前目录的 node_modules/.bin 子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径或者 npxscript 中可通过 $npm_config_tag 获取 shell 中的配置值；如果 env 环境变量中存在以 npm_config_* 为前缀的环境变量，则也会被识别为 npm 的配置属性；以及各个级别的 .npmrc 配置文件npm run serve --params  // 参数params将转化成process.env.npm_config_params = truenpm run serve --params=123 // 参数params将转化成process.env.npm_config_params = 123npm version patch升级小版本，还会默认执行 git add-&gt;git commit-&gt;git tag 操作，也可以通过配置禁止这一默认行为查看所有可用命令：npm runnpm cinpm ci 只根据 package-lock.json 来安装包，而 npm install 在安装的过程中会结合 package.json 和 package-lock.json 来计算依赖包版本的差异性问题。所以相比较 npm install，npm ci 既能提升包的安装速度，又能避免在生产化境中出现包版本不一致的问题如果项目中已经存在 node_modules，npm ci 将会先删除它，然后再安装如果检测到 package.json 和 package-lock.json 中的依赖项不匹配的话，npm ci 将退出并报错，而不是更新两个文件中的版本号要求项目中必须具有 package-lock.json 或 npm-shrinkwrap.json，否则执行 npm ci 将会报错npm ci 只能一次安装整个项目的依赖包，而不能为项目安装单个依赖包npm 检查配置的优先级项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件 &gt; 全局级的 .npmrc &gt; npm 内置的 .npmrc 文件package-lock.json、yarn.lock 的作用锁定安装时的包的版本号，并且需要上传到 git，以保证其他人在 npm install 时大家的依赖能保证一致package.json 文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次 npm install 都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以 package-lock.json 文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。npm install 流程检查项目中是否有 package-lock.json 文件如果有， 检查 package-lock.json 和 package.json 声明的依赖是否一致：一致， 直接使用 package-lock.json 中的信息，从网络或者缓存中加载依赖不一致， 根据上述流程中的不同版本进行处理如果没有， 那么会根据 package.json 递归构建依赖树，然后就会根据构建好的依赖去下载完整的依赖资源，在下载的时候，会检查有没有相关的资源缓存:存在， 直接解压到 node_modules 文件中不存在， 从 npm 远端仓库下载包，校验包的完整性，同时添加到缓存中，解压到 node_modules 中最后， 生成 package-lock.json 文件在我们实际的项目开发中，使用 npm 作为团队的最佳实践: 同一个项目团队，应该保持 npm 版本的一致性。如果希望一个模块不管是否安装过，npm 都要强制重新安装，可以使用 -f 或–force 参数npm 的缺点包之间相互依赖，导致嵌套地狱，会形成一棵巨大的依赖树依赖层级过深，有问题不利于排查和调试安装结果占据大量空间资源，安装时间长yarn 解决的问题采用模块扁平化的安装模式: 将不同版本的依赖包，按照一定的策略，归结为单个版本；以避免创建多个版本造成工程的冗余（目前版本的 npm 也有相同的优化）网络性能更好: yarn 采用了请求排队的理念，类似于并发池连接，能够更好的利用网络资源；同时也引入了一种安装失败的重试机制采用缓存机制，实现了离线模式 （目前的 npm 也有类似的实现）依赖包版本号采用了 semver 规范作为依赖版本管理方案一般格式：主版本号.次版本号.修订号（x.y.z）package.jsonbin：表示的是一个可执行文件到指定文件源的映射&quot;bin&quot;: {  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;}file：需要上传 npm 的文件，一般设置只上传编译产物，加快下载包的速度main：指定加载的入口文件browser：定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件module：定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用。如果 npm 包导出的是 ESM 规范的包，使用 module 来定义入口文件man：指定帮助文档typings：指定 TypeScript 的入口文件dependenciesdependencies最终上线或者发布 npm 包时所需要，例如 vue 框架、UI 组件库发布 npm 包的时候，包中的 dependencies 依赖项在安装该包的时候会被一起下载，devDependencies 依赖项则不会devDependencies开发和测试时需要，例如打包工具、css 预处理器、测试框架等peerDependencies如果你安装我，那么你最好也要按照我的要求安装 A、B 和 C可以用来防止多次引入相同的库optionalDependencies这种依赖中的依赖项即使安装失败了，也不影响整个安装的过程如果一个依赖同时出现在 dependencies 和 optionalDependencies 中，那么 optionalDependencies 会获得更高的优先级在实际项目中，如果某个包已经失效，我们通常会寻找它的替代者，或者换一个实现方案。不确定的依赖会增加代码判断和测试难度，所以这个依赖项还是尽量不要使用域级包管理以@开头的包名由于用@声明了该包，npm 会默认将此包认定为私有包，而在 npm 上托管私有包是需要收费的，所以为了避免发布私有包，可以在发布时添加--accss=public 参数告知 npm 这不是一个私有包域级包不一定就是私有包，但是私有包一定是一个域级包在安装域级包时需要按照域级包全名来安装：npm install @scopeName/package发布一个支持 tree shaking 机制的包tree shaking 是依赖 ES Module 的模块特性来工作的，那是因为 ES Module 模块的依赖关系是在编译时确定的（和运行时无关），并且之后不能再改变，所以基于此特性可以进行可靠的静态分析设置 module 字段：该字段指向一个既符合 ES Module 模块规范但是又使用 ES5 语法的源文件。这么做的目的是为了启动 tree shaking 的同时，又避免代码兼容性的问题{  &quot;main&quot;: &quot;./lib/index.js&quot;, // 指向 CommonJS 模块规范的代码入口文件  &quot;module&quot;: &quot;./lib/index.es.js&quot; // 指向 ES Module 模块规范的代码入口文件}如上配置要求你的包中要发布两种模块规范的版本。如果你的 npm 环境支持 module 字段，则会优先使用 ES Module 模块规范的入口文件，如果不支持则会使用 CommonJS 模块规范的入口文件。其实要想发布一个支持 tree shaking 机制的包，最主要是要构建出一个符合 module 字段要求的源文件，也就是一个既符合 ES Module 模块规范但是又采用 ES5 语法的源文件。rollup 可以直接构建出符合 ES Module 模块规范的文件，但是 webpack 不能。所以我们只需要使用 rollup 提供的构建能力，在配置文件中把 output 的格式设置为 es 即可为了更好地使用 ES Module 模块规范来开启 tree shaking 功能，优先选用 rollup 来开发 npm 包基于 ES6 模块规范是为了用户在使用我们的包时可以享受 Tree Shaking 带来的好处；使用 ES5 语法书写是为了用户在配置 babel 插件时可以放心的屏蔽 node_modules 目录"},{"id":"前端技术/函数式编程.md","filename":"函数式编程.md","basename":"函数式编程","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"函数式编程是什么函数式编程是一种编程范式，目标是使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变，旨在尽可能地提高代码的无状态性和不变性主要思想是把运算过程尽量写成一系列嵌套的函数调用，比如柯里化、react 的高阶函数函数式库：Ramda.js、lodash、RxJS命令模式中 run 函数的好处将函数本身参数化，非侵入式的修改函数，无需重写任何内部逻辑为什么纯函数易于维护：无状态的代码不会改变或破坏全局的状态易于测试：不依赖外部资源的算法灵活便于重用、保持业务逻辑代码的纯净任务分解，一定程度增加代码可读性函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的"},{"id":"前端技术/原型链和继承.md","filename":"原型链和继承.md","basename":"原型链和继承","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"参考https://github.com/mqyqingfeng/blog/issues/2原型链原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&quot;继承&quot;属性或方法，其实就是 prototype 对象原型链：由相互关联的原型组成的链状结构就是原型链原型对象上的所有属性和方法，都能被对应的构造函数创建的实例对象共享（这就是 JavaScript 继承机制的基本设计）JavaScript 对象通过 prototype 指向父类对象，直到指向 Object 对象为止，这样就形成了一个原型指向的链条, 即原型链如果试图引用实例的某个属性或方法，会首先在对象内部寻找，直至找不到，才在该对象的原型里去找这个属性或方法instanceof、isPrototypeOf：判断是否处于原型链Object.hasOwnProperty()：检查对象自身中是否含有该属性for in 会搜索原型几乎所有 JavaScript 中的对象都是位于原型链顶端的 null 的实例函数对象的 prototype -&gt; 实例原型实例（普通对象）的 __proto__ -&gt; 实例原型原型的 constructor -&gt; 关联的构造函数实例原型的原型 -&gt; ObjectObject 的原型 -&gt; null，Object.prototype.__proto__ === null此时原型链停止查找null 表示“没有对象”，即该处不应该有值。所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思原型对象 和 构造函数在 JavaScript 中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个 prototype 属性，这个属性指向函数的原型对象当函数经过 new 调用时，这个函数就成为了构造函数，返回一个全新的实例对象，这个实例对象有一个 __proto__ 属性，指向构造函数的原型对象声明方法为什么要用 prototype为了在类的各个实例间共享通过该构造函数生成的实例所拥有的方法都是指向一个函数的索引，这样可以节省内存不使用 prototype 定义的方法相当于类的静态方法，可以直接使用，不需要 new使用 prototype 定义的方法相当于类的实例方法，必须 new 后才能使用prototype 和 proto 和 constructor 的关系prototype 用于访问函数的原型对象。它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，任何函数在创建的时候，其实会默认同时创建该函数的 prototype 对象__proto__ 用于访问对象实例的原型对象（或者使用 Object.getPrototypeOf()）__proto__ 是对象独有的__proto__ 作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的 __proto__ 属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的 __proto__ 属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找，直到原型链顶端 null 空对象constructor 属性也是对象才拥有的，它是从一个对象指向一个函数，含义就是指向该对象的构造函数typeof 和 instanceof 区别typeof：判断一个变量的类型instanceof：判断一个变量是否是某个对象的实例instanceof 原理：能在实例的 原型对象链 中找到该构造函数的 prototype 属性所指向的 原型对象，就返回 truenew 干了什么new 操作符新建了一个空对象，这个对象原型指向构造函数的 prototype，执行构造函数后返回这个对象。创建一个空对象将构造函数的作用域赋给新对象，根据原型链，设置空对象的 __proto__ 为构造函数的 prototype构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象手写 new：function myNew(context) {  const obj = new Object();  obj.__proto__ = context.prototype;  const res = context.apply(obj, [...arguments].slice(1));  return typeof res === &#x27;object&#x27; ? res : obj;}继承许多面向对象语言都支持两种继承方式: 接口继承 和 实现继承JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承JavaScript 也没有在语言层面提供对抽象类和接口的支持接口继承只继承方法签名，而实现继承则继承实际的方法在 JavaScript 中无法实现接口继承，只支持实现继承，而且其实现继承主要是依靠原型链来实现的以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链原型链继承直接通过原型继承属性和方法Son.prototype = new Father();缺点：原型中包含引用值的时候，会在所有实例间共享，修改子类引用类型属性会影响到父类子类型在实例化时不能给父类型的构造函数传参盗用构造函数为了解决原型包含引用值导致的继承问题（含引用类型值的原型属性会被所有实例共享）在子类型构造函数的内部调用父类型构造函数优点是可以在子类构造函数中向父类构造函数传参function Father() {  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];}function Son() {  Father.call(this);  // 继承了Father，且向父类型传递参数}缺点：必须在构造函数中定义方法，因此函数不能重用子类也不能访问父类原型上定义的方法组合继承原型链继承和盗用构造函数继承的结合使用原型链实现对原型属性和方法的继承通过盗用构造函数来实现对实例属性的继承既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性function Father(name) {  this.name = name;  this.colors = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;];}Father.prototype.sayName = function () {  alert(this.name);};function Son(name, age) {  // 继承属性  Father.call(this, name);  this.age = age;}// 继承方法Son.prototype = new Father();Son.prototype.constructor = Son;Son.prototype.sayAge = function () {  alert(this.age);};原型式继承即相当于 ES6 的 Object.create()方法适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合创建一个临时构造函数将传入的对象赋值给这个构造函数的原型然后返回这个临时类型的一个实例function object(o) {  function F() {}  F.prototype = o;  return new F();}寄生式继承类似工厂模式创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象适合主要关注对象，而不在乎类型和构造函数的场景通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似var book = { name: &#x27;js book&#x27;, likeBook: [&#x27;html book&#x27;, &#x27;css book&#x27;] };function createBook(obj) {  // 通过原型方式创建新的对象  var o = new inheritObject(obj);  // 拓展新对象  o.getName = function (name) {    console.log(name);  };  // 返回拓展后的新对象  return o;}寄生组合继承组合继承的问题：会调用两次父类型构造函数，创建子类原型时、在子类构造函数内部通过借用构造函数来继承属性通过原型链的混成形式来继承方法不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已function Father(foo) {  this.foo = foo;}Father.prototype.printFoo = function () {  console.log(this.foo);};function Son(bar) {  this.bar = bar;  Father.call(this);}Son.prototype = Object.create(Super.prototype);Son.prototype.constructor = Son;ES6 的 extendsclass Father {  constructor(foo) {    this.foo = foo;  }  printFoo() {    console.log(this.foo);  }}class Son extends Father {  constructor(foo, bar) {    super(foo);    this.bar = bar;  }}"},{"id":"前端技术/微信开发.md","filename":"微信开发.md","basename":"微信开发","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"微信开发小程序开发最佳实践全局共享数据（非响应式），可以保存在 wx 对象，wx 就类似于网页的 window 对象微信小程序分包机制某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个主包。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据开发者的配置进行划分。在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。 目前小程序分包大小有以下限制：整个小程序所有分包大小不超过 20M单个分包/主包大小不能超过 2M对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。什么是 wxs公众号用户授权1、用户同意授权，获取 code先在后台配置合法域名，页面需要运行在合法的域名下开发的时候，可以修改电脑的 hosts 文件，将配置的域名映射为 127.0.0.1，即可进行本地开发引导关注者打开一个微信的授权页面页面链接会通过 url 传递一些参数 appid、redirect_uri、response_type 等2、通过 code 换取网页授权 access_token把 code 传给后台后台调微信接口传 code，获得网页授权 access_token 和 openid请求微信用户信息接口，传上一步获得的 access_token 和 openid，响应给前端接入 js-sdk登录后台配置合法域名，页面需要运行在这个域名页面进入一个微信 js-sdk 的库请求后台获取签名等参数的接口，把当前 url 发给后台后台请求微信接口获取 access_token，再用 access_token 获取 jsapi_ticket组装 noncestr、jsapi_ticket、timestamp、url，进行 sha1 签名得到 signature把计算得到的东西发给前端前端调用 wx.config 注入权限通过 ready 接口处理成功验证、通过 error 接口处理失败验证小程序登录流程首次登录：首先需要调用小程序 api 接口 wx.login() 获取 临时登录凭证 code ，这个 code 是有过期时间的将这个 code 回传到开发者服务器（就是请求开发者服务器的登录接口，通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key）等拿到开发者服务器传回来的会话密钥（session_key）之后，前端要保存 wx.setStorageSync(‘sessionKey’, ‘value’)再次登录：获取缓存中的 session_key，wx.getStorageSync(‘sessionKey’)如果缓存中存在 session_key，那么调用小程序 api 接口 wx.checkSession()来判断登录态是否过期，回调成功说明当前 session_key 未过期，回调失败说明 session_key 已过期。登录态过期后前端需要再调用 wx.login()获取新的用户的 code，然后再向开发者服务器发起登录请求。一般在项目开发，开发者服务器也会对用户的登录态做过期限制，所以这时在判断完微信服务器中登录态如果没有过期之后还要判断开发者服务器的登录态是否过期。（请求开发者服务器给定的接口进行请求判断就好）无论是微信服务器过期了还是开发者服务器登录态过期了，都要像首次登录那样开始三步骤。所以注意封装代码"},{"id":"前端技术/微前端.md","filename":"微前端.md","basename":"微前端","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"微前端微前端不一定是一种新技术，也不必太复杂。只要我们保证代码隔离和团队自治，无论我们采用何种技术栈，我们都可以达到相同的效果由来工程越来越大，打包越来越慢团队人员多，产品功能复杂，代码冲突频繁、影响面大在后端服务开发中，为了解决庞大的一整块后端服务带来的变更与扩展方面的限制，出现了微服务架构把应用程序设计成一系列松耦合的细粒度服务允许使用不同的编程语言来编写不同服务前端也出现这样的问题，即，一种由独立交付的多个应用组成整体的架构风格。将前端应用分解成一些更小更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品比起一整块的前端代码库，微前端架构下的代码库倾向于更小/简单、更容易开发传统开发的缺点历史项目，祖传代码交付压力，当时求快就近就熟，当时求稳导致技术栈落后，甚至强行混用多种技术栈，耦合混乱，不敢动，牵一发动全身每个微前端都应具备有自己的持续交付流水线（包括构建、测试并部署到生产环境），且要能独立部署，不必过多考虑其它代码库的状态意义技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略独立运行时，每个微应用之间状态隔离，运行时状态不共享微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。技术方案package 集成将每个微前端发布为一个 npm 包，并让容器应用程序将所有微前端应用作为依赖项这意味着只要有一个包更新，即使是小版本，宿主也要重新构建一次。不建议使用这种方案iframe优点：隔离得很彻底缺点：速度慢，浏览器处理 iframe 要启动更多的进程；页面刷新难以保存状态，路由、历史记录等等使用 umd 包通过 script 标签引入放在 cdn 上的资源，可以始终保持最新，子应用更新不需要通知宿主具有完全的灵活性，宿主可以控制什么时候载入每个应用，以及渲染应用时额外传参数微前端架构存在的一些普遍问题下载量独立构建的 JavaScript 文件可能导致重复的公共依赖，从而增加用户的下载量例如，如果每个微应用都包括自己的 React 副本，那么用户就得多次下载 React环境差异在本地开发时无法把所有微应用和对应的后端都启动起来，不得不在本地进行环境的简化。如果开发环境和生产环境不严谨一致，容易造成问题。如果开发者想要完全模拟生产环境，会比较耗时治理复杂性要管理更多的东西：更多的代码库、更多的工具、更多的构建管道、更多的服务器、更多的域名等"},{"id":"前端技术/手写题.md","filename":"手写题.md","basename":"手写题","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"手写题防抖节流防抖：n 秒内只执行一次，如果 n 秒内再次触发，则重新计算时间（多用于输入框）节流：n 秒内只会执行一次，稀释执行频率手写：const tools = {  debounce: (fn, wait = 500) =&gt; {    let timer = null;    return function () {      if (timer) {        clearTimeout(timer);      }      timer = setTimeout(() =&gt; {        fn.apply(this, arguments);      }, wait);    };  },  throttle: (fn, wait = 500) =&gt; {    let canrun = true;    return function () {      if (!canrun) {        return;      }      canrun = false;      setTimeout(() =&gt; {        fn.apply(this, arguments);        canrun = true;      }, wait);    };  },};手写工厂模式class SuperAdmin {  constructor() {    this.name = &#x27;超级管理员&#x27;;    this.viewPage = [&#x27;首页&#x27;, &#x27;通讯录&#x27;, &#x27;发现页&#x27;, &#x27;应用数据&#x27;, &#x27;权限管理&#x27;];  }}class Admin {  constructor() {    this.name = &#x27;管理员&#x27;;    this.viewPage = [&#x27;首页&#x27;, &#x27;通讯录&#x27;, &#x27;发现页&#x27;, &#x27;应用数据&#x27;, &#x27;权限管理&#x27;];  }}class NormalUser {  constructor() {    this.name = &#x27;普通用户&#x27;;    this.viewPage = [&#x27;首页&#x27;, &#x27;通讯录&#x27;, &#x27;发现页&#x27;, &#x27;应用数据&#x27;, &#x27;权限管理&#x27;];  }}class UserFactory {  getFactory(role) {    switch (role) {      case &#x27;superAdmin&#x27;:        return new SuperAdmin();        break;      case &#x27;admin&#x27;:        return new Admin();        break;      case &#x27;user&#x27;:        return new NormalUser();        break;      default:        throw new Error(&#x27;参数错误, 可选参数:superAdmin、admin、user&#x27;);    }  }}let uesr = new UserFactory();uesr.getFactory(&#x27;superAdmin&#x27;);uesr.getFactory(&#x27;admin&#x27;);uesr.getFactory(&#x27;user&#x27;);手写数组去重// 方法1const uniqBy = (arr, key) =&gt; {  return [...new Map(arr.map((item) =&gt; [item[key], item])).values()];};const singers = [  { id: 1, name: &#x27;Leslie Cheung&#x27; },  { id: 1, name: &#x27;Leslie Cheung&#x27; },  { id: 2, name: &#x27;Eason Chan&#x27; },];console.log(uniqBy(singers, &#x27;id&#x27;));// 方法2function unique(arr) {  return Array.from(new Set(arr));}手写数组扁平化const str = [0, 1, [2, [3, 4]]].toString();// &#x27;0, 1, 2, 3, 4&#x27;const arr = str.split(&#x27;,&#x27;);// [&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]const newArr = arr.map((item) =&gt; +item);// [0, 1, 2, 3, 4]const flatten = (arr) =&gt;  arr    .toString()    .split(&#x27;,&#x27;)    .map((item) =&gt; +item);手写发布订阅 EventEmitterclass EventEmitter {  constructor() {    this.events = {};  }  on(name, cb) {    if (!this.events[name]) {      this.events[name] = [cb];    } else {      this.events[name].push(cb);    }  }  emit(name, ...arg) {    if (this.events[name]) {      this.events[name].forEach((fn) =&gt; {        fn.call(this, ...arg);      });    }  }  off(name, cb) {    if (this.events[name]) {      this.events[name].filter((fn) =&gt; {        return fn != cb;      });    }  }  once(name, fn) {    let onlyOnce = () =&gt; {      fn.apply(this, arguments);      this.off(name, onlyOnce);    };    this.on(name, onlyOnce);    return this;  }}手写获取 url 参数function getQuery() {  let result = {};  let search = decodeURI(window.location.search);  if (!search) {    return result;  }  search    .slice(1)    .split(&#x27;&amp;&#x27;)    .forEach((item, i) =&gt; {      let k = item.split(&#x27;=&#x27;)[0];      let v = item.split(&#x27;=&#x27;)[1];      result[k] = v;    });  return result;}手写数组乱序function mixArr(arr) {  return arr.sort(() =&gt; {    return Math.random() - 0.5;  });}判断括号字符串是否有效function is_leagl_brackets(string) {  var array = [];  for (var i = 0; i &lt; string.length; i++) {    var item = string[i];    if (item === &#x27;(&#x27;) {      array.push(&#x27;(&#x27;);    } else if (item === &#x27;)&#x27;) {      if (array.length === 0) {        return false;      } else {        array.pop();      }    } else {      continue;    }  }  return array.length === 0;}console.log(&#x27;(asd):&#x27;, is_leagl_brackets(&#x27;(asd)&#x27;));console.log(&#x27;asd(asd(adsfsdf(asdf())))):&#x27;, is_leagl_brackets(&#x27;asd(asd(adsfsdf(asdf()))))&#x27;));求斐波那契数列第 N 项// 求斐波那契数列（Fibonacci）中的第n项 1 1 2 3 5 8 13 21 ...// 在控制台输出 斐波那契竖列的前12项function getFib(n) {  if (n === 1 || n === 2) {    return 1;  }  var n1 = 1;  var n2 = 1;  var fib;  for (var i = 3; i &lt;= n; i++) {    fib = n1 + n2;    n1 = n2;    n2 = fib;  }  return fib;}// console.log(getFib(12)); // 144for (var i = 1; i &lt;= 12; i++) {  console.log(getFib(i));}"},{"id":"前端技术/模块.md","filename":"模块.md","basename":"模块","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"模块化机制常用 IIFE 模式实现模块化：匿名函数自调用，将数据和行为封装到一个函数内部，外部依赖通过参数传入常见的模块规范：ES6 模块（esm）、CommonJS、CMD、AMD什么是 Tree Shaking消除无用的 js 代码的算法，集成在 webpack 和 rollup 等打包工具中CommonJS通用环境，比如 nodejs，不局限于浏览器每个模块提供一个 module 变量一个文件一个模块可以动态引入，所以不支持树摇特点：语法相对简单，浏览器不直接支持AMD明确基于浏览器基本退出了历史舞台RequireJS 是 AMD 的一个实现特点：异步加载、同一个文件定义一个模块ESMesm 是 javascript 的标准功能，是语言规范，是官方明确的发展方向，cjs 也只是 esm 出来之前的临时解决方案而已相比 cjs 的好处是可以使用 tree shaking，支持静态分析模块脚本自动采用严格模式模块顶层的 this 关键字返回 undefinedesm 是编译时加载，也就是只有所有 import 的模块都加载完成，才会开始执行，这有利于引擎的静态分析，加载的过程会先于代码的执行，却也导致 import 导入语句不能在函数或者 if 语句中执行。es2020 提案引入 import() 函数，用来动态加载模块，并且可以用在函数和 if 语句中模块缓存：同一个模块如果加载多次，只会执行一次export 导出的是值引用，当模块内部的值被修改时，esm 可以获取到被修改后的值，cjs 获取不到CommonJS，ESM 区别都属于不同的模块规范，require 属于 CommonJS 规范，import 属于 ES modulerequire 支持动态导入，import 不支持它们都是一种模块规范，例如 Node 使用的就是 CommonJS 规范。ES module 则是语言标准上的模块规范 区别：CommonJS 模块使用 require() 和 module.exports，ES6 模块使用 import 和 exportCommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用CommonJS 模块是运行时加载，ES6 模块是编译时输出接口，是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成，而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段ES6 模块之中，顶层的 this 指向 undefined；CommonJS 模块的顶层 this 指向当前模块UMD通用模块定义规范（Universal Module Definition）可以通过运行时或者编译时让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。未来同一个 JavaScript 包运行在浏览器端、服务区端甚至是 APP 端都只需要遵守同一个写法就行了是前端实现跨平台技术需求发展下的产物它没有自己专有的规范，是集结了 CommonJs、CMD、AMD 的规范于一身，一个简单实现的例子：((root, factory) =&gt; {  if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) {    // AMD    define([&#x27;jquery&#x27;], factory);  } else if (typeof exports === &#x27;object&#x27;) {    // CommonJS    var $ = requie(&#x27;jquery&#x27;);    module.exports = factory($);  } else {    // 没有模块环境，直接挂载在全局对象上    root.testModule = factory(root.jQuery);  }})(this, ($) =&gt; {  return {    name: &#x27;我是一个umd模块&#x27;,  };});/*  定义一个 IIFE，  在定义模块的时候检测当前使用环境和模块的定义方式，  将各种模块化定义方式转化为同样一种写法，\t先判断当前环境如果支持 AMD，则使用 require.js 提供的 define 函数定义模块，\t再判断是否 cjs，如果是则使用 cjs 相应的模块定义方法进行模块定义，  如果还需要兼容其他类型的模块系统也是类似思路去兼容，  最后如果没有模块环境，直接挂载在全局对象上，这个传进来的全局对象 this，其值可能是 window 或者 global，视运行环境而定*/"},{"id":"前端技术/虚拟列表.md","filename":"虚拟列表.md","basename":"虚拟列表","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"虚拟列表是什么不能分页的情况下渲染多条（上万级别）数据只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能实现描述首屏加载时，只加载可视区域内需要的列表项滚动发生时，计算出可视区域内的列表项，并将非可视区域内存在的列表项销毁问题列表项动态高度问题列表项包含文字或图片，图片加载完成是异步的，无法预判高度对组件属性 itemSize 进行扩展，支持传递类型为数字、数组、函数将列表项渲染到屏幕外，对其高度进行测量并缓存，然后再将其渲染至可视区域内以预估高度先行渲染，然后获取真实高度并缓存使用新 api：ResizeObserver 监听图片尺寸变化，但需要考虑浏览器兼容性scroll 事件频繁触发问题IntersectionObserver"},{"id":"前端技术/设计模式.md","filename":"设计模式.md","basename":"设计模式","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"设计模式设计模式原则单一职责原则一个程序只做好一件事如果功能过于复杂就拆分开，每个部分保持独立比如 Promise，每个 then 只做一件事开放/封闭原则对扩展开放，对修改封闭增加需求时，扩展新代码，而非修改已有代码比如 Promise，如果新增需求，扩展 then比如为表单校验类增加拓展接口而不是修改内部代码// 优化前let checkType = function (str, type) {  switch (type) {    case &#x27;email&#x27;:      return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);    case &#x27;mobile&#x27;:      return /^1[3|4|5|7|8][0-9]{9}$/.test(str);    case &#x27;tel&#x27;:      return /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str);    default:      return true;  }};// const result = checkType(&#x27;165226226326&#x27;,&#x27;mobile&#x27;)// 优化后let checkType = (function () {  let rules = {    email(str) {      return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);    },    mobile(str) {      return /^1[3|4|5|7|8][0-9]{9}$/.test(str);    },  };  //暴露接口  return {    //校验    check(str, type) {      return rules[type] ? rules[type](str) : false;    },    //添加规则    addRule(type, fn) {      rules[type] = fn;    },  };})();console.log(checkType.check(&#x27;188170239&#x27;, &#x27;mobile&#x27;));checkType.addRule(&#x27;money&#x27;, function (str) {  return /^[0-9]+(.[0-9]{2})?$/.test(str);});console.log(checkType.check(&#x27;18.36&#x27;, &#x27;money&#x27;));里氏替换原则子类能覆盖父类父类能出现的地方子类就能出现接口隔离原则保持接口的单一独立依赖倒转原则面向接口编程，依赖于抽象而不依赖于具体使用方只关注接口而不关注具体类的实现设计模式分类创建型单例模式原型模式工厂模式抽象工厂模式建造者模式组合型（结构型）适配器模式装饰器模式代理模式外观模式桥接模式组合模式享元模式行为型观察者模式迭代器模式策略模式模板方法模式职责链模式命令模式备忘录模式状态模式访问者模式中介者模式解释器模式工厂模式场景需要依赖具体环境创建不同实例，实例都有相同的行为扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以示例class Product {  constructor(name) {    this.name = name;  }  init() {    console.log(&#x27;init&#x27;);  }  fun() {    console.log(&#x27;fun&#x27;);  }}class Factory {  create(name) {    return new Product(name);  }}let factory = new Factory();let p = factory.create(&#x27;p1&#x27;);p.init();p.fun();单例模式场景：登录框、vuex 和 redux 中的 store一个类只有一个实例，并提供一个访问它的全局访问点划分命名空间，减少全局变量只会实例化一次。简化了代码的调试和维护，节约内存有可能导致模块间的强耦合，从而不利于单元测试示例class LoginForm {  constructor() {    this.state = &#x27;hide&#x27;;  }  show() {    if (this.state === &#x27;show&#x27;) {      return;    }    this.state = &#x27;show&#x27;;    console.log(&#x27;显示&#x27;);  }  hide() {    if (this.state === &#x27;hide&#x27;) {      return;    }    this.state = &#x27;hide&#x27;;    console.log(&#x27;隐藏&#x27;);  }}LoginForm.getInstance = (function () {  let instance;  return function () {    if (!instance) {      instance = new LoginForm();    }    return instance;  };})();let obj1 = LoginForm.getInstance();obj1.show();let obj2 = LoginForm.getInstance();obj2.hide();console.log(obj1 === obj2); // true适配器模式将一个类的接口转化为另外一个接口，以满足需求，使类之间接口不兼容问题通过适配器得以解决可以让任何两个没有关联的类一起运行，提高了类的复用额外对象的创建，非直接调用，存在一定的开销场景：整合第三方 SDK、封装旧接口适配器与代理模式相似，适配器模式提供一个不同的接口，代理模式提供一模一样的接口示例class Plug {  getName() {    return &#x27;iphone充电头&#x27;;  }}class Target {  constructor() {    this.plug = new Plug();  }  getName() {    return this.plug.getName() + &#x27; 适配器Type-c充电头&#x27;;  }}let target = new Target();target.getName();// 自己封装的ajax， 使用方式如下ajax({ url: &#x27;/getData&#x27;, type: &#x27;Post&#x27;, dataType: &#x27;json&#x27;, data: { test: 111 } }).done(function () {});// 因为历史原因，代码中全都是：// $.ajax({....})// 做一层适配器var $ = {  ajax: function (options) {    return ajax(options);  },};装饰者模式在不改变原对象的基础上，动态的给对象添加额外职责，对其进行包装扩展，是实现继承的一种替代方案装饰类和被装饰类都只关心自身的核心业务，实现了解耦方便动态的扩展功能，且提供了比继承更多的灵活性缺点多层装饰比较复杂常常会引入许多小对象，看起来比较相似，实际功能大相径庭代理模式为一个对象提供一个代用品或占位符，以便控制对它的访问能将代理对象与被调用对象分离，降低耦合度，可以起到保护目标对象的作用代理对象可以扩展目标对象的功能，通过修改代理对象就可以了，符合开闭原则场景做授权控制HTML 元素事件代理ES6 的 proxy缺点处理请求速度可能有差别，非直接访问存在开销外观模式为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用减少系统相互依赖，提高灵活性、安全性缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适场景兼容浏览器事件绑定设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作观察者模式（发布订阅模式）定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式缺点：过度使用会导致对象与对象之间的联系弱化，会导致难以跟踪维护和理解场景DOM 事件vue 事件总线状态模式允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类迭代器模式提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示访问一个聚合对象的内容而无需暴露它的内部表示为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式场景Array.prototype.forEachES6 Iterator示例class Iterator {  constructor(conatiner) {    this.list = conatiner.list;    this.index = 0;  }  next() {    if (this.hasNext()) {      return this.list[this.index++];    }    return null;  }  hasNext() {    if (this.index &gt;= this.list.length) {      return false;    }    return true;  }}class Container {  constructor(list) {    this.list = list;  }  getIterator() {    return new Iterator(this);  }}let container = new Container([1, 2, 3, 4, 5]);let iterator = container.getIterator();while (iterator.hasNext()) {  console.log(iterator.next());}桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化有助于独立地管理各组成部分， 把抽象化与实现化解耦大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少示例class Color {  constructor(name) {    this.name = name;  }}class Shape {  constructor(name, color) {    this.name = name;    this.color = color;  }  draw() {    console.log(`${this.color.name} ${this.name}`);  }}let red = new Color(&#x27;red&#x27;);let yellow = new Color(&#x27;yellow&#x27;);let circle = new Shape(&#x27;circle&#x27;, red);circle.draw();let triangle = new Shape(&#x27;triangle&#x27;, yellow);triangle.draw();组合模式通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象示例class TrainOrder {  create() {    console.log(&#x27;创建火车票订单&#x27;);  }}class HotelOrder {  create() {    console.log(&#x27;创建酒店订单&#x27;);  }}class TotalOrder {  constructor() {    this.orderList = [];  }  addOrder(order) {    this.orderList.push(order);    return this;  }  create() {    this.orderList.forEach((item) =&gt; {      item.create();    });    return this;  }}// 可以在购票网站买车票同时也订房间let train = new TrainOrder();let hotel = new HotelOrder();let total = new TotalOrder();total.addOrder(train).addOrder(hotel).create();原型模式用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象示例class Person {  constructor(name) {    this.name = name;  }  getName() {    return this.name;  }}class Student extends Person {  constructor(name) {    super(name);  }  sayHello() {    console.log(`Hello， My name is ${this.name}`);  }}let student = new Student(&#x27;xiaoming&#x27;);student.sayHello();策略模式组成：一组策略类，封装了具体的算法，并负责具体的计算过程；环境类，接受客户的请求，将请求委托给某一个策略定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换可以有效的避免多重条件选择语句提供了对开放-封闭原则的支持，将算法封装在独立的策略中，使得它们易于切换，理解，易于扩展场景一个系统需要动态地在几种算法中选择一种表单验证模板方法模式模板方法模式由抽象父类、具体的实现子类组成。在抽象父类中封装了子类的算法框架，实现一些公共方法和封装子类中所有方法的执行顺序子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法场景一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复示例class Beverage {  constructor({ brewDrink, addCondiment }) {    this.brewDrink = brewDrink;    this.addCondiment = addCondiment;  }  /* 烧开水，共用方法 */  boilWater() {    console.log(&#x27;水已经煮沸=== 共用&#x27;);  }  /* 倒杯子里，共用方法 */  pourCup() {    console.log(&#x27;倒进杯子里===共用&#x27;);  }  /* 模板方法 */  init() {    this.boilWater();    this.brewDrink();    this.pourCup();    this.addCondiment();  }}/* 咖啡 */ const coffee = new Beverage({  /* 冲泡咖啡，覆盖抽象方法 */  brewDrink: function () {    console.log(&#x27;冲泡咖啡&#x27;);  },  /* 加调味品，覆盖抽象方法 */  addCondiment: function () {    console.log(&#x27;加点奶和糖&#x27;);  },});coffee.init();命令模式将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行示例// 接收者类class Receiver {  execute() {    console.log(&#x27;接收者执行请求&#x27;);  }}// 命令者class Command {  constructor(receiver) {    this.receiver = receiver;  }  execute() {    console.log(&#x27;命令&#x27;);    this.receiver.execute();  }}// 触发者class Invoker {  constructor(command) {    this.command = command;  }  invoke() {    console.log(&#x27;开始&#x27;);    this.command.execute();  }}// 仓库const warehouse = new Receiver();// 订单const order = new Command(warehouse);// 客户const client = new Invoker(order);client.invoke();中介者模式所有的相关对象都通过中介者对象来通信，而不是互相引用使网状的多对多关系变成了相对简单的一对多关系类似于观察者模式，但是单向的，由中介者统一管理例如表单的 onchange 事件，无论是输入框还是单选按钮，都统一与 onchange 通信，由 onchange 统一处理事件类型的差异，实现各个事件间的解耦"},{"id":"前端技术/语言基础.md","filename":"语言基础.md","basename":"语言基础","path":"/home/runner/work/my-book/my-book/前端技术","relative_path":"前端技术","output_path":"/home/runner/work/my-book/my-book/dist/前端技术","content":"arguments是一个类数组对象，存储传入函数的全部参数。（类数组对象：属性是 0 开始的下标，并且有 length 属性，但没有数组独有的方法）callee 属性：当前函数的引用妙用：递归、参数累加为什么 ES6 不推荐使用 arguments.callee()访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响浏览器的性能，还会影响闭包。当一个函数必须调用自身的时候，假如它是函数表达式则给它命名，或者使用函数声明，避免使用 calleedelete 机制使用 delete 操作符并不会直接释放内存，与 V8 引擎有关最有效的方式，应该是将不需要的属性设置为 undefined在实际业务中可以考虑使用 Map 来代替 object，map 包装对象有 delete 方法，比以上方式都快0.1 + 0.2 为什么不等于 0.3二进制模拟十进制进行计算时的精度问题进制转换：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失对阶运算：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0 舍 1 入），尾数位移时可能会发生数丢失的情况，影响精度解决使用 Number.EPSILON 误差范围Number.EPSILON 表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值function isEqual(a, b) {  return Math.abs(a - b) &lt; Number.EPSILON;}console.log(isEqual(0.1 + 0.2, 0.3)); // truees6 新特性箭头函数Promise拓展运算符和解构赋值对象和数组解构let const模板字符串函数的参数默认值classfor…of 和 for…in模块尾调用优化 TCOvar let constconst 用于声明常量，const 声明的一般类型的变量，不能修改const 声明的对象，属性可以被修改用 var 重复声明不会报错，但 let 和 const 会var 会使变量提升，变量可以在 var 声明之前使用。let 和 const 不会使变量提升，提前使用会报错。柯里化含义：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。意义：让人们将关注的重点聚焦到函数本身，而不因冗余的数据参数分散注意力，单一参数的纯函数是最简单的，目的单纯、职责单一、灵活且通用缺点：过度使用会占用较大的堆栈空间在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用把一个多参数的函数转化为单参数函数的方法 好处：提高程序性能使代码模块化，减少耦合增强其可维护性经过柯里化之后，函数的通用性有所降低，但是适用性有所提高// 手写柯里化const add = function (a, b, c) {  return a + b + c;};function curry(fn) {  return function curryFun(...args) {    if (args.length &lt; fn.length) {      return function () {        return curryFun(...args.concat(Array.from(arguments)));      };    }    return fn(...args);  };}const curried = curry(add);const a = curried(1)(9)(3);const b = curried(2, 8)(6);console.log({ a, b });闭包函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量能够访问已经被销毁的执行期上下文的活动对象的函数、有权访问另一个函数作用域中的变量的函数函数做为参数传递或在尾部 return，并且子函数在外调用，形成闭包，子函数所在的父函数的作用域不会被释放，子函数的作用域中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象应用：设计私有的方法和变量。优点：可以避免全局变量的污染缺点：常驻内存会增大内存使用量，会躲掉垃圾回收机制，使用不当很容易造成内存泄露。如何优化闭包通过解除对匿名函数的引用，可以将匿名函数占用的内存安全释（将闭包创建的函数赋值为 null）function outerFun(outerArg) {  return function () {    console.log(&#x27;这里是内部匿名函数&#x27;);    console.log(&#x27;可以访问包含函数的变量&#x27;, outerArg);  };}var create = outerFun(&#x27;hi&#x27;);// 创建一个函数，是 outerFun 中返回的匿名函数create();// 调用函数，是调用匿名函数create = null;// 释放对匿名函数的引用如果没有对匿名函数的引用，匿名函数执行完之后自动销毁，就可以做到减少占用内存的问题。利用匿名函数，制造私有作用域（块级作用域），这样匿名函数执行完之后可以将引用的活动对象销毁。垃圾回收现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数标记清除（主流）垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记从根部出发将能触及到的对象的标记清除那些还存在标记的变量被视为准备删除的变量销毁那些带标记的值引用计数如果一个对象没有被其他对象引用，那它将被垃圾回收机制回收。跟踪记录每个值被引用的次数当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来缺点：循环引用会造成对象无法被回收如何避免垃圾回收对象尽量复用数组优化： 将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。引起内存泄漏的操作全局变量闭包dom 清除，事件绑定未清除未清除的计时器setTimeout 的第一个参数使用字符串而非函数引用循环：在两个对象彼此引用且彼此保留时，就会产生一个引用循环console.log 打印了太大的变量js 数据类型基本类型：number、string、boolean、undefined、null、Symbol、BigInt（BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数）栈内存：是一种特殊的线性表，它具有后进先出的特性，存放基本类型堆内存：存放引用类型（在栈内存中存一个基本类型值保存对象在堆内存中的地址，用于引用这个对象)基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据引用数据类型存储在堆内存中，因为引用数据类型占据空间大、占用内存不固定。 如果存储在栈中，将会影响程序运行的性能引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体引用类型：Object、Array、Function、内置对象（Date、Math 等等）数据类型的判断typeof：能判断所有值类型，函数。不可对 null、对象、数组进行精确判断，因为都返回 objectinstanceof：能判断对象类型，不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型使用 Object.prototype.toString.call()，所有原始数据类型都能判断，还有 Error 对象，Date 对象等如何判断变量是否为数组Array.isArray(arr)arr.__proto__ === Array.prototypearr instanceof ArrayObject.prototype.toString.call(arr)null 和 undefined 区别null 表示没有对象，即该处不应该有值。undefined 表示缺少值，即此处应该有值，但没有定义。typeof null 为 objecttypeof undefined 为 undefinednull 和 undefined 转换成 number 数据类型时，null 转成 0 undefined 转成 NaN为什么会出现精度丢失这跟浮点数在计算机内部（用二进制存储）的表示方法有关JS 采用 IEEE 754 标准的 64 位双精度浮点数表示法，这个标准是 20 世纪 80 年代以来最广泛使用的浮点数运算标准，为许多 CPU 与浮点运算器所采用，也被很多语言如 java、python 采用。这个标准，会让大部分的十进制小数都不能用二进制浮点数来精确表示（比如转成二进制就会变成无限小数）。所以一般情况下，你输入的十进制小数仅由实际存储在计算机中的近似的二进制浮点数表示。然而，许多语言在处理的时候，在一定误差范围内（通常极小）会将结果修正为正确的目标数字，而不是像 JS 一样将存在误差的真实结果转换成最接近的小数输出深拷贝、浅拷贝浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign 或 展开运算符深拷贝：JavaScript 包含基本类型（如字符串、数字、布尔）和引用类型（如数组、对象）基本数据类型按值访问、引用类型的值按照引用访问直接复制引用类型的值，实际上是一个内存地址的指针，修改新的变量，原变量也会被修改手写深拷贝：function deepCopy(obj) {  // 1、判断是否是简单数据类型，  if (typeof obj == &#x27;object&#x27;) {    // 2、复杂数据类型    var result = obj.constructor == Array ? [] : {};    for (let i in obj) {      result[i] = typeof obj[i] == &#x27;object&#x27; ? deepCopy(obj[i]) : obj[i];    }  } else {    // 简单数据类型 直接赋值    var result = obj;  }  return result;}描述 Promise用来解决回调地狱实例化一个 Promise 需要传入一个函数，业务代码在这个函数中执行，这个函数往往接收两个参数 resolve 和 reject在函数中业务代码执行成功了，调用 resolve 函数，可以把 Promise 的状态变为已成功，通过参数把成功的结果传递出去，能在这个 Promise 对象的 then 方法中获取，then 方法可以链式调用多次，then 方法接受一个函数作为参数，这个函数的参数就是 resolve 传递出来的结果在函数中业务代码执行失败了，调用 reject 函数，可以把 Promise 的状态变为已失败，通过参数把失败的结果传递出去，能在这个 Promise 对象的 catch 方法中获取，catch 方法和 then 方法用法一致，也是接受一个函数作为参数无论结果如何都会走 finally 方法Promise.all 接受一个数组作为参数，都是 Promise 实例，调用 Promise.all 的时候，这些实例会一起开始执行，返回一个结果数组，只有全部实例的状态是已完成，结果的状态才会是已完成，只要有一个失败，结果就是失败Promise.race 接受一个数组作为参数，都是 Promise 实例，返回一个结果数组，调用 Promise.race 的时候，传进去的实例是竞赛关系，哪个结果获得的快，就返回那个结果手写 Promise// 在这里用Symbol定义三种状态，防止外部改变状态const Pending = Symbol(&#x27;Pending&#x27;);// 进行中const Fulfilled = Symbol(&#x27;Fulfilled&#x27;);// 已成功const Rejected = Symbol(&#x27;Rejected&#x27;);// 已失败const handleValue = (promise, x, resolve, reject) =&gt; {  // 循环引用，自己等待自己完成，会出错，用reject传递出错误原因  if (promise === x) {    return reject(new TypeError(&#x27;检测到Promise的链式循环引用&#x27;));  }  // 确保递归解析中只传递出去一次值  let once = false;  if ((x !== null &amp;&amp; typeof x === &#x27;object&#x27;) || typeof x === &#x27;function&#x27;) {    try {      // 防止重复去读取x.then      let then = x.then;      // 判断x是不是Promise      if (typeof then === &#x27;function&#x27;) {        //调用then实例方法处理Promise执行结果        then.call(          x,          (y) =&gt; {            if (once) return;            once = true;            // 防止Promise中Promise执行成功后又传递一个Promise过来，            // 要做递归解析。            handleValue(promise, y, resolve, reject);          },          (r) =&gt; {            if (once) return;            once = true;            reject(r);          }        );      } else {        // 如果x是个普通对象，直接调用resolve(x)        resolve(x);      }    } catch (err) {      if (once) return;      once = true;      reject(err);    }  } else {    // 如果x是个原始值，直接调用resolve(x)    resolve(x);  }};class Promise {  constructor(executor) {    this.status = Pending;    //存储 Promise 的状态    this.value = undefined;    //存储executor函数中业务代码执行成功的结果    this.reason = undefined;    //存储executor函数中业务代码执行失败的原因    this.onFulfilled = [];    //executor函数中业务代码执行成功回调函数的集合    this.onRejected = [];    //executor函数中业务代码执行失败回调函数的集合    const resolve = (value) =&gt; {      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。      if (this.status === Pending) {        this.status = Fulfilled;        this.value = value;        // 依次调用成功回调函数        this.onFulfilled.forEach((fn) =&gt; fn());      }    };    const reject = (value) =&gt; {      // 只有当状态为 Pending 才会改变，来保证一旦状态改变就不会再变。      if (this.status === Pending) {        this.status = Rejected;        this.reason = value;        // 依次调用失败回调函数        this.onRejected.forEach((fn) =&gt; fn());      }    };    try {      executor(resolve, reject);    } catch (error) {      reject(error);    }  }  then(onFulfilled, onRejected) {    onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : (v) =&gt; v;    onRejected =      typeof onRejected === &#x27;function&#x27;        ? onRejected        : (err) =&gt; {            throw err;          };    let promise = new Promise((resolve, reject) =&gt; {      if (this.status === Fulfilled) {        setTimeout(() =&gt; {          try {            let x = onFulfilled(this.value);            handleValue(promise, x, resolve, reject);          } catch (error) {            reject(error);          }        }, 0);      }      if (this.status === Rejected) {        if (onRejected &amp;&amp; typeof onRejected === &#x27;function&#x27;) {          setTimeout(() =&gt; {            try {              let x = onRejected(this.reason);              handleValue(promise, x, resolve, reject);            } catch (error) {              reject(error);            }          }, 0);        }      }      if (this.status === Pending) {        this.onFulfilled.push(() =&gt; {          setTimeout(() =&gt; {            try {              let x = onFulfilled(this.value);              handleValue(promise, x, resolve, reject);            } catch (error) {              reject(error);            }          }, 0);        });        if (onRejected &amp;&amp; typeof onRejected === &#x27;function&#x27;) {          this.onRejected.push(() =&gt; {            setTimeout(() =&gt; {              try {                let x = onRejected(this.reason);                handleValue(promise, x, resolve, reject);              } catch (error) {                reject(error);              }            }, 0);          });        }      }    });    return promise;  }  static resolve(param) {    if (param instanceof Promise) {      return param;    }    return new Promise((resolve, reject) =&gt; {      if (param &amp;&amp; Object.prototype.toString.call(param) === &#x27;[object Object]&#x27; &amp;&amp; typeof param.then === &#x27;function&#x27;) {        setTimeout(() =&gt; {          param.then(resolve, reject);        }, 0);      } else {        resolve(param);      }    });  }  static reject(param) {    return new Promise((resolve, reject) =&gt; {      reject(param);    });  }  static all(promises) {    //将参数promises转为一个真正的数组    promises = Array.from(promises);    return new Promise((resolve, reject) =&gt; {      const length = promises.length;      let value = [];      if (length) {        value = Array.apply(null, { length: length });        for (let i = 0; i &lt; length; i++) {          Promise.resolve(promises[i]).then(            (res) =&gt; {              value[i] = res;              if (value.length == length) {                resolve(value);              }            },            (err) =&gt; {              reject(err);              return;            }          );        }      } else {        resolve(value);      }    });  }  static race(promises) {    //将参数promises转为一个真正的数组    promises = Array.from(promises);    return new Promise((resolve, reject) =&gt; {      const length = promises.length;      if (length) {        for (let i = 0; i &lt; length; i++) {          Promise.resolve(promises[i]).then(            (res) =&gt; {              resolve(res);              return;            },            (err) =&gt; {              reject(err);              return;            }          );        }      } else {        return;      }    });  }}描述 async/awaitasync 用来声明函数，告诉解释器这是一个异步函数，只有 async 声明的函数里面才能用 awaitawait 用来等待一个 promise 执行结束，可以返回 promise 对象 resolve 出来的结果如果 await 等待的这个 Promise 对象出错或者结果为 reject，可以通过 try catch 捕获到错误Array 的方法isArray()indexOf、lastIndexOftoString() 返回字符串，逗号分隔push(o:any) 在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度，会改变原数组pop() 删除数组的最后一个元素，并返回该元素，会改变原数组shift() 删除数组的第一个元素，并返回该元素，会改变原数组unshift(o:any) 在数组的第一个位置添加元素，并返回添加新元素后的数组长度，会改变原数组join(o:str) 以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔concat(o:array) 用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变reverse 用于颠倒排列数组元素，返回改变后的数组，会改变原数组slice(start, end) 用于提取目标数组的一部分，返回一个新数组，原数组不变splice(start, count, addElement1, addElement2, …) 用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。会改变原数组sortmap、forEach、filter、some、every、reduce、reduceRightString 的方法split(o:str) 按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组toLowerCase、toUpperCasetrim 用于去除字符串两端的空格，返回一个新字符串，不改变原字符串indexOf、lastIndexOfsubstr 用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 和 substring 方法的作用相同substring(start, end) 用于从原字符串取出子字符串并返回，不改变原字符串，跟 slice 方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）slice(start, end) 用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）concat 用于连接两个字符串，返回一个新字符串，不改变原字符串charAt(num) 返回指定位置的字符，参数是从 0 开始编号的位置，这个方法完全可以用数组下标替代fromCharCode 方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串btoa 任意值转为 Base64 编码atob Base64 编码转为原来的值数组的遍历迭代方法for in以任意顺序遍历一个对象自有的、继承的、可枚举的、非 Symbol 的属性。对于每个不同的属性，语句都会被执行。如果你只要考虑对象本身的属性，而不是它的原型，那么使用 getOwnPropertyNames() 或执行 hasOwnProperty() 来确定某属性是否是对象本身的属性。for ofES6 新增，用来替代 for in 和 forEach，可以遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代(Iterable data)的数据结构。forEach遍历数组中的每一项，没有返回值，对原数组没有影响，注意：在 forEach 中用 return 不会返回，break 不会跳出，函数会继续执行。map返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。filter返回通过过滤的元素，不改变原来的数组。some用于检测数组中的某个元素是否满足指定条件,返回 boolean 值，不改变原数组。every用于检测数组中的所有元素是否都符合指定条件，返回 boolean 值，不改变原数组。reduce接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduceRight和 reduce() 功能是一样的，它是从数组的末尾处向前开始计算。find 返回通过测试（函数内判断）的数组的第一个元素的值。forEach、for in、for of 三者区别：forEach 更多的用来遍历数组for in 一般常用来遍历对象或 jsonfor of 数组对象都可以遍历，遍历对象需要通过和 Object.keys()for in 循环出的是 key，for of 循环出的是 valueapply、call、bind都是用来改变函数 this 的指向区别：apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用，bind 与 apply/call 一样都能改变函数 this 指向，但 bind 并不会立即执行函数，而是返回一个绑定了 this 的新函数，你需要再次调用此函数才能达到最终执行手写// callFunction.prototype.myCall = function (context) {  // 判断调用对象  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  // 首先获取参数  let args = [...arguments].slice(1);  let result = null;  // 判断 context 是否传入，如果没有传就设置为 window  context = context || window;  // 将被调用的方法设置为 context 的属性  // this 即为我们要调用的方法  context.fn = this;  // 执行要被调用的方法  result = context.fn(...args);  // 删除手动增加的属性方法  delete context.fn;  // 将执行结果返回  return result;};// applyFunction.prototype.myApply = function (context) {  if (typeof this !== &#x27;function&#x27;) {    throw new Error(&#x27;Type error&#x27;);  }  let result = null;  context = context || window;  // 与上面代码相比，我们使用 Symbol 来保证属性唯一  // 也就是保证不会重写用户自己原来定义在 context 中的同名属性  const fnSymbol = Symbol();  context[fnSymbol] = this;  // 执行要被调用的方法  if (arguments[1]) {    result = context[fnSymbol](...arguments[1]);  } else {    result = context[fnSymbol]();  }  delete context[fnSymbol];  return result;};// bindFunction.prototype.myBind = function (context) {  // 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) {    throw new Error(&quot;Type error&quot;);  }  // 获取参数  const args = [...arguments].slice(1),  const fn = this;  return function Fn() {    return fn.apply(      this instanceof Fn ? this : context,      // 当前的这个 arguments 是指 Fn 的参数      args.concat(...arguments)    );  };};尾调用和尾递归指某个函数的最后一步是调用另一个函数递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生栈溢出错误但对于尾递归来说，由于只存在一个调用记录，所以不会发生栈溢出function factorial(num) {  if (num === 1) return 1;  return num * factorial(num - 1);}console.log(factorial(5));console.log(factorial(10));词法作用域和动态作用域JavaScript 采用词法作用域，也就是静态作用域函数的作用域在函数定义的时候就决定了而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定var value = 1;function foo() {  console.log(value);}function bar() {  var value = 2;  foo();}bar();// 1"}]},{"id":"index.md","filename":"index.md","basename":"index","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","content":"✏ 学习总结和日常笔记build by doc-builder"},{"id":"其他.md","filename":"其他.md","basename":"其他","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","content":"Restful用 URL 定位资源，用 HTTP 描述操作应该将 API 的版本号放入 URL每个网址代表一种资源，所以网址中不能有动词，只能有名词，往往与数据库的表格名对应对于资源的具体操作类型 CURD，由 HTTP 动词表示，例如查询用 GET 方式请求使用 HTTP 状态码表达处理结果，例如成功为 200，无权限 403，而不能全都是 200返回尽量使用 JSON 格式，避免使用 XMLJWT组成base64UrlEncode(header) + ‘.’ + base64UrlEncode(payload) + ‘.’ + signaturesignature：签证信息，由 HMAC_SHA256((base64UrlEncode(header) + ‘.’ + base64UrlEncode(payload)), ‘密钥’) 生成payload 即载体，存放过期时间用户信息等等，不应该在载体存放敏感信息，因为该部分是客户端可解密的部分防篡改通过比对 signature，用客户端传过来的这个 token，把头部和载体拿出来再算一遍 signature，和 token 里面带的那个 signature 比对是否一致缺点缺点就是一旦签发不可撤销单元测试定义：是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。前端开发我只对较为复杂的功能做单元测试，一些简单功能的没必要做，会增加比较多的工作量前端常用单元测试框架mocha、Jest 提供了单元测试所需的各种 API，你可以使用它们来对你的代码进行单元测试对称加密 和 非对称加密对称加密加密与解密用的是同样的密钥效率高密钥越大，加密越强，但加密与解密的过程越慢通常使用相对较小的密钥，一般小于 256 bit缺点是不安全，在发送密钥的过程中，密钥有很大的风险会被黑客们拦截通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人非对称加密使用了一对密钥，公钥（public key）和私钥（private key）私钥只能由一方安全保管，不能外泄，公钥则可以发给任何请求它的人非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥使用公钥对消息加密，只有私钥的持有人才能对消息解密不需要将私钥通过网络发送出去，因此安全性大大提高常用的非对称加密算法是 RSA 算法相对对称加密较慢解决：将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通进程和线程进程 是操作系统进行资源分配和调度的独立单位，是应用程序运行的载体线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线同一个进程下的所有线程共享该进程的所有资源React 与 Vue 异同React 是手动挡，Vue 是自动挡异react 是函数式思想，all in js ，jsx 语法，js 操控 cssreact 是单项数据流react 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 shouldComponentUpdate 这个生命周期方法来进行控制，如果为 true 继续渲染、false 不渲染，但 Vue 将此视为默认的优化react 对 ts 更友好一些vue 是响应式思想，也就是基于数据可变的。把 html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中vue 是双向绑定Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树同使用 Virtual DOM，都有 jsx，性能好都是数据驱动视图后端一次给 10 万条数据，如何处理展示直接遍历渲染（耗时最高，不推荐）setTimeout 分页渲染：把 10w 按照每页数量 limit 分成总共 Math.ceil(total / limit)页，然后利用 setTimeout，每次渲染 1 页数据使用 requestAnimationFrame 代替上一条的 setTimeout文档碎片(createDocumentFragment) + requestAnimationFrame懒加载：在列表尾部放一个空节点 blank，等到 blank 出现在视图中（使用 getBoundingClientRect），就说明到底了，这时候再加载第二页，以此类推虚拟列表跨浏览器开发最佳实践封装垫片 polyfill不要污染全局调试排错技巧参考：https://developer.chrome.com/docs/devtools/前端界有哪些越早知道越好的小技巧、小知识？IDEA debug 断点调试技巧浏览器使用 debugger 关键字source 面板打断点chrome 移动页面调试工具：chrome://inspect/#deviceschrome dev tools 的请求重放功能webstorm 的 debug JavaScript in chrome 功能reactredux devtoolsreact developer toolsTop five useful Chrome Dev Tools tips for ReactNodejs使用 VScode 或 webstorm 的 debug 功能完全满足使用 pscp 实现 Windows 和 Linux 服务器间远程传递文件PSCP (PuTTY Secure Copy client)是 PuTTY 提供的文件传输工具，通过 SSH 连接，在两台机器之间安全的传输文件，可以用于任何 SSH（包括 SSH v1、SSH v2）服务器。redis 的雪崩和穿透原因某个时刻，多个键同时失效，大量请求打进数据库解决封装 redis 的 set 方法时，给过期时间随即加上时间戳什么是 Base64一个可逆编码算法可以将二进制数据（比如图片）转化为可打印字符，方便传输数据内容编码后体积变大， 至少 1/3，因为是三字节变成四个字节，当只有一个字节的时候，也至少会变成三个字节。由来早期邮件传输协议基于 ASCII 文本，对于诸如图片、视频等二进制文件处理并不好。 ASCII 主要用于显示现代英文，到目前为止只定义了 128 个字符，包含控制字符和可显示字符。 为了解决上述问题，Base64 编码顺势而生。Base64 是编解码，主要的作用不在于安全性，而在于让内容能在各个网关间无错的传输，这才是 Base64 编码的核心作用。算法描述三个字节作为一组，一共是 24 个二进制位，字节数不能被 3 整除，用 0 字节值在末尾补足即：如果一个数据有 6 个字节，可编码后将包含(6/3)*4=8 个字节按照 6 个比特位一组分组，前两位补 0，凑齐 8 位计算每个分组的数值当数据的长度无法满足 3 的倍数的情况下，最后的数据需要进行填充操作，即补“=”将原始数据的每三个字节分为一组，按位进行分割为每 6 位一个字节的形式，进行转换，形成新的 4 个字节。这四个字节才通过 Base64 编码表进行映射，形成最后实际的 Base64 编码结果。如果原始数据最后无法凑成 3 个字节，则补填充，以“=”作为替换，代表没有数据Base64 编码索引表：使用场景JSON 中传递二进制数据canvas 图片生成jwtwebpack 处理小图，减少 http 请求Unicode 字符集计算机使用 0 和 1 来存储文本。比如字符“C”被存成“01000011”，那么计算机在显示这个字符时需要经过两个步骤：计算机读取“01000011”，得到数字 67，因为 67 被编码成“01000011”。计算机在 Unicode 字符集中查找 67，找到了“C”。"},{"id":"网络.md","filename":"网络.md","basename":"网络","path":"/home/runner/work/my-book/my-book","relative_path":"","output_path":"/home/runner/work/my-book/my-book/dist","content":"参考https://www.cnblogs.com/leezhxing/p/4524176.htmlhttps://juejin.cn/post/6844904100035821575TCP/IPTCP 和 UDP 的区别tcp 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。tcp 提供可靠的服务。tcp 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。tcp 的首部较大为 20 字节，而 UDP 只有 8 字节。tcp 是面向连接的可靠性传输，而 UDP 是不可靠的。什么是 tcp 三次握手，为什么由 TCP 的自身特点可靠传输决定的客户端和服务端都需要知道各自是否可收发，因此需要三次握手第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）服务器发回一个带 SYN=1，ACK=X+1，Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）客户端再回传一个带 ACK=Y+1，Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）tcp 四次挥手发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)HTTP说一下常见请求头？Accept 可接受的响应内容类型CookieContent-Type 请求体的 MIME 类型OriginReferer 来源User-AgentCache-Control 强缓存相关Expires 强缓存相关Last-Modified 协商缓存相关Etag 协商缓存相关Access-Control-Allow-Origin 指定允许跨域的域名HTTP 2.01.0 协议缺点：文本协议传输，不够安全无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手线头阻塞，导致请求之间互相影响Header 内容繁多，有时有可能会超过响应内容，并且每次有许多字段都是重复传输基于以上缺点，也出现了许多优化手段：雪碧图、合并脚本和样式表、资源内联、域名分片等优化工作，但是如果 HTTP 协议足够好的话，本可以避免这些额外的操作。1.1 新特性长连接(默认 keep-alive)，复用断点续传身份认证状态管理cache 缓存头部标识Cache-ControlExpiresLast-ModifiedEtag2.0 新特性多路复用，单一长连接，二进制格式传输头部 header 压缩服务端推送多路复用什么是 http超文本传输协议，是一个客户端和服务器端请求和应答的标准，默认端口 80什么是 https是以安全为目的设计结合 ssl 协议，建立一个信息安全通道，来确保数组的传输，确保网站的真实性。http 传输的数据都是未加密的网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理需要证书，有成本默认端口 443HTTP 报文格式http 报文分为三部分：起始行、头部、主体起始行是对请求或响应的描述头部存放如 cookie、content-type 等主体存放数据，明文传输状态码1xx 信息，服务器收到请求，需要请求者继续执行操作2xx 成功，操作被成功接收并处理3xx 重定向，需要进一步的操作以完成请求4xx 客户端错误，请求包含语法错误或无法完成请求5xx 服务器错误，服务器在处理请求的过程中发生了错误100 表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略200 表明请求已经成功. 默认情况下状态码为 200 的响应可以被缓存201 表示请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。202 表示服务器端已经收到请求消息，但是尚未进行处理。但是对于请求的处理确实无保证的，即稍后无法通过 HTTP 协议给客户端发送一个异步请求来告知其请求的处理结果。204 表示目前请求成功，但客户端不需要更新其现有页面。301 永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。302 临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个 URL，但是搜索引擎不会对该资源的链接进行更新304 Not Modified 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在 GET 请求, 或在请求中附带了头部信息：If-None-Match 或 If-Modified-Since307 临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。308 永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。400 表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。401 说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。403 指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）404 说明服务器端无法找到所请求的资源。405 Method Not Allowed 表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。500 表示所请求的服务器遇到意外的情况并阻止其执行请求，比如服务端代码语法错误502 表示作为网关或代理角色的服务器，从上游服务器（如 tomcat、php-fpm）中接收到的响应是无效的。504 表示网关或者代理的服务器无法在规定的时间内获得想要的响应。比如 代码执行时间超时，或死循环了。301 和 302 区别302 重定向只是暂时的重定向，例如未登陆的用户访问用户中心重定向到登录页面。因为服务器返回 302，所以，搜索搜索引擎认为新的网址是暂时的，搜索引擎会抓取新的内容而保留旧的地址。301 重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址options 请求OPTIONS 方法是用于请求获得由 Request-URI 标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。HTTP 队头阻塞“队头阻塞”与短连接和长连接无关，而是由 HTTP 基本的“请求 - 应答”模型所导致的。因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。 解决：域名分片，多开几个域名，而这些域名都指向同一个服务器post 和 get 区别GET 和 POST 方法没有实质区别，只是报文格式不同。约定上，get 一般使用 url 传参，post 一般使用 body 传参，实际上 post 也可以 url 传参。GET 请求会被浏览器主动缓存下来，GET 没有副作用，点击浏览器后退和刷新按钮时，POST 的数据会被重新提交，GET 可以收藏为书签，GET 参数可被浏览器历史保存。GET 的参数长度受到浏览器限制，http 协议上并没有限制。POST 无限制。数据类型 GET 只允许传 ASCII 字符，POST 没有限制，允许传二进制数据。POST 并不比 GET 安全，只有 https 才是安全的。get 请求传参长度的误区：误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。 实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:HTTP 协议 未规定 GET 和 POST 的长度限制GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度不同的浏览器和 WEB 服务器，限制的最大长度不一样从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)https://segmentfault.com/a/1190000018129846https://juejin.im/post/59fc04ecf265da4317697f26cookie主要作用：会话状态管理、个性化设置、浏览器行为跟踪一段一般不超过 4KB 的小型文本数据由名称（name）、值（value）和其它几个用于控制 Cookie 有效期、安全性、使用范围的可选属性组成Expires 用于设置 Cookie 的过期时间Max-Age 用于设置在 Cookie 失效之前需要经过的秒数Domain 指定了 Cookie 可以送达的主机名。Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。设置 HTTPOnly 属性可以防止客户端脚本访问 Cookie，保证安全，例如 XSS 攻击。SameSite 是最近非常值得一提的内容，因为新的 Chrome80 版本中默认屏蔽了第三方的 Cookiecookie 缺点大小只有 4kb、会增加请求大小个数限制、长度限制不安全，有可能被截获相比 localstorage， 需要自己封装 setter 和 gettercookie-sessionHTTP 是一个无状态的协议。为了解决 HTTP 无状态导致的问题，出现了 Cookie，为了解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。第一次请求服务端的时候，服务端响应报头出现一个 Set-Cookie 字段，在客户端设置一个 cookie，当再次请求服务端的时候，请求会附带这个 cookie 过去，cookie 中存有 sessionId 这样的信息来到服务端这边确认是否属于同一次会话。当客户端请求创建一个 session 的时候，服务端会先检查这个客户端的请求里是否已包含了一个 session 标识 - sessionId，如果已包含这个 sessionId，则说明以前已经为此客户端创建过 session，服务端就按照 sessionId 把这个 session 检索出来使用跨域请求如何携带 cookie服务端设置 Access-Control-Allow-Origin 响应头，为允许跨域的域服务端设置 Access-Control-Allow-Credentials 响应头 为 true请求时设置 withCredentials 为 truewithCredentials 是什么XMLHttpRequest 的一个请求配置指示了是否该使用类似 cookies,authorization headers(头部授权)或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制"}]