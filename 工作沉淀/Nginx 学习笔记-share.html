<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - Nginx 学习笔记</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：3/30/2022, 8:49:50 AM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <div class="content markdown-body"><blockquote>
<p>工作中经常用的，简单记录一下。</p>
</blockquote>
<h1>实用</h1>
<ul>
<li>跨域</li>
</ul>
<pre><code class="language-nginx"># 这里约定代理请求url path是以/apis/开头
location ^~/apis/ {
    # 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配
    rewrite ^/apis/(.*)$ /$1 break;
    ...
    proxy_pass https://www.tianqiapi.com/;
}
</code></pre>
<ul>
<li>处理前端单页应用的 history 路由模式</li>
</ul>
<pre><code class="language-nginx">location / {
    try_files $uri $uri/ /index.html;
}
</code></pre>
<ul>
<li>适配 PC 和移动环境</li>
</ul>
<pre><code class="language-nginx">location / {
    # 移动、pc设备适配
    if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') {
        set $mobile_request '1';
    }
    if ($mobile_request = '1') {
        rewrite ^.+ http://mysite-base-H5.com;
    }
}

</code></pre>
<ul>
<li>端口转发</li>
</ul>
<pre><code class="language-nginx">http {
    ...
    upstream dmp8001 {
        server 127.0.0.1:8001;
    }
    server {
        listen       80;
        server_name  abc.com;

        location / {
            ...
            proxy_pass http://dmp8001;
        }
    }
    ...
}
</code></pre>
<ul>
<li>善用正则</li>
</ul>
<pre><code class="language-nginx"># 动态校验企业微信 h5 应用可信域名
location ~ WW_verify_(.*).txt {
    return 200 $1;
}
</code></pre>
<ul>
<li>虚拟主机</li>
</ul>
<pre><code class="language-nginx">server {
    listen 12332;
    server_name 127.0.0.1;

    location / {
        root D:/Desktop/test;
        index index.html index.htm;
    }
}
</code></pre>
<ul>
<li>防媒体文件盗链</li>
</ul>
<pre><code class="language-nginx">location ~* \.(gif|jpg|png|jpeg|mp4)$ {

    expires 30d;
    valid_referers *.hugao8.com www.hugao8.com m.hugao8.com *.baidu.com *.google.com;

    if ($invalid_referer) {
        rewrite ^/ http://ww4.sinaimg.cn/bmiddle/051bbed1gw1egjc4xl7srj20cm08aaa6.jpg;
        # return 404;
    }

}
</code></pre>
<h1>简单实现负载均衡</h1>
<ul>
<li>轮询（默认），请求过来后，Nginx 随机分配流量到任一服务器</li>
</ul>
<pre><code class="language-nginx">upstream backend {
    server 127.0.0.1:3000;
    server 127.0.0.1:3001;
}
</code></pre>
<ul>
<li>weight=number 设置服务器的权重，默认为 1，权重大的会被优先分配</li>
</ul>
<pre><code class="language-nginx">upstream backend {
    server 127.0.0.1:3000 weight=2;
    server 127.0.0.1:3001 weight=1;
}
</code></pre>
<ul>
<li>backup 标记为备份服务器。当主服务器不可用时，将传递与备份服务器的连接</li>
</ul>
<pre><code class="language-nginx">upstream backend {
    server 127.0.0.1:3000 backup;
    server 127.0.0.1:3001;
}
</code></pre>
<p>代理这个集群</p>
<pre><code class="language-nginx">server {
    listen      9000;
    server_name localhost;

    location / {
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Scheme $scheme;

        proxy_pass backend;
    }
}
</code></pre>
<h1>关于 location 的匹配</h1>
<h2>location 的几种匹配方式</h2>
<p>普通匹配：</p>
<pre><code class="language-nginx">location = URI { configuration } #精确匹配
location ^~ URI { configuration } #非正则匹配
location [空格] URI { configuration } #前缀匹配
</code></pre>
<p>正则匹配：</p>
<pre><code class="language-nginx">location ~ URI { configuration } #区分大小写
location ~* URI { configuration } #不区分大小写
</code></pre>
<h2>几种匹配方式的说明与优先级</h2>
<p>整体规则按照先普通匹配，然后再正则匹配，如果正则不匹配，则回退至上一个普通匹配。其中普通匹配没有顺序之分，哪个匹配最精确，就使用哪个 location，正则匹配按照<mark>规则的书写顺序</mark>进行。</p>
<ul>
<li><code>=</code> 精确匹配，匹配后停止后续匹配，直接执行该匹配后的 configuration。</li>
<li><code>[空格]</code> 前缀匹配，匹配后，继续更长前缀匹配和正则匹配。</li>
<li><code>^~</code> <mark>不属于正则匹配</mark>，匹配该规则后，停止继续正则匹配。</li>
<li><code>~</code> 区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。</li>
<li><code>~*</code> 不区分大小写的正则匹配，按顺序匹配，一旦匹配即停止后续匹配。</li>
</ul>
<h2>示例</h2>
<pre><code class="language-nginx">location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /user/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}
</code></pre>
<ul>
<li>请求<code>/</code>精准匹配 A，不再往下查找。</li>
<li>请求<code>/index.html</code>匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。</li>
<li>请求<code>/user/index.html</code>匹配 C。首先找到最长匹配 C，由于后面没有匹配的<mark>正则</mark>，所以使用最长匹配 C。</li>
<li>请求<code>/user/1.jpg</code>匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。</li>
<li>请求<code>/images/1.jpg</code>匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了^~修饰符，<mark>不再进行接下来的正则的匹配查找</mark>，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。</li>
<li>请求<code>/documents/about.html</code>匹配 B。因为 B 表示任何以/开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。</li>
</ul>
<h2>总结</h2>
<ul>
<li>location 的配置有两种形式，普通和正则。</li>
<li>查找匹配的时候，先查找普通，选择最长匹配项，再查找正则。</li>
<li>正则的优先级高于普通。</li>
<li>正则查找是<mark>按照在配置文件中的顺序</mark>进行的，因此正则顺序很重要，建议越精细的放的越靠前。</li>
<li>使用<code>=</code>精准匹配可以加快查找的效率，如果经常被访问建议使用精确匹配<code>=</code>。</li>
</ul>
</div>
  </body>
</html>
