<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Book - 我的最佳实践</title>

  <link rel="stylesheet" href="/my-book/resource/lib/github-markdown.min.css" />
  <link rel="stylesheet" href="/my-book/resource/style.css" />
  <link rel="stylesheet" href="/my-book/resource/lib/highlight/default.min.css" />
  <script src="/my-book/resource/lib/highlight/highlight.min.js"></script>
  <script src="/my-book/resource/lib/jquery.min.js"></script>
  <script src="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.js"></script>
  <script src="//unpkg.com/jquery-viewer@1.0.1/dist/jquery-viewer.min.js"></script>
  <link rel="stylesheet" href="//unpkg.com/viewerjs@1.10.4/dist/viewer.min.css" />

  <link rel="manifest" href="/my-book/manifest.json" />
  <link rel="shortcut icon" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="bookmark" type="image/x-icon" href="/my-book/resource/favicon.ico" />
  <link rel="apple-touch-icon" href="/my-book/resource/favicon.ico" />

  <!-- 编译时间：4/2/2022, 10:02:47 AM -->

  <script>
    window.root = '/my-book';
    hljs.highlightAll();
  </script>

  <script src="/my-book/resource/script.js"></script>
</head>

  <body>
    <ul class="menu" id="menu">
      
            <ul class="parent open">
              <li id="工作沉淀" class="dir">
                <span>工作沉淀</span>
                <div class="triangle"></div>
              </li>
              
          <li id="工作沉淀/Fiddler 真机调试微信 h5.md" class="children">
            <a href="/my-book/工作沉淀/Fiddler 真机调试微信 h5.html">Fiddler 真机调试微信 h5</a>
          </li>
        
          <li id="工作沉淀/GitFlow 学习笔记.md" class="children">
            <a href="/my-book/工作沉淀/GitFlow 学习笔记.html">GitFlow 学习笔记</a>
          </li>
        
          <li id="工作沉淀/Nginx 学习笔记.md" class="children">
            <a href="/my-book/工作沉淀/Nginx 学习笔记.html">Nginx 学习笔记</a>
          </li>
        
          <li id="工作沉淀/工作中遇到问题汇总.md" class="children">
            <a href="/my-book/工作沉淀/工作中遇到问题汇总.html">工作中遇到问题汇总</a>
          </li>
        
          <li id="工作沉淀/我的最佳实践.md" class="children">
            <a href="/my-book/工作沉淀/我的最佳实践.html">我的最佳实践</a>
          </li>
        
          <li id="工作沉淀/敏捷迭代.md" class="children">
            <a href="/my-book/工作沉淀/敏捷迭代.html">敏捷迭代</a>
          </li>
        
          <li id="工作沉淀/登录方案.md" class="children">
            <a href="/my-book/工作沉淀/登录方案.html">登录方案</a>
          </li>
        
          <li id="工作沉淀/设计稿多端适配方案.md" class="children">
            <a href="/my-book/工作沉淀/设计稿多端适配方案.html">设计稿多端适配方案</a>
          </li>
        
            </ul>
          
            <ul class="parent open">
              <li id="前端技术" class="dir">
                <span>前端技术</span>
                <div class="triangle"></div>
              </li>
              
            <ul class="parent open">
              <li id="前端技术/浏览器" class="dir">
                <span>浏览器</span>
                <div class="triangle"></div>
              </li>
              
          <li id="前端技术/浏览器/其他.md" class="children">
            <a href="/my-book/前端技术/浏览器/其他.html">其他</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器架构.md" class="children">
            <a href="/my-book/前端技术/浏览器/浏览器架构.html">浏览器架构</a>
          </li>
        
          <li id="前端技术/浏览器/浏览器缓存.md" class="children">
            <a href="/my-book/前端技术/浏览器/浏览器缓存.html">浏览器缓存</a>
          </li>
        
            </ul>
          
          <li id="前端技术/AST抽象语法树.md" class="children">
            <a href="/my-book/前端技术/AST抽象语法树.html">AST抽象语法树</a>
          </li>
        
          <li id="前端技术/Babel.md" class="children">
            <a href="/my-book/前端技术/Babel.html">Babel</a>
          </li>
        
          <li id="前端技术/Browserslist.md" class="children">
            <a href="/my-book/前端技术/Browserslist.html">Browserslist</a>
          </li>
        
          <li id="前端技术/CSS.md" class="children">
            <a href="/my-book/前端技术/CSS.html">CSS</a>
          </li>
        
          <li id="前端技术/Fiber.md" class="children">
            <a href="/my-book/前端技术/Fiber.html">Fiber</a>
          </li>
        
          <li id="前端技术/Hooks.md" class="children">
            <a href="/my-book/前端技术/Hooks.html">Hooks</a>
          </li>
        
          <li id="前端技术/Nodejs.md" class="children">
            <a href="/my-book/前端技术/Nodejs.html">Nodejs</a>
          </li>
        
          <li id="前端技术/PWA.md" class="children">
            <a href="/my-book/前端技术/PWA.html">PWA</a>
          </li>
        
          <li id="前端技术/React.md" class="children">
            <a href="/my-book/前端技术/React.html">React</a>
          </li>
        
          <li id="前端技术/Typescript.md" class="children">
            <a href="/my-book/前端技术/Typescript.html">Typescript</a>
          </li>
        
          <li id="前端技术/Vue.md" class="children">
            <a href="/my-book/前端技术/Vue.html">Vue</a>
          </li>
        
          <li id="前端技术/Webpack.md" class="children">
            <a href="/my-book/前端技术/Webpack.html">Webpack</a>
          </li>
        
          <li id="前端技术/npm.md" class="children">
            <a href="/my-book/前端技术/npm.html">npm</a>
          </li>
        
          <li id="前端技术/函数式编程.md" class="children">
            <a href="/my-book/前端技术/函数式编程.html">函数式编程</a>
          </li>
        
          <li id="前端技术/微信开发.md" class="children">
            <a href="/my-book/前端技术/微信开发.html">微信开发</a>
          </li>
        
          <li id="前端技术/微前端.md" class="children">
            <a href="/my-book/前端技术/微前端.html">微前端</a>
          </li>
        
          <li id="前端技术/手写题.md" class="children">
            <a href="/my-book/前端技术/手写题.html">手写题</a>
          </li>
        
          <li id="前端技术/模块.md" class="children">
            <a href="/my-book/前端技术/模块.html">模块</a>
          </li>
        
          <li id="前端技术/虚拟列表.md" class="children">
            <a href="/my-book/前端技术/虚拟列表.html">虚拟列表</a>
          </li>
        
          <li id="前端技术/设计模式.md" class="children">
            <a href="/my-book/前端技术/设计模式.html">设计模式</a>
          </li>
        
          <li id="前端技术/语言基础.md" class="children">
            <a href="/my-book/前端技术/语言基础.html">语言基础</a>
          </li>
        
            </ul>
          
          <li id="其他.md" class="children">
            <a href="/my-book/其他.html">其他</a>
          </li>
        
          <li id="网络.md" class="children">
            <a href="/my-book/网络.html">网络</a>
          </li>
        

      <li id="index.md" class="children about">
        <a href="/my-book/">关于</a>
      </li>
    </ul>
    <div class="mobile_menu" id="mobile_menu">
      <img src="https://cdn.jsdelivr.net/gh/FortAwesome/font-awesome/svgs/solid/bars.svg" alt="" />
    </div>
    <div class="content markdown-body"><blockquote>
<p>总结开发中常用的习惯和模式。</p>
</blockquote>
<h1 id="%E5%8F%82%E8%80%83" tabindex="-1"><a class="header-anchor" href="#%E5%8F%82%E8%80%83" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> 参考</h1>
<ul>
<li><a href="https://isamatov.com/simple-tips-for-writing-clean-react-components/" target="_blank">Simple tips for writing clean React components</a></li>
<li><a href="https://react-typescript-cheatsheet.netlify.app/" target="_blank">React TypeScript Cheatsheet</a></li>
<li><a href="https://juejin.im/post/5e021eb96fb9a01628014095" target="_blank">JavaScript 设计模式</a></li>
</ul>
<h1 id="javascript" tabindex="-1"><a class="header-anchor" href="#javascript" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> Javascript</h1>
<ul>
<li>先声明后调用</li>
<li>声明变量优先使用 const</li>
<li>常量大写</li>
<li>不要忽略抛异常、不要忘了在 Promise\async await 抛异常</li>
<li>缓存耗时的计算，比如 dom 节点查找结果、设备信息查询结果等</li>
<li>尽可能使用原生方法，因为原生方法是用低级语言写的（C/C++），并且被编译成机器码，效率更高，比如 Array 的 filter</li>
<li>少用 for-in，比其他循环方式明显要慢，因为 for-in 要搜索原型属性</li>
<li>基于函数的迭代 forEach 比一般的循环要慢，如果对运行速度要求很严格，不要使用</li>
<li>使用枚举或策略模式减少 elseif，使用 Map、Object 优化 switch-case</li>
<li>?? 空值合并操作符、?. 链合并运算符</li>
<li>少写 console（或提交代码时删除 console），善于利用浏览器或 IDE 自带的 debugger 工具来调试，项目跑起来一堆的日志让队友很头疼</li>
<li>多元判断时，可将条件拼接成字符串存到 Object 里</li>
</ul>
<pre><code class="language-js">/**
 * 按钮点击事件
 * @param {number} status 活动状态：1未开始 2进行中 3 结束
 * @param {string} identity 身份标识：guest游客 admin管理员
 */
const onButtonClick = (status, identity) =&gt; {
    if (identity == 'guest') {
        if (status == 1) {
            //do sth
        } else if (status == 2) {
            //do sth
        } else if (status == 3) {
            //do sth
        } else {
            //do sth
        }
    } else if (identity == 'admin') {
        if (status == 1) {
            //do sth
        } else if (status == 2) {
            //do sth
        } else if (status == 3) {
            //do sth
        } else {
            //do sth
        }
    }
};

// 可优化为
const actions = new Map([
    [
        'guest_1',
        () =&gt; {
            /*do sth*/
        },
    ],
    [
        'guest_2',
        () =&gt; {
            /*do sth*/
        },
    ],
    [
        'guest_3',
        () =&gt; {
            /*do sth*/
        },
    ],
    [
        'admin_1',
        () =&gt; {
            /*do sth*/
        },
    ],
    [
        'admin_2',
        () =&gt; {
            /*do sth*/
        },
    ],
    [
        'admin_3',
        () =&gt; {
            /*do sth*/
        },
    ],
    [
        'default',
        () =&gt; {
            /*do sth*/
        },
    ],
]);

/**
 * 按钮点击事件
 * @param {string} identity 身份标识：guest游客 admin管理员
 * @param {number} status 活动状态：1未开始 2进行中 3 结束
 */
const onButtonClick = (identity, status) =&gt; {
    let action = actions.get(`${identity}_${status}`) || actions.get('default');
    action.call(this);
};
</code></pre>
<ul>
<li>可适当使用对象区分作用域</li>
<li>使用 Array.includes 来优化多个条件的判断</li>
<li>使用 Array.every 和 Array.some 来处理全部/部分满足条件</li>
<li>减少嵌套，提前使用 return 语句</li>
<li>用有意义且常用的单词命名变量</li>
</ul>
<pre><code class="language-js">// 错误：
const yyyymmdstr = moment().format('YYYY/MM/DD');
// 正确:
const currentDate = moment().format('YYYY/MM/DD');
</code></pre>
<ul>
<li>保持统一命名<br>
可能同一个项目对于获取用户信息，会有三个不一样的命名，应该保持统一。</li>
</ul>
<pre><code class="language-js">// 错误：
getUserInfo();
getClientData();
getCustomerRecord();

// 正确：
getUser();
</code></pre>
<ul>
<li>尽量少写魔法值，每个常量都该命名</li>
</ul>
<pre><code class="language-js">// 错误：
// 三个月之后你还能知道 86400000 是什么吗?
setTimeout(doSomeThing, 86400000);

// 正确：
const MILLISECOND_IN_A_DAY = 86400000;
setTimeout(doSomeThing, MILLISECOND_IN_A_DAY);
</code></pre>
<ul>
<li>避免无意义的前缀<br>
如果创建了一个对象 car，就没有必要把它的颜色命名为 carColor。</li>
</ul>
<pre><code class="language-js">// 错误：
const car = {
    carMake: 'Honda',
    carModel: 'Accord',
    carColor: 'Blue',
};

function paintCar(car) {
    car.carColor = 'Red';
}

// 正确：
const car = {
    make: 'Honda',
    model: 'Accord',
    color: 'Blue',
};

function paintCar(car) {
    car.color = 'Red';
}
</code></pre>
<ul>
<li>使用函数参数默认值</li>
</ul>
<pre><code class="language-js">// 错误：
function doSomeThing(name) {
    const username = name || 'tony';
    // ...
}

// 正确：
function doSomeThing(name = 'tony') {
    // ...
}
</code></pre>
<ul>
<li>参数越少越好<br>
如果参数超过两个，使用解构语法，不用考虑参数的顺序。</li>
</ul>
<pre><code class="language-js">// 错误：
function createMenu(title, body, buttonText, cancellable) {
    // ...
}

// 正确：
function createMenu({ title, body, buttonText, cancellable }) {
    // ...
}

createMenu({
    title: 'Foo',
    body: 'Bar',
    buttonText: 'Baz',
    cancellable: true,
});
</code></pre>
<ul>
<li>
<p>抽象重复代码<br>
很多时候虽然是同一个功能，但由于一两个不同点，让你不得不写两个几乎相同的函数，要想优化重复代码需要有较强的抽象能力。</p>
</li>
<li>
<p>不传 flag 参数<br>
不要通过 flag 的 true 或 false，来判断执行逻辑。</p>
</li>
<li>
<p>不污染全局<br>
在 JavaScript 中不要污染全局，会容易产生难以预料的 bug。</p>
</li>
<li>
<p>删除弃用代码<br>
可以在代码库历史版本中找到它。</p>
</li>
<li>
<p>使用 class</p>
</li>
<li>
<p>链式调用<br>
这种模式让的代码简洁优雅，在类的方法最后返回 this 就可以了。</p>
</li>
</ul>
<pre><code class="language-js">class Car {
    constructor(make, model, color) {
      this.make = make;
      this.model = model;
      this.color = color;
    }

    setMake(make) {
      this.make = make;
      return this;
    }

    setModel(model) {
      this.model = model;
      return this;
    }

    setColor(color) {
      this.color = color;
      return this;
    }

    save() {
      console.log(this.make, this.model, this.color);
      return this;
    }
}

const car = new Car('Ford','F-150','red')
  .setColor('pink');
  .save();
</code></pre>
<ul>
<li>
<p>单一功能原则<br>
如果一个类干的事情太多太杂，会导致后期很难维护。我们应该厘清职责，各司其职减少相互之间依赖。</p>
</li>
<li>
<p>封闭开放原则<br>
“当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码”<br>
比如我想修改一个公共组件的样式来适配自己的页面，但又需要保证其他使用这个组件的页面不受影响，可以通过增加一个主题参数，根据该参数加载一份新的样式文件</p>
</li>
</ul>
<h1 id="react" tabindex="-1"><a class="header-anchor" href="#react" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> React</h1>
<ul>
<li>定义类组件时，使用 PropTypes 对属性进行类型检查和赋予默认值（deprecate）</li>
<li>组件属性超过 3 个则换行</li>
<li>多用函数组件，更小的打包体积，更高的执行效率</li>
<li>多用 PureComponent，PureComponent 会先对 state 和 props 进行浅比较，不同的时候才会 render</li>
<li>遵循单一职责原则，使用 HOC / 装饰器 / Render Props 增加职责</li>
<li>react 组件文件用 jsx，用大驼峰命名 jsx 文件</li>
<li>表达式中的 jsx 使用圆括号包裹</li>
<li>每个文件只写一个组件，但是多个无状态组件可以放在单个文件中，文件名要与默认导出的类名一致</li>
<li>组合优于继承</li>
<li>性能原因尽量不写内联函数，比如点击事件</li>
<li>封装切换类型的组件时，使用一个配置数组来减少判断（策略模式）</li>
<li>多使用解构，例如声明函数组件的 props 和 默认值</li>
</ul>
<pre><code class="language-jsx">export default ({ name = '小明', sex = '男' }) =&gt; (
    &lt;&gt;
        我叫 {name}，性别 {sex}
    &lt;/&gt;
);
</code></pre>
<ul>
<li>没有子元素的组件写成自闭合</li>
</ul>
<pre><code class="language-jsx">// 错误：
&lt;Foo&gt;&lt;/Foo&gt;

// 正确：
&lt;Foo/&gt;
</code></pre>
<ul>
<li>组件属性命名保持统一，使兼容性良好，避免无意义前缀</li>
</ul>
<pre><code class="language-jsx">// 错误，心塞
&lt;MyInput inputValue onInputChange wrapStyle wrapClassName /&gt;

// 正确
&lt;MyInput value onChange style className /&gt;
</code></pre>
<ul>
<li>避免在 render 里面动态创建对象 / 方法，否则会导致子组件每次都 render</li>
</ul>
<pre><code class="language-jsx">// 错误：
render() {
    const obj = {num: 1}

    return (
        &lt;Child obj={obj} onClick={()=&gt;{...}} /&gt;
    );
}
</code></pre>
<ul>
<li>避免在 JSX 中写复杂的三元表达式，应通过封装函数或组件实现</li>
</ul>
<pre><code class="language-jsx">// 错误：
render() {
    const a = 8;
    return (
        &lt;div&gt;
            {
                a &gt; 0 ? a &lt; 9 ? ... : ... : ...
            }
        &lt;/div&gt;
    );
}
</code></pre>
<pre><code class="language-jsx">// 正确：
f() {
    ...
}

render() {
    const a = 8;

    return (
        &lt;div&gt;
            {
                this.f()
            }
        &lt;/div&gt;
    );
}
</code></pre>
<ul>
<li>使用运算符&amp;&amp;简化三元运算<br>
在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false，因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。</li>
</ul>
<p>例如：</p>
<pre><code class="language-jsx">{
    loading ? &lt;Loading /&gt; : null;
}
</code></pre>
<p>可简化为</p>
<pre><code class="language-jsx">{
    loading &amp;&amp; &lt;Loading /&gt;;
}
</code></pre>
<ul>
<li>
<p>尽量避免使用展开运算符来展开 props<br>
变得难以理解和维护，容易出 bug</p>
</li>
<li>
<p>遇到事件处理，使用一个返回新函数的方法<br>
例如：</p>
</li>
</ul>
<pre><code class="language-jsx">import React from 'react';

export default function SampleComponent({ onValueChange }) {
    const handleChange = (key) =&gt; {
        return (e) =&gt; onValueChange(key, e.target.value);
    };

    return (
        &lt;form&gt;
            &lt;input onChange={handleChange('name')} /&gt;
            &lt;input onChange={handleChange('email')} /&gt;
            &lt;input onChange={handleChange('phone')} /&gt;
        &lt;/form&gt;
    );
}
</code></pre>
<p>这样看起来比较简洁</p>
<ul>
<li>使用 Hook components<br>
比如要封装一个弹窗组件：</li>
</ul>
<pre><code class="language-jsx">// 组件
import React, { useCallback, useState } from 'react';
import ConfirmationDialog from 'components/global/ConfirmationDialog';

export default function useConfirmationDialog({ headerText, bodyText, confirmationButtonText, onConfirmClick }) {
    const [isOpen, setIsOpen] = useState(false);

    const onOpen = () =&gt; {
        setIsOpen(true);
    };

    const Dialog = useCallback(
        () =&gt; (
            &lt;ConfirmationDialog
                headerText={headerText}
                bodyText={bodyText}
                isOpen={isOpen}
                onConfirmClick={onConfirmClick}
                onCancelClick={() =&gt; setIsOpen(false)}
                confirmationButtonText={confirmationButtonText}
            /&gt;
        ),
        [isOpen]
    );

    return {
        Dialog,
        onOpen,
    };
}
</code></pre>
<pre><code class="language-jsx">// 使用
import React from 'react';
import { useConfirmationDialog } from './useConfirmationDialog';

function Client() {
    const { Dialog, onOpen } = useConfirmationDialog({
        headerText: 'Delete this record?',
        bodyText: 'Are you sure you want delete this record? This cannot be undone.',
        confirmationButtonText: 'Delete',
        onConfirmClick: handleDeleteConfirm,
    });

    function handleDeleteConfirm() {}

    const handleDeleteClick = () =&gt; {
        onOpen();
    };

    return (
        &lt;div&gt;
            &lt;Dialog /&gt;
            &lt;button onClick={handleDeleteClick} /&gt;
        &lt;/div&gt;
    );
}

export default Client;
</code></pre>
<p>这种模式可以少写很多与组件相关的 state，比如弹窗的 visible、title 之类的</p>
<ul>
<li>将业务逻辑封装进 hooks，业务逻辑与 UI 分离（关注点分离）</li>
</ul>
<pre><code class="language-jsx">// 例如：
import React from 'react';
import ItemDisplay from './ItemDisplay';

export default function SampleComponent() {
    const { data, handleDelete, handleEdit, handleAdd } = useCustomHook();

    return (
        &lt;div&gt;
            &lt;div&gt;
                {data.map((item) =&gt; (
                    &lt;ItemDisplay item={item} /&gt;
                ))}
            &lt;/div&gt;
            &lt;div&gt;
                &lt;button onClick={handleDelete} /&gt;
                &lt;button onClick={handleAdd} /&gt;
                &lt;button onClick={handleEdit} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}
</code></pre>
<ul>
<li>
<p>不要把所有状态存放在 redux，redux 只用于存放用户登录信息、主题等信息</p>
</li>
<li>
<p>不要任何变量都使用状态，可以使用 useRef 或成员属性（类组件）来储存与更新渲染无关的变量，可以通过已保存的状态来推断出的状态可使用 useMemo 来计算，而不要创建新状态</p>
</li>
<li>
<p>尽量不要在组件中声明新的组件</p>
<pre><code class="language-jsx">// 错误，不建议
function A() {
    const B = () =&gt; {
        return &lt;p&gt;hello&lt;/p&gt;;
    };

    return (
        &lt;div&gt;
            &lt;B /&gt;
        &lt;/div&gt;
    );
}
</code></pre>
<p>原因：</p>
<p>高耦合<br>
影响性能，A 每一次渲染都会重新声明一遍 B</p>
</li>
<li>
<p>尽量避免向组件传递</p>
</li>
<li>
<p>避免为了优化少量性能过度设计代码，反而降低了代码的可维护性、易读性，浪费时间</p>
</li>
</ul>
<h1 id="typescript" tabindex="-1"><a class="header-anchor" href="#typescript" aria-hidden="true"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a> Typescript</h1>
<ul>
<li>接口命名以大写字母“I”开头，来自：<a href="http://wiki.eclipse.org/Naming_Conventions#Classes_and_Interfaces" target="_blank">eclipse 的建议</a></li>
<li>少写 any</li>
<li>类型定义文件(.d.ts)如何放置
<ul>
<li>临时的类型，直接在使用时定义</li>
<li>组件个性化类型，直接定义在 ts(x)文件中</li>
<li>范围/全局数据，定义在.d.ts 文件中</li>
</ul>
</li>
</ul>
</div>
    
    <div class="table-of-contents"><ul><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#javascript">Javascript</a></li><li><a href="#react">React</a></li><li><a href="#typescript">Typescript</a></li></ul></div>
    
  </body>
</html>
